/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.6 Copyright jQuery Foundation and other contributors.
 * Released under mit license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.6',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
            /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttps://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                //baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                        scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                            normalize(name, parentName, applyMap) :
                            name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                '_unnormalized' + (unnormalizedCounter += 1) :
                '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                    prefix + '!' + normalizedName :
                    normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function (queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                            this.map.parentMap,
                            true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                'fromText eval for ' + id +
                                ' failed: ' + e,
                                e,
                                [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                            (this.map.isDefine ? this.map : this.map.parentMap),
                            false,
                            !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function (err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function (id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                            .replace(currDirRegExp, '')
                            .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                id +
                                '" has not been loaded yet for context: ' +
                                contextName +
                                (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                            relMap && relMap.id, true), ext, true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function (args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                'No define call for ' + moduleName,
                                null,
                                [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                    url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                    (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function (value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function (depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                        (parents.length ?
                            '", needed by: ' + parents.join(', ') :
                            '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
            document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
            document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                //Check if node.attachEvent is artificially added by custom script or
                //natively supported by browser
                //read https://github.com/requirejs/requirejs/issues/187
                //if we can NOT find [native code] then it must NOT natively supported.
                //in IE8, node.attachEvent does not have toString()
                //Note the test for "[native code" with no closing brace, see:
                //https://github.com/requirejs/requirejs/issues/273
                !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function () { }, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                    'importScripts failed for ' +
                    moduleName + ' at ' + url,
                    e,
                    [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/') + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

define("requirejs", function () { });


/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function (C, e) { "use strict"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function (e) { return t.flat.call(e) } : function (e) { return t.concat.apply([], e) }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item }, x = function (e) { return null != e && e === e.window }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement("script"); if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o) } function w(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e } var f = "3.6.0", S = function (e, t) { return new S.fn.init(e, t) }; function p(e) { var t = !!e && "length" in e && e.length, n = w(e); return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e) } S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function () { return s.call(this) }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return S.each(this, e) }, map: function (n) { return this.pushStack(S.map(this, function (e, t) { return n.call(e, t, e) })) }, slice: function () { return this.pushStack(s.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(S.grep(this, function (e, t) { return (t + 1) % 2 })) }, odd: function () { return this.pushStack(S.grep(this, function (e, t) { return t % 2 })) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0 <= n && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: u, sort: t.sort, splice: t.splice }, S.extend = S.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, S.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n) }, each: function (e, t) { var n, r = 0; if (p(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, makeArray: function (e, t) { var n = t || []; return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r }, map: function (e, t, n) { var r, i, o = 0, a = []; if (p(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i); else for (o in e) null != (i = t(e[o], o, n)) && a.push(i); return g(a) }, guid: 1, support: y }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { n["[object " + t + "]"] = t.toLowerCase() }); var d = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date, p = n.document, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), j = function (e, t) { return e === t && (l = !0), 0 }, D = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]", F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", B = new RegExp(M + "+", "g"), $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), _ = new RegExp("^" + M + "*," + M + "*"), z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp(M + "|>"), X = new RegExp(F), V = new RegExp("^" + I + "$"), G = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + F), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + R + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /HTML$/i, Q = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"), ne = function (e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, oe = function () { T() }, ae = be(function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }, { dir: "parentNode", next: "legend" }); try { H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType } catch (e) { H = { apply: t.length ? function (e, t) { L.apply(e, O.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function se(t, e, n, r) { var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9; if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n; if (!r && (T(e), e = e || C, E)) { if (11 !== p && (u = Z.exec(t))) if (i = u[1]) { if (9 === p) { if (!(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n } if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) { if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) { (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length; while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]); c = l.join(",") } try { return H.apply(n, f.querySelectorAll(c)), n } catch (e) { N(t, !0) } finally { s === S && e.removeAttribute("id") } } } return g(t.replace($, "$1"), e, n, r) } function ue() { var r = []; return function e(t, n) { return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n } } function le(e) { return e[S] = !0, e } function ce(e) { var t = C.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function fe(e, t) { var n = e.split("|"), r = n.length; while (r--) b.attrHandle[n[r]] = t } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function de(t) { return function (e) { return "input" === e.nodeName.toLowerCase() && e.type === t } } function he(n) { return function (e) { var t = e.nodeName.toLowerCase(); return ("input" === t || "button" === t) && e.type === n } } function ge(t) { return function (e) { return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t } } function ve(a) { return le(function (o) { return o = +o, le(function (e, t) { var n, r = a([], e.length, o), i = r.length; while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n])) }) }) } function ye(e) { return e && "undefined" != typeof e.getElementsByTagName && e } for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || "HTML") }, T = se.setDocument = function (e) { var t, n, r = e ? e.ownerDocument || e : p; return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) { return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length }), d.attributes = ce(function (e) { return e.className = "i", !e.getAttribute("className") }), d.getElementsByTagName = ce(function (e) { return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) { return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length }), d.getById ? (b.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute("id") === t } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ? [n] : [] } }) : (b.filter.ID = function (e) { var n = e.replace(te, ne); return function (e) { var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return t && t.value === n } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), b.find.TAG = d.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, b.find.CLASS = d.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e) }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) { var t; a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]") }), ce(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = C.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:") })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) { d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F) }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, j = t ? function (e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1) } : function (e, t) { if (e === t) return l = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0; if (i === o) return pe(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0 }), C }, se.matches = function (e, t) { return se(e, null, null, t) }, se.matchesSelector = function (e, t) { if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { N(t, !0) } return 0 < se(t, C, null, [e]).length }, se.contains = function (e, t) { return (e.ownerDocument || e) != C && T(e), y(e, t) }, se.attr = function (e, t) { (e.ownerDocument || e) != C && T(e); var n = b.attrHandle[t.toLowerCase()], r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0; return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }, se.escape = function (e) { return (e + "").replace(re, ie) }, se.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, se.uniqueSort = function (e) { var t, n = [], r = 0, i = 0; if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1) } return u = null, e }, o = se.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else while (t = e[r++]) n += o(t); return n }, (b = se.selectors = { cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = m[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function (n, r, i) { return function (e) { var t = se.attr(e, n); return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-")) } }, CHILD: function (h, e, t, g, v) { var y = "nth" !== h.slice(0, 3), m = "last" !== h.slice(-4), x = "of-type" === e; return 1 === g && 0 === v ? function (e) { return !!e.parentNode } : function (e, t, n) { var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1; if (c) { if (y) { while (l) { a = e; while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1; u = l = "only" === h && !u && "nextSibling" } return !0 } if (u = [m ? c.firstChild : c.lastChild], m && p) { d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s]; while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) { i[h] = [k, s, d]; break } } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break; return (d -= v) === g || d % g == 0 && 0 <= d / g } } }, PSEUDO: function (e, o) { var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e); return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) { var n, r = a(e, o), i = r.length; while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]) }) : function (e) { return a(e, 0, t) }) : a } }, pseudos: { not: le(function (e) { var r = [], i = [], s = f(e.replace($, "$1")); return s[S] ? le(function (e, t, n, r) { var i, o = s(e, null, r, []), a = e.length; while (a--) (i = o[a]) && (e[a] = !(t[a] = i)) }) : function (e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop() } }), has: le(function (t) { return function (e) { return 0 < se(t, e).length } }), contains: le(function (t) { return t = t.replace(te, ne), function (e) { return -1 < (e.textContent || o(e)).indexOf(t) } }), lang: le(function (n) { return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) { var t; do { if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-") } while ((e = e.parentNode) && 1 === e.nodeType); return !1 } }), target: function (e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id }, root: function (e) { return e === a }, focus: function (e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: ge(!1), disabled: ge(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !b.pseudos.empty(e) }, header: function (e) { return J.test(e.nodeName) }, input: function (e) { return Q.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ve(function () { return [0] }), last: ve(function (e, t) { return [t - 1] }), eq: ve(function (e, t, n) { return [n < 0 ? n + t : n] }), even: ve(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: ve(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r); return e }), gt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e); for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e); function me() { } function xe(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function be(s, e, t) { var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r++; return e.first ? function (e, t, n) { while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n); return !1 } : function (e, t, n) { var r, i, o, a = [k, p]; if (n) { while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0 } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e; else { if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0 } return !1 } } function we(i) { return 1 < i.length ? function (e, t, n) { var r = i.length; while (r--) if (!i[r](e, t, n)) return !1; return !0 } : i[0] } function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Ce(d, h, g, v, y, e) { return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) { var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) { for (var r = 0, i = t.length; r < i; r++)se(e, t[r], n); return n }(h || "*", n.nodeType ? [n] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f; if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a)) } if (e) { if (y || d) { if (y) { i = [], o = p.length; while (o--) (a = p[o]) && i.push(f[o] = a); y(null, p = [], i, r) } o = p.length; while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a)) } } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p) }) } function Ee(e) { for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) { return e === i }, a, !0), l = be(function (e) { return -1 < P(i, e) }, a, !0), c = [function (e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n)); return i = null, r }]; s < r; s++)if (t = b.relative[e[s].type]) c = [be(we(c), t)]; else { if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) { for (n = ++s; n < r; n++)if (b.relative[e[n].type]) break; return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: " " === e[s - 2].type ? "*" : "" })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e)) } c.push(t) } return we(c) } return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) { var n, r, i, o, a, s, u, l = x[e + " "]; if (l) return t ? 0 : l.slice(0); a = e, s = [], u = b.preFilter; while (a) { for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace($, " ") }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break } return t ? a.length : a ? se.error(e) : x(e, s).slice(0) }, f = se.compile = function (e, t) { var n, v, y, m, x, r, i = [], o = [], a = A[e + " "]; if (!a) { t || (t = h(e)), n = t.length; while (n--) (a = Ee(t[n]))[S] ? i.push(a) : o.push(a); (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) { var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG("*", i), h = k += null == p ? 1 : Math.random() || .1, g = d.length; for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) { if (x && o) { a = 0, t || o.ownerDocument == C || (T(o), n = !E); while (s = v[a++]) if (s(o, t || C, n)) { r.push(o); break } i && (k = h) } m && ((o = !s && o) && u--, e && c.push(o)) } if (u += l, m && l !== u) { a = 0; while (s = y[a++]) s(c, f, t, n); if (e) { if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r)); f = Te(f) } H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r) } return i && (k = h, w = p), c }, m ? le(r) : r))).selector = e } return a }, g = se.select = function (e, t, n, r) { var i, o, a, s, u, l = "function" == typeof e && e, c = !r && h(e = l.selector || e); if (n = n || [], 1 === c.length) { if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) { if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n; l && (t = t.parentNode), e = e.slice(o.shift().value.length) } i = G.needsContext.test(e) ? 0 : o.length; while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n; break } } } return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) { return 1 & e.compareDocumentPosition(C.createElement("fieldset")) }), ce(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || fe("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), d.attributes && ce(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || fe("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ce(function (e) { return null == e.getAttribute("disabled") }) || fe(R, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), se }(C); S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && S(e).is(n)) break; r.push(e) } return r }, T = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, k = S.expr.match.needsContext; function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function j(e, n, r) { return m(n) ? S.grep(e, function (e, t) { return !!n.call(e, t, e) !== r }) : n.nodeType ? S.grep(e, function (e) { return e === n !== r }) : "string" != typeof n ? S.grep(e, function (e) { return -1 < i.call(n, e) !== r }) : S.filter(n, e, r) } S.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) { return 1 === e.nodeType })) }, S.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(S(e).filter(function () { for (t = 0; t < r; t++)if (S.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)S.find(e, i[t], n); return 1 < r ? S.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(j(this, e || [], !1)) }, not: function (e) { return this.pushStack(j(this, e || [], !0)) }, is: function (e) { return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length } }); var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (S.fn.init = function (e, t, n) { var r, i; if (!e) return this; if (n = n || D, "string" == typeof e) { if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this } return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this) }).prototype = S.fn, D = S(E); var L = /^(?:parents|prev(?:Until|All))/, H = { children: !0, contents: !0, next: !0, prev: !0 }; function O(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } S.fn.extend({ has: function (e) { var t = S(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (S.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && S(e); if (!k.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(1 < o.length ? S.uniqueSort(o) : o) }, index: function (e) { return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), S.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return h(e, "parentNode") }, parentsUntil: function (e, t, n) { return h(e, "parentNode", n) }, next: function (e) { return O(e, "nextSibling") }, prev: function (e) { return O(e, "previousSibling") }, nextAll: function (e) { return h(e, "nextSibling") }, prevAll: function (e) { return h(e, "previousSibling") }, nextUntil: function (e, t, n) { return h(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return h(e, "previousSibling", n) }, siblings: function (e) { return T((e.parentNode || {}).firstChild, e) }, children: function (e) { return T(e.firstChild) }, contents: function (e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes)) } }, function (r, i) { S.fn[r] = function (e, t) { var n = S.map(this, i, e); return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n) } }); var P = /[^\x20\t\r\n\f]+/g; function R(e) { return e } function M(e) { throw e } function I(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } S.Callbacks = function (r) { var e, n; r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) { n[t] = !0 }), n) : S.extend({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () { for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1) } r.memory || (t = !1), i = !1, a && (s = t ? [] : "") }, f = { add: function () { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { S.each(e, function (e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t) }) }(arguments), t && !i && c()), this }, remove: function () { return S.each(arguments, function (e, t) { var n; while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l-- }), this }, has: function (e) { return e ? -1 < S.inArray(e, s) : 0 < s.length }, empty: function () { return s && (s = []), this }, disable: function () { return a = u = [], s = t = "", this }, disabled: function () { return !s }, lock: function () { return a = u = [], t || i || (s = t = ""), this }, locked: function () { return !!a }, fireWith: function (e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this }, fire: function () { return f.fireWith(this, arguments), this }, fired: function () { return !!o } }; return f }, S.extend({ Deferred: function (e) { var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]], i = "pending", a = { state: function () { return i }, always: function () { return s.done(arguments).fail(arguments), this }, "catch": function (e) { return a.then(null, e) }, pipe: function () { var i = arguments; return S.Deferred(function (r) { S.each(o, function (e, t) { var n = m(i[t[4]]) && i[t[4]]; s[t[1]](function () { var e = n && n.apply(this, arguments); e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments) }) }), i = null }).promise() }, then: function (t, n, r) { var u = 0; function l(i, o, a, s) { return function () { var n = this, r = arguments, e = function () { var e, t; if (!(i < u)) { if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r)) } }, t = s ? e : function () { try { e() } catch (e) { S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r)) } }; i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t)) } } return S.Deferred(function (e) { o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M)) }).promise() }, promise: function (e) { return null != e ? S.extend(e, a) : a } }, s = {}; return S.each(o, function (e, t) { var n = t[2], r = t[5]; a[t[1]] = n.add, r && n.add(function () { i = r }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () { return s[t[0] + "With"](this === s ? void 0 : this, arguments), this }, s[t[0] + "With"] = n.fireWith }), a.promise(s), e && e.call(s, s), s }, when: function (e) { var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = S.Deferred(), a = function (t) { return function (e) { r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i) } }; if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then(); while (t--) I(i[t], a(t), o.reject); return o.promise() } }); var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; S.Deferred.exceptionHook = function (e, t) { C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, S.readyException = function (e) { C.setTimeout(function () { throw e }) }; var F = S.Deferred(); function B() { E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready() } S.fn.ready = function (e) { return F.then(e)["catch"](function (e) { S.readyException(e) }), this }, S.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]) } }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B)); var $ = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a); else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(S(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, _ = /^-ms-/, z = /-([a-z])/g; function U(e, t) { return t.toUpperCase() } function X(e) { return e.replace(_, "ms-").replace(z, U) } var V = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function G() { this.expando = S.expando + G.uid++ } G.uid = 1, G.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[X(t)] = n; else for (r in t) i[X(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length; while (n--) delete r[t[n]] } (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !S.isEmptyObject(t) } }; var Y = new G, Q = new G, J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g; function Z(e, t, n) { var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i) } catch (e) { } Q.set(e, t, n) } else n = void 0; return n } S.extend({ hasData: function (e) { return Q.hasData(e) || Y.hasData(e) }, data: function (e, t, n) { return Q.access(e, t, n) }, removeData: function (e, t) { Q.remove(e, t) }, _data: function (e, t, n) { return Y.access(e, t, n) }, _removeData: function (e, t) { Y.remove(e, t) } }), S.fn.extend({ data: function (n, e) { var t, r, i, o = this[0], a = o && o.attributes; if (void 0 === n) { if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) { t = a.length; while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r])); Y.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof n ? this.each(function () { Q.set(this, n) }) : $(this, function (e) { var t; if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0; this.each(function () { Q.set(this, n, e) }) }, null, e, 1 < arguments.length, null, !0) }, removeData: function (e) { return this.each(function () { Q.remove(this, e) }) } }), S.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = S.queue(e, t), r = n.length, i = n.shift(), o = S._queueHooks(e, t); "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () { S.dequeue(e, t) }, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return Y.get(e, n) || Y.access(e, n, { empty: S.Callbacks("once memory").add(function () { Y.remove(e, [t + "queue", n]) }) }) } }), S.fn.extend({ queue: function (t, n) { var e = 2; return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () { var e = S.queue(this, t, n); S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t) }) }, dequeue: function (e) { return this.each(function () { S.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, i = S.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = ["Top", "Right", "Bottom", "Left"], re = E.documentElement, ie = function (e) { return S.contains(e.ownerDocument, e) }, oe = { composed: !0 }; re.getRootNode && (ie = function (e) { return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument }); var ae = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display") }; function se(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return S.css(e, t, "") }, u = s(), l = n && n[3] || (S.cssNumber[t] ? "" : "px"), c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, S.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var ue = {}; function le(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n))); for (c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]); return e } S.fn.extend({ show: function () { return le(this, !0) }, hide: function () { return le(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? S(this).show() : S(this).hide() }) } }); var ce, fe, pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i; ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild; var ge = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function ve(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n } function ye(e, t) { for (var n = 0, r = e.length; n < r; n++)Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval")) } ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]); var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; S.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o); else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f } var be = /^([^.]*)(?:\.(.+)|)/; function we() { return !0 } function Te() { return !1 } function Ce(e, t) { return e === function () { try { return E.activeElement } catch (e) { } }() == ("focus" === t) } function Ee(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return S().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = S.guid++)), e.each(function () { S.event.add(this, t, i, r, n) }) } function Se(e, i, o) { o ? (Y.set(e, i, !1), S.event.add(e, i, { namespace: !1, handler: function (e) { var t, n, r = Y.get(this, i); if (1 & e.isTrigger && this[i]) { if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation(); else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value } else r.length && (Y.set(this, i, { value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === Y.get(e, i) && S.event.add(e, i, we) } S.event = { global: {}, add: function (t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t); if (V(t)) { n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) { return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0 }), l = (e = (e || "").match(P) || [""]).length; while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e); if (v && (u = v.events)) { l = (t = (t || "").match(P) || [""]).length; while (l--) if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) { f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]) } else for (d in u) S.event.remove(e, d + t[l], n, r, !0); S.isEmptyObject(u) && Y.remove(e, "handle events") } }, dispatch: function (e) { var t, n, r, i, o, a, s = new Array(arguments.length), u = S.event.fix(e), l = (Y.get(this, "events") || Object.create(null))[u.type] || [], c = S.event.special[u.type] || {}; for (s[0] = u, t = 1; t < arguments.length; t++)s[t] = arguments[t]; if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) { a = S.event.handlers.call(this, u, l), t = 0; while ((i = a[t++]) && !u.isPropagationStopped()) { u.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, u), u.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (t, e) { Object.defineProperty(S.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ? function () { if (this.originalEvent) return e(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[t] }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) }, fix: function (e) { return e[S.expando] ? e : new S.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1 }, trigger: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0 }, _default: function (e) { var t = e.target; return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, S.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, S.Event = function (e, t) { if (!(this instanceof S.Event)) return new S.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0 }, S.Event.prototype = { constructor: S.Event, isDefaultPrevented: Te, isPropagationStopped: Te, isImmediatePropagationStopped: Te, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, S.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function (e, t) { S.event.special[e] = { setup: function () { return Se(this, e, Ce), !1 }, trigger: function () { return Se(this, e), !0 }, _default: function () { return !0 }, delegateType: t } }), S.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, i) { S.event.special[e] = { delegateType: i, bindType: i, handle: function (e) { var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t } } }), S.fn.extend({ on: function (e, t, n, r) { return Ee(this, e, t, n, r) }, one: function (e, t, n, r) { return Ee(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function () { S.event.remove(this, e, n, t) }) } }); var ke = /<script|<style|<link/i, Ae = /checked\s*(?:[^=]|=\s*.checked.)/i, Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function je(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e } function De(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function qe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Le(e, t) { var n, r, i, o, a, s; if (1 === t.nodeType) { if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), s) for (n = 0, r = s[i].length; n < r; n++)S.event.add(t, i, s[i][n]); Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a)) } } function He(n, r, i, o) { r = g(r); var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d); if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function (e) { var t = n.eq(e); h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o) }); if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) { for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++)u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c); if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++)u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, { nonce: u.nonce || u.getAttribute("nonce") }, l) : b(u.textContent.replace(Ne, ""), u, l)) } return n } function Oe(e, t, n) { for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r)); return e } S.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, n) { var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = ie(e); if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Le(o[r], a[r]); else Le(e, c); return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c }, cleanData: function (e) { for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)if (V(n)) { if (t = n[Y.expando]) { if (t.events) for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle); n[Y.expando] = void 0 } n[Q.expando] && (n[Q.expando] = void 0) } } }), S.fn.extend({ detach: function (e) { return Oe(this, e, !0) }, remove: function (e) { return Oe(this, e) }, text: function (e) { return $(this, function (e) { return void 0 === e ? S.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return He(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e) }) }, prepend: function () { return He(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = je(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return He(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return He(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return S.clone(this, e, t) }) }, html: function (e) { return $(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = S.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var n = []; return He(this, arguments, function (e) { var t = this.parentNode; S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this)) }, n) } }), S.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, a) { S.fn[e] = function (e) { for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n) } }); var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Re = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e) }, Me = function (e, t, n) { var r, i, o = {}; for (i in t) o[i] = e.style[i], e.style[i] = t[i]; for (i in r = n.call(e), t) e.style[i] = o[i]; return r }, Ie = new RegExp(ne.join("|"), "i"); function We(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a } function Fe(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (l) { u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l); var e = C.getComputedStyle(l); n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null } } function t(e) { return Math.round(parseFloat(e)) } var n, r, i, o, a, s, u = E.createElement("div"), l = E.createElement("div"); l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, { boxSizingReliable: function () { return e(), r }, pixelBoxStyles: function () { return e(), o }, pixelPosition: function () { return e(), n }, reliableMarginLeft: function () { return e(), s }, scrollboxSize: function () { return e(), i }, reliableTrDimensions: function () { var e, t, n, r; return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a } })) }(); var Be = ["Webkit", "Moz", "ms"], $e = E.createElement("div").style, _e = {}; function ze(e) { var t = S.cssProps[e] || _e[e]; return t || (e in $e ? e : _e[e] = function (e) { var t = e[0].toUpperCase() + e.slice(1), n = Be.length; while (n--) if ((e = Be[n] + t) in $e) return e }(e) || e) } var Ue = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ve = { position: "absolute", visibility: "hidden", display: "block" }, Ge = { letterSpacing: "0", fontWeight: "400" }; function Ye(e, t, n) { var r = te.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function Qe(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i)); return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u } function Je(e, t, n) { var r = Re(e), i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r), o = i, a = We(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1); if (Pe.test(a)) { if (!n) return a; a = "auto" } return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px" } function Ke(e, t, n, r, i) { return new Ke.prototype.init(e, t, n, r, i) } S.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = We(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = X(t), u = Xe.test(t), l = e.style; if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = X(t); return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), S.each(["height", "width"], function (e, u) { S.cssHooks[u] = { get: function (e, t, n) { if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function () { return Je(e, u, n) }) }, set: function (e, t, n) { var r, i = Re(e), o = !y.scrollboxSize() && "absolute" === i.position, a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i), s = n ? Qe(e, u, n, a, i) : 0; return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s) } } }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + "px" }), S.each({ margin: "", padding: "", border: "Width" }, function (i, o) { S.cssHooks[i + o] = { expand: function (e) { for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++)n[i + ne[t] + o] = r[t] || r[t - 2] || r[0]; return n } }, "margin" !== i && (S.cssHooks[i + o].set = Ye) }), S.fn.extend({ css: function (e, t) { return $(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = Re(e), i = t.length; a < i; a++)o[t[a]] = S.css(e, t[a], !1, r); return o } return void 0 !== n ? S.style(e, t, n) : S.css(e, t) }, e, t, 1 < arguments.length) } }), ((S.Tween = Ke).prototype = { constructor: Ke, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px") }, cur: function () { var e = Ke.propHooks[this.prop]; return e && e.get ? e.get(this) : Ke.propHooks._default.get(this) }, run: function (e) { var t, n = Ke.propHooks[this.prop]; return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this } }).init.prototype = Ke.prototype, (Ke.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit) } } }).scrollTop = Ke.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, S.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, S.fx = Ke.prototype.init, S.fx.step = {}; var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/, it = /queueHooks$/; function ot() { et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick()) } function at() { return C.setTimeout(function () { Ze = void 0 }), Ze = Date.now() } function st(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = ne[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i } function ut(e, t, n) { for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function lt(o, e, t) { var n, a, r = 0, i = lt.prefilters.length, s = S.Deferred().always(function () { delete u.elem }), u = function () { if (a) return !1; for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1) }, l = s.promise({ elem: o, props: S.extend({}, e), opts: S.extend(!0, { specialEasing: {}, easing: S.easing._default }, t), originalProperties: e, originalOptions: t, startTime: Ze || at(), duration: t.duration, tweens: [], createTween: function (e, t) { var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n }, stop: function (e) { var t = 0, n = e ? l.tweens.length : 0; if (a) return this; for (a = !0; t < n; t++)l.tweens[t].run(1); return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this } }), c = l.props; for (!function (e, t) { var n, r, i, o, a; for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a) for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i); else t[r] = i }(c, l.opts.specialEasing); r < i; r++)if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n; return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l } S.Animation = S.extend(lt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return se(n.elem, e, te.exec(t), n), n }] }, tweener: function (e, t) { m(e) ? (t = e, e = ["*"]) : e = e.match(P); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), v = Y.get(e, "fxshow"); for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, S.queue(e, "fx").length || a.empty.fire() }) })), t) if (i = t[r], rt.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !v || void 0 === v[r]) continue; g = !0 } d[r] = v && v[r] || S.style(e, r) } if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", { display: l }), o && (v.hidden = !g), g && le([e], !0), p.done(function () { for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]) })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0)) }], prefilter: function (e, t) { t ? lt.prefilters.unshift(e) : lt.prefilters.push(e) } }), S.speed = function (e, t, n) { var r = e && "object" == typeof e ? S.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue) }, r }, S.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (t, e, n, r) { var i = S.isEmptyObject(t), o = S.speed(e, n, r), a = function () { var e = lt(this, S.extend({}, t), o); (i || Y.get(this, "finish")) && e.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function (i, e, o) { var a = function (e) { var t = e.stop; delete e.stop, t(o) }; return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function () { var e = !0, t = null != i && i + "queueHooks", n = S.timers, r = Y.get(this); if (t) r[t] && r[t].stop && a(r[t]); else for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]); for (t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1)); !e && o || S.dequeue(this, i) }) }, finish: function (a) { return !1 !== a && (a = a || "fx"), this.each(function () { var e, t = Y.get(this), n = t[a + "queue"], r = t[a + "queueHooks"], i = S.timers, o = n ? n.length : 0; for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1)); for (e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this); delete t.finish }) } }), S.each(["toggle", "show", "hide"], function (e, r) { var i = S.fn[r]; S.fn[r] = function (e, t, n) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n) } }), S.each({ slideDown: st("show"), slideUp: st("hide"), slideToggle: st("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, r) { S.fn[e] = function (e, t, n) { return this.animate(r, e, t, n) } }), S.timers = [], S.fx.tick = function () { var e, t = 0, n = S.timers; for (Ze = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || S.fx.stop(), Ze = void 0 }, S.fx.timer = function (e) { S.timers.push(e), S.fx.start() }, S.fx.interval = 13, S.fx.start = function () { et || (et = !0, ot()) }, S.fx.stop = function () { et = null }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function (r, e) { return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) { var n = C.setTimeout(e, r); t.stop = function () { C.clearTimeout(n) } }) }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value; var ct, ft = S.expr.attrHandle; S.fn.extend({ attr: function (e, t) { return $(this, S.attr, e, t, 1 < arguments.length) }, removeAttr: function (e) { return this.each(function () { S.removeAttr(this, e) }) } }), S.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!y.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(P); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), ct = { set: function (e, t, n) { return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n } }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) { var a = ft[t] || S.find.attr; ft[t] = function (e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r } }); var pt = /^(?:input|select|textarea|button)$/i, dt = /^(?:a|area)$/i; function ht(e) { return (e.match(P) || []).join(" ") } function gt(e) { return e.getAttribute && e.getAttribute("class") || "" } function vt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [] } S.fn.extend({ prop: function (e, t) { return $(this, S.prop, e, t, 1 < arguments.length) }, removeProp: function (e) { return this.each(function () { delete this[S.propFix[e] || e] }) } }), S.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = S.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (S.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { S.propFix[this.toLowerCase()] = this }), S.fn.extend({ addClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).addClass(t.call(this, e, gt(this))) }); if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") { a = 0; while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = ht(r)) && n.setAttribute("class", s) } return this }, removeClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).removeClass(t.call(this, e, gt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") { a = 0; while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " "); i !== (s = ht(r)) && n.setAttribute("class", s) } return this }, toggleClass: function (i, t) { var o = typeof i, a = "string" === o || Array.isArray(i); return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) { S(this).toggleClass(i.call(this, e, gt(this), t), t) }) : this.each(function () { var e, t, n, r; if (a) { t = 0, n = S(this), r = vt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e) } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || "")) }) }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0; return !1 } }); var yt = /\r/g; S.fn.extend({ val: function (n) { var r, e, i, t = this[0]; return arguments.length ? (i = m(n), this.each(function (e) { var t; 1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) { return null == e ? "" : e + "" })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t)) })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0 } }), S.extend({ valHooks: { option: { get: function (e) { var t = S.find.attr(e, "value"); return null != t ? t : ht(S.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) { if (t = S(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = S.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), S.each(["radio", "checkbox"], function () { S.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t) } }, y.checkOn || (S.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) }), y.focusin = "onfocusin" in C; var mt = /^(?:focusinfocus|focusoutblur)$/, xt = function (e) { e.stopPropagation() }; S.extend(S.event, { trigger: function (e, t, n, r) { var i, o, a, s, u, l, c, f, p = [n || E], d = v.call(e, "type") ? e.type : e, h = v.call(e, "namespace") ? e.namespace.split(".") : []; if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) { if (!r && !c.noBubble && !x(n)) { for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o; a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C) } i = 0; while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result } }, simulate: function (e, t, n) { var r = S.extend(new S.Event, n, { type: e, isSimulated: !0 }); S.event.trigger(r, null, t) } }), S.fn.extend({ trigger: function (e, t) { return this.each(function () { S.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return S.event.trigger(e, t, n, !0) } }), y.focusin || S.each({ focus: "focusin", blur: "focusout" }, function (n, r) { var i = function (e) { S.event.simulate(r, e.target, S.event.fix(e)) }; S.event.special[r] = { setup: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r); t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1) }, teardown: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r) - 1; t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r)) } } }); var bt = C.location, wt = { guid: Date.now() }, Tt = /\?/; S.parseXML = function (e) { var t, n; if (!e || "string" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, "text/xml") } catch (e) { } return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function (e) { return e.textContent }).join("\n") : e)), t }; var Ct = /\[\]$/, Et = /\r?\n/g, St = /^(?:submit|button|image|reset|file)$/i, kt = /^(?:input|select|textarea|keygen)/i; function At(n, e, r, i) { var t; if (Array.isArray(e)) S.each(e, function (e, t) { r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i) }); else if (r || "object" !== w(e)) i(n, e); else for (t in e) At(n + "[" + t + "]", e[t], r, i) } S.param = function (e, t) { var n, r = [], i = function (e, t) { var n = m(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () { i(this.name, this.value) }); else for (n in e) At(n, e[n], t, i); return r.join("&") }, S.fn.extend({ serialize: function () { return S.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = S.prop(this, "elements"); return e ? S.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = S(this).val(); return null == n ? null : Array.isArray(n) ? S.map(n, function (e) { return { name: t.name, value: e.replace(Et, "\r\n") } }) : { name: t.name, value: n.replace(Et, "\r\n") } }).get() } }); var Nt = /%20/g, jt = /#.*$/, Dt = /([?&])_=[^&]*/, qt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Lt = /^(?:GET|HEAD)$/, Ht = /^\/\//, Ot = {}, Pt = {}, Rt = "*/".concat("*"), Mt = E.createElement("a"); function It(o) { return function (e, t) { "string" != typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase().match(P) || []; if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t) } } function Wt(t, i, o, a) { var s = {}, u = t === Pt; function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function (e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r } return l(i.dataTypes[0]) || !s["*"] && l("*") } function Ft(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e } Mt.href = bt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: bt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Rt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e) }, ajaxPrefilter: It(Ot), ajaxTransport: It(Pt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = { readyState: 0, getResponseHeader: function (e) { var t; if (h) { if (!n) { n = {}; while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]) } t = n[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return h ? p : null }, setRequestHeader: function (e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this }, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this }, abort: function (e) { var t = e || u; return c && c.abort(t), l(0, t), this } }; if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host } catch (e) { v.crossDomain = !0 } } if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T; for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) { if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function () { T.abort("timeout") }, v.timeout)); try { h = !1, c.send(a, l) } catch (e) { if (h) throw e; l(-1, e) } } else l(-1, "No Transport"); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function () { }), s = function (e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop"))) } return T }, getJSON: function (e, t, n) { return S.get(e, t, n, "json") }, getScript: function (e, t) { return S.get(e, void 0, t, "script") } }), S.each(["get", "post"], function (e, i) { S[i] = function (e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)) } }), S.ajaxPrefilter(function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") }), S._evalUrl = function (e, t, n) { return S.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { S.globalEval(e, t, n) } }) }, S.fn.extend({ wrapAll: function (e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (n) { return m(n) ? this.each(function (e) { S(this).wrapInner(n.call(this, e)) }) : this.each(function () { var e = S(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n) }) }, wrap: function (t) { var n = m(t); return this.each(function (e) { S(this).wrapAll(n ? t.call(this, e) : t) }) }, unwrap: function (e) { return this.parent(e).not("body").each(function () { S(this).replaceWith(this.childNodes) }), this } }), S.expr.pseudos.hidden = function (e) { return !S.expr.pseudos.visible(e) }, S.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, S.ajaxSettings.xhr = function () { try { return new C.XMLHttpRequest } catch (e) { } }; var Bt = { 0: 200, 1223: 204 }, $t = S.ajaxSettings.xhr(); y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function (i) { var o, a; if (y.cors || $t && !i.crossDomain) return { send: function (e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]); o = function (e) { return function () { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () { 4 === r.readyState && C.setTimeout(function () { o && a() }) }, o = o("abort"); try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e } }, abort: function () { o && o() } } }), S.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return S.globalEval(e), e } } }), S.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), S.ajaxTransport("script", function (n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function (e, t) { r = S("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function (e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function () { i && i() } } }); var _t, zt = [], Ut = /(=)\?(?=&|$)|\?\?/; S.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = zt.pop() || S.expando + "_" + wt.guid++; return this[e] = !0, e } }), S.ajaxPrefilter("json jsonp", function (e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () { return o || S.error(r + " was not called"), o[0] }, e.dataTypes[0] = "json", i = C[r], C[r] = function () { o = arguments }, n.always(function () { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), "script" }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o }, S.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, S.expr.pseudos.animated = function (t) { return S.grep(S.timers, function (e) { return t === e.elem }).length }, S.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l = S.css(e, "position"), c = S(e), f = {}; "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f) } }, S.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ? this : this.each(function (e) { S.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - S.css(r, "marginTop", !0), left: t.left - i.left - S.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === S.css(e, "position")) e = e.offsetParent; return e || re }) } }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (t, i) { var o = "pageYOffset" === i; S.fn[t] = function (e) { return $(this, function (e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n }, t, e, arguments.length) } }), S.each(["top", "left"], function (e, n) { S.cssHooks[n] = Fe(y.pixelPosition, function (e, t) { if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t }) }), S.each({ Height: "height", Width: "width" }, function (a, s) { S.each({ padding: "inner" + a, content: s, "": "outer" + a }, function (r, o) { S.fn[o] = function (e, t) { var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border"); return $(this, function (e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i) }, s, n ? e : void 0, n) } }) }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { S.fn[t] = function (e) { return this.on(t, e) } }), S.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) { S.fn[n] = function (e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } }); var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; S.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || S.guid++, i }, S.holdReady = function (e) { e ? S.readyWait++ : S.ready(!0) }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) { var t = S.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, S.trim = function (e) { return null == e ? "" : (e + "").replace(Xt, "") }, "function" == typeof define && define.amd && define("jquery", [], function () { return S }); var Vt = C.jQuery, Gt = C.$; return S.noConflict = function (e) { return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S }, "undefined" == typeof e && (C.jQuery = C.$ = S), S });

define('utils/jqDomUtils', [
    'jquery'
], function (
    $
) {
    'use strict';

    var origAppendFn = $.fn.append,
        origPrependFn = $.fn.prepend,
        origRemoveFn = $.fn.remove;

    $.fn.append = function () {
        var returnObj = origAppendFn.apply(this, arguments);
        this.trigger('domchange', this);
        return returnObj;
    };

    $.fn.prepend = function () {
        var returnObj = origPrependFn.apply(this, arguments);
        this.trigger('domchange', this);
        return returnObj;
    };

    $.fn.remove = function () {
        this.trigger('domchange', this);
        return origRemoveFn.apply(this, arguments);
    };
});

define('managers/eventManager', [], function () {
    'use strict';

    function EventManager() {
        var self, internal, fn;

        self = this;

        internal = {
            listeners: {}
        };

        fn = {
            addListener: function (eventName, handler) {
                if (!internal.listeners[eventName]) {
                    internal.listeners[eventName] = [];
                }

                internal.listeners[eventName].push(handler);
                return handler;
            },

            removeListener: function (eventName, handler) {
                let handlers = internal.listeners[eventName];

                if (!handlers) {
                    return;
                }

                for (let i = handlers.length - 1; i >= 0; i -= 1) {
                    if (handlers[i] === handler) {
                        return handlers.splice(i, 1)[0];
                    }
                }
            },

            emit: function (eventName) {
                let handlers = internal.listeners[eventName] || [];
                let args = Array.prototype.slice.call(arguments, 1);
                handlers.forEach(function (handler) {
                    handler.apply(self, args.slice());
                });
            }
        };

        self.addListener = fn.addListener;
        self.removeListener = fn.removeListener;
        self.emit = fn.emit;

    }

    return new EventManager();
});

(function (factory) { if (typeof define === "function" && define.amd) { define('easing', ["jquery"], function ($) { return factory($) }) } else if (typeof module === "object" && typeof module.exports === "object") { exports = factory(require("jquery")) } else { factory(jQuery) } })(function ($) { $.easing.jswing = $.easing.swing; var pow = Math.pow, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, PI = Math.PI, c1 = 1.70158, c2 = c1 * 1.525, c3 = c1 + 1, c4 = 2 * PI / 3, c5 = 2 * PI / 4.5; function bounceOut(x) { var n1 = 7.5625, d1 = 2.75; if (x < 1 / d1) { return n1 * x * x } else if (x < 2 / d1) { return n1 * (x -= 1.5 / d1) * x + .75 } else if (x < 2.5 / d1) { return n1 * (x -= 2.25 / d1) * x + .9375 } else { return n1 * (x -= 2.625 / d1) * x + .984375 } } $.extend($.easing, { def: "easeOutQuad", swing: function (x) { return $.easing[$.easing.def](x) }, easeInQuad: function (x) { return x * x }, easeOutQuad: function (x) { return 1 - (1 - x) * (1 - x) }, easeInOutQuad: function (x) { return x < .5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2 }, easeInCubic: function (x) { return x * x * x }, easeOutCubic: function (x) { return 1 - pow(1 - x, 3) }, easeInOutCubic: function (x) { return x < .5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2 }, easeInQuart: function (x) { return x * x * x * x }, easeOutQuart: function (x) { return 1 - pow(1 - x, 4) }, easeInOutQuart: function (x) { return x < .5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2 }, easeInQuint: function (x) { return x * x * x * x * x }, easeOutQuint: function (x) { return 1 - pow(1 - x, 5) }, easeInOutQuint: function (x) { return x < .5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2 }, easeInSine: function (x) { return 1 - cos(x * PI / 2) }, easeOutSine: function (x) { return sin(x * PI / 2) }, easeInOutSine: function (x) { return -(cos(PI * x) - 1) / 2 }, easeInExpo: function (x) { return x === 0 ? 0 : pow(2, 10 * x - 10) }, easeOutExpo: function (x) { return x === 1 ? 1 : 1 - pow(2, -10 * x) }, easeInOutExpo: function (x) { return x === 0 ? 0 : x === 1 ? 1 : x < .5 ? pow(2, 20 * x - 10) / 2 : (2 - pow(2, -20 * x + 10)) / 2 }, easeInCirc: function (x) { return 1 - sqrt(1 - pow(x, 2)) }, easeOutCirc: function (x) { return sqrt(1 - pow(x - 1, 2)) }, easeInOutCirc: function (x) { return x < .5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2 }, easeInElastic: function (x) { return x === 0 ? 0 : x === 1 ? 1 : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4) }, easeOutElastic: function (x) { return x === 0 ? 0 : x === 1 ? 1 : pow(2, -10 * x) * sin((x * 10 - .75) * c4) + 1 }, easeInOutElastic: function (x) { return x === 0 ? 0 : x === 1 ? 1 : x < .5 ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2 : pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5) / 2 + 1 }, easeInBack: function (x) { return c3 * x * x * x - c1 * x * x }, easeOutBack: function (x) { return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2) }, easeInOutBack: function (x) { return x < .5 ? pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2 }, easeInBounce: function (x) { return 1 - bounceOut(1 - x) }, easeOutBounce: bounceOut, easeInOutBounce: function (x) { return x < .5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2 } }) });
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the mit license
 * http://jquery.org/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('mousewheel', ['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ('onwheel' in document || document.documentMode >= 9) ?
            ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function () {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function () {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function (elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function (elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function (fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function (fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            offsetX = 0,
            offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ('detail' in orgEvent) { deltaY = orgEvent.detail * -1; }
        if ('wheelDelta' in orgEvent) { deltaY = orgEvent.wheelDelta; }
        if ('wheelDeltaY' in orgEvent) { deltaY = orgEvent.wheelDeltaY; }
        if ('wheelDeltaX' in orgEvent) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ('deltaY' in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ('deltaX' in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) { delta = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if (deltaY === 0 && deltaX === 0) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            // Divide all the things by 40!
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

define('utils/functionUtil', [], function () {
    'use strict';

    var functionUtil = {};

    functionUtil.debounce = function (func, wait, immediate) {
        // debounce function adapted from underscore.js
        // https://underscorejs.org/#debounce
        var timeout, result;
        if (!wait) {
            wait = 100;
        }
        return function () {
            var context = this,
                args = arguments,
                later = function () {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                    }
                },
                callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
            }
            return result;
        };
    };

    // adapted from underscore.js
    // https://underscorejs.org/#throttle
    functionUtil.throttle = function (func, wait, options) {
        var timeout, context, args, result;
        var previous = 0;
        if (!options) options = {};

        var later = function () {
            previous = options.leading === false ? 0 : functionUtil.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        };

        var throttled = function () {
            var _now = functionUtil.now();
            if (!previous && options.leading === false) previous = _now;
            var remaining = wait - (_now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = _now;
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };

        throttled.cancel = function () {
            clearTimeout(timeout);
            previous = 0;
            timeout = context = args = null;
        };

        return throttled;
    };

    functionUtil.now = Date.now || function () {
        // now function taken from underscore.js
        // https://underscorejs.org/#now
        return new Date().getTime();
    };

    return functionUtil;
});

define('utils/globalElements', ['jquery'], function ($) {
    'use strict';

    return {
        doc: $(document),
        win: $(window),
        html: $('html'),
        body: $('body'),
    };

});

define('services/AnchorLinkObserver', [
    'jquery',
    'managers/eventManager'
], function (
    $,
    eventManager
) {
    'use strict';

    var AnchorLinkObserver = function (options) {
        var o, internal, fn, handlers;

        o = $.extend({
            $e: null,
            selector: 'body'
        }, options);

        internal = {
            name: 'AnchorLinkObserver',
            $e: o.$e || $(o.selector)
        };

        fn = {
            init: function () {
                internal.$e.on('click', 'a[href^="#"]', handlers.anchorLinkClick);
                internal.$e.on('click', 'a[href]', handlers.hrefLinkClick);
            }
        };

        handlers = {
            anchorLinkClick: function (event) {
                var $target, eventData;

                $target = $(this.hash, internal.$e);
                if ($target.length === 1) {
                    event.preventDefault();

                    eventData = {
                        hash: this.hash,
                        $anchor: $(this),
                        $target: $target
                    };

                    eventManager.emit(AnchorLinkObserver.eventTypes.ANCHOR_CLICK, eventData);
                }

            },

            hrefLinkClick: function (event) {
                var eventData, href;

                href = this.href;

                if (href.length && !this.hash.length) {
                    eventData = {
                        href: href,
                        $anchor: $(this),
                        event: event
                    };

                    eventManager.emit(AnchorLinkObserver.eventTypes.HREF_CLICK, eventData);
                }
            }
        };

        fn.init();
    };

    AnchorLinkObserver.eventTypes = {
        ANCHOR_CLICK: 'anchorLinkClick',
        HREF_CLICK: 'hrefLinkClick'
    };

    AnchorLinkObserver.on = {
        hrefLinkClick: function (callback) {
            eventManager.addListener(AnchorLinkObserver.eventTypes.HREF_CLICK, callback);
        }
    };

    return AnchorLinkObserver;
});

define('services/scroller', [
    'jquery',
    'easing',
    'mousewheel',
    'utils/functionUtil',
    'utils/globalElements',
    'managers/eventManager',
    'services/AnchorLinkObserver'
], function (
    $,
    easing,
    _mousewheel,
    functionUtil,
    globalElements,
    eventManager,
    AnchorLinkObserver
) {
    'use strict';

    var Scroller = function (options) {
        var self, o, eventTypes, internal, elements, fn, handlers;

        self = this;

        o = $.extend({
            scrollDuration: 800,
            scrollEasing: 'easeInOutCubic',
            compressedHeaderHeight: 80
        }, options);

        eventTypes = {
            SCROLL: 'scrollerScroll'
        };

        internal = {
            name: 'Scroller',
            scrollTop: 0,
            isWheeling: false,
            wheelingTimeout: null
        };

        elements = {
            doc: globalElements.doc,
            html: globalElements.html,
        };

        fn = {
            init: function () {
                elements.doc.on('scroll', handlers.scroll);
                elements.doc.on('mousewheel', handlers.mousewheel);

                eventManager.addListener(AnchorLinkObserver.eventTypes.ANCHOR_CLICK, handlers.anchorLinkClick);
            },
            scrollToYPos: function (yPos, callback) {
                fn.handleScrollOrMousewheelEvent.cancel();
                elements.html.stop(true, false).animate(
                    {
                        scrollTop: yPos
                    },
                    {
                        duration: o.scrollDuration,
                        easing: o.scrollEasing,
                        done: callback,
                    }
                );
            },
            scrollToElement: function ($e, callback) {
                var yPos = $e.offset().top - o.compressedHeaderHeight;
                return fn.scrollToYPos(yPos, callback);
            },
            getScrollTop: function () {
                return elements.html.scrollTop();
            },
            handleScrollOrMousewheelEvent: functionUtil.throttle(function () {
                eventManager.emit(eventTypes.SCROLL, {
                    scrollTop: elements.html.scrollTop()
                });
            }, 75),
            onScroll: function (handler) {
                return eventManager.addListener(eventTypes.SCROLL, handler);
            },
            offScroll: function (handler) {
                return eventManager.removeListener(eventTypes.SCROLL, handler);
            }
        };

        handlers = {
            scroll: function () {
                if (!internal.isWheeling) {
                    fn.handleScrollOrMousewheelEvent();
                }
            },
            mousewheel: function () {
                internal.isWheeling = true;
                if (internal.wheelingTimeout) {
                    clearTimeout(internal.wheelingTimeout);
                }
                internal.wheelingTimeout = setTimeout(function () {
                    internal.isWheeling = false;
                }, 100);

                fn.handleScrollOrMousewheelEvent();
            },
            anchorLinkClick: function (d) {
                var $target = d.$target,
                    id = $target.attr('id');

                fn.scrollToElement($target, function () {
                    // avoid tripping browser response to hashchange
                    // by removing the id from the target, and
                    // restoring it after the hash has been updated
                    // (calling preventDefault on the hashchange event
                    // appears to not work in Firefox)
                    if (id) {
                        $target.removeAttr('id');
                    }
                    window.location.hash = d.hash;
                    if (id) {
                        $target.attr('id', id);
                    }
                });
            }
        };

        self.o = o;
        self.eventTypes = eventTypes;

        self.scrollToYPos = fn.scrollToYPos;
        self.scrollToElement = fn.scrollToElement;
        self.getScrollTop = fn.getScrollTop;
        self.onScroll = fn.onScroll;
        self.offScroll = fn.offScroll;

        fn.init();
    };


    return new Scroller();
});

define('services/layout', [
    'jquery',
    'utils/functionUtil',
    'utils/globalElements',
    'managers/eventManager'
], function (
    $,
    functionUtil,
    globalElements,
    eventManager
) {
    'use strict';

    /*

    A singleton module responsible for:
    - Tracking viewport dimensions
    - Deriving current responsive breakpoint
    - Deriving grid column width according to current breakpoint
    - Emitting debounced resize events that other modules can subscribe/unsusbscribe to

    Since there are various modules that respond to viewport resizes and are interested
    in the current viewport dimensions, this provides a centralized place to manage
    these concerns.
    */
    var Layout = function () {
        var self, eventTypes, breakpoints, dimensions, internal, elements, fn, handlers;

        self = this;

        eventTypes = {
            RESIZE: 'layoutResize'
        };

        // enum of possible breakpoints
        // these values correspond to breakpoint rules
        // defined in _layout.scss
        // NB: this approach assumes no overlap in these breakpoints
        breakpoints = {
            FULL: {
                columnCount: 4,
                columnUnitCount: 4,
                minWidth: 1081
            },
            MEDIUM: {
                columnCount: 3,
                columnUnitCount: 4,
                maxWidth: 1080,
                minWidth: 761
            },
            SMALL: {
                columnCount: 2,
                columnUnitCount: 4,
                maxWidth: 760,
                minWidth: 421
            },
            TINY: {
                columnCount: 1,
                columnUnitCount: 4,
                maxWidth: 420
            }
        };

        dimensions = {
            BASE_UNIT: 10
        };

        internal = {
            name: 'Layout',
            // info is cached internally to allow multiple calls to getInfo
            // without each call requiring to read/derive everything,
            // since this data only changes on resize
            info: null
        };

        elements = {
            win: globalElements.win
        };

        fn = {
            init: function () {
                fn.updateInfo();
                elements.win.on('resize', handlers.resize);
            },
            updateInfo: function () {
                var $win = elements.win,
                    width = $win.width(),
                    height = $win.height(),
                    breakpoint = fn.deriveBreakpoint(width),
                    columnWidth = fn.deriveColumnWidth(width, breakpoint),
                    columnUnit = fn.deriveColumnUnit(columnWidth, breakpoint);

                internal.info = {
                    width: width,
                    height: height,
                    breakpoint: breakpoint,
                    columnWidth: columnWidth,
                    columnUnit: columnUnit
                };
            },
            deriveBreakpoint: function (width) {
                var b;

                $.each(breakpoints, function (i, breakpoint) {
                    if (breakpoint.minWidth) {
                        if (width >= breakpoint.minWidth) {
                            if (breakpoint.maxWidth) {
                                if (width <= breakpoint.maxWidth) {
                                    b = breakpoint;
                                    return false;
                                }
                            } else {
                                b = breakpoint;
                                return false;
                            }
                        }
                    } else if (breakpoint.maxWidth) {
                        if (width <= breakpoint.maxWidth) {
                            b = breakpoint;
                            return false;
                        }
                    }
                });

                return b;
            },
            deriveColumnWidth: function (width, breakpoint) {
                return Math.ceil(width / breakpoint.columnCount);
            },
            deriveColumnUnit: function (columnWidth, breakpoint) {
                return Math.ceil(columnWidth / breakpoint.columnUnitCount);
            },

            getInfo: function () {
                return internal.info;
            },
            onResize: function (handler) {
                return eventManager.addListener(eventTypes.RESIZE, handler);
            },
            offResize: function (handler) {
                return eventManager.removeListener(eventTypes.RESIZE, handler);
            },
            trigger: function () {
                fn.updateInfo();
                eventManager.emit(eventTypes.RESIZE, internal.info);
            },
            breakpointIs: function (bpKey) {
                var breakpoint;
                breakpoint = internal.info.breakpoint;
                return breakpoint === breakpoints[bpKey];
            },
            getFullWidth: function () {
                var breakpoint, columnWidth, columnCount;

                breakpoint = internal.info.breakpoint;
                columnWidth = internal.info.columnWidth;
                columnCount = breakpoint.columnCount;

                return columnWidth * columnCount;
            },
            getColumnWidth: function () {
                return internal.info.columnWidth;
            },
            hasTouchSupport: function () {
                return (('ontouchstart' in window) ||
                    (navigator.maxTouchPoints > 0) ||
                    (navigator.msMaxTouchPoints > 0));
            }
        };

        handlers = {
            resize: functionUtil.debounce(function () {
                fn.trigger();
            }, 25)
        };

        self.eventTypes = eventTypes;
        self.breakpoints = breakpoints;
        self.dimensions = dimensions;

        self.getInfo = fn.getInfo;
        self.onResize = fn.onResize;
        self.offResize = fn.offResize;
        self.trigger = fn.trigger;
        self.breakpointIs = fn.breakpointIs;
        self.getFullWidth = fn.getFullWidth;
        self.getColumnWidth = fn.getColumnWidth;
        self.hasTouchSupport = fn.hasTouchSupport;

        fn.init();
    };


    return new Layout();
});

define('utils/statesUtil', [
    'jquery'
], function (
    $
) {
    'use strict';

    var statesUtil = {};

    statesUtil.markup = {
        READY: 'state-ready',

        ACTIVE: 'state-active',
        INACTIVE: 'state-inactive',

        OPEN: 'state-open',
        CLOSED: 'state-closed',

        SELECTED: 'state-selected',
        CURRENT: 'state-current',
        HIGHLIGHT: 'state-highlight',
        FOCUS: 'state-focus',
        BLUR: 'state-blur',
        HOVER: 'state-hover',
        HAS_VALUE: 'state-has-value',

        PLACEHOLDER: 'state-placeholder',

        SHOW: 'state-show',
        HIDE: 'state-hide',

        VISIBLE: 'state-visible',
        INVISIBLE: 'state-invisible',

        DISABLED: 'state-disabled',
        ENABLED: 'state-enabled',

        INVALID: 'state-invalid',
        VALID: 'state-valid',

        COLLAPSE: 'state-collapse',
        EXPAND: 'state-expand',

        INITED: 'state-inited',
        SETUP: 'state-setup',

        FULL_SCREEN: 'state-full-screen',

        PROCESSING: 'state-processing'
    };

    statesUtil.extend = function (markupObj) {
        var markupExtension = {};
        $.extend(markupExtension, statesUtil.markup, markupObj);
        $.extend(markupObj, markupExtension);
    };

    statesUtil.m = statesUtil.markup;

    return statesUtil;
});

define('ui/Header', [
    'jquery',
    'managers/eventManager',
    'services/scroller',
    'services/layout',
    'utils/statesUtil'
], function (
    $,
    eventManager,
    scroller,
    layout,
    statesUtil
) {
    'use strict';

    var Header = function (options) {
        var self, o, m, internal, fn, handlers;

        self = this;

        o = $.extend({
            $e: null,
            selector: ''
        }, options);

        m = Header.markup;

        internal = {
            name: 'Header',
            $e: o.$e || $(o.selector),
            compressThreshold: null,
            isCompressed: null
        };

        fn = {
            init: function () {
                internal.isCompressed = internal.$e.hasClass(m.COMPRESSED);
                fn.updateFromDimensions(layout.getInfo());

                internal.$e.on('click', '.global-header-nav a[data-target]', handlers.targetNavLinkClick);
                scroller.onScroll(handlers.scroll);
                layout.onResize(handlers.resize);
            },
            destroy: function () {
                internal.$e.off('click', '.global-header-nav a[data-target]', handlers.targetNavLinkClick);
                scroller.offScroll(handlers.scroll);
                layout.offResize(handlers.resize);
                internal.$e.removeClass(m.COMPRESSED);
            },
            updateFromDimensions: function (d) {
                internal.compressThreshold = d.height / 3;
                fn.updatePositionState(scroller.getScrollTop());
            },
            updatePositionState: function (scrollTop) {
                if (internal.isCompressed) {
                    if (scrollTop < internal.compressThreshold) {
                        internal.$e.removeClass(m.COMPRESSED);
                        internal.isCompressed = false;
                    }
                } else {
                    if (scrollTop >= internal.compressThreshold) {
                        internal.$e.addClass(m.COMPRESSED);
                        internal.isCompressed = true;
                    }
                }
            },
            isCompressed: function () {
                return internal.isCompressed;
            }
        };

        handlers = {
            targetNavLinkClick: function (evnt) {
                evnt.preventDefault();

                let target = $(this).data('target');
                let eventData = { target: target };

                eventManager.emit(Header.eventTypes.TARGET_NAV_ITEM_CLICK, eventData);
            },
            scroll: function (d) {
                fn.updatePositionState(d.scrollTop);
            },
            resize: function (d) {
                fn.updateFromDimensions(d);
            }
        };

        self.isCompressed = fn.isCompressed;
        self.destroy = fn.destroy;

        fn.init();
    };

    Header.eventTypes = {
        TARGET_NAV_ITEM_CLICK: 'headerTargetNavItemClick'
    };

    Header.markup = {
        COMPRESSED: 'state-compressed'
    };
    statesUtil.extend(Header.markup);

    return Header;
});

define('utils/keycodes', {
    BACKSPACE: 8,
    CAPS_LOCK: 20,
    COMMA: 188,
    CONTROL: 17,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    INSERT: 45,
    LEFT: 37,
    NUMPAD_ADD: 107,
    NUMPAD_DECIMAL: 110,
    NUMPAD_DIVIDE: 111,
    NUMPAD_ENTER: 108,
    NUMPAD_MULTIPLY: 106,
    NUMPAD_SUBTRACT: 109,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SHIFT: 16,
    SPACE: 32,
    TAB: 9,
    UP: 38
});

define('ui/Drawer', [
    'jquery',
    'utils/globalElements',
    'managers/eventManager',
    'ui/Header',
    'utils/keycodes',
    'utils/statesUtil'
], function (
    $,
    globalElements,
    eventManager,
    Header,
    keycodes,
    statesUtil
) {
    'use strict';

    // TODO: Refactor this to use the moduleFactory

    var Drawer = function (options) {
        var self, o, m, internal, elements, fn, handlers;

        self = this;

        o = $.extend({
            $e: null,
            selector: ''
        }, options);

        m = Drawer.markup;

        internal = {
            name: 'Drawer',
            $e: o.$e || $(o.selector),
            currentPane: null
        };

        elements = {
            body: globalElements.body,
            panes: $('.global-drawer-pane', internal.$e)
        };

        fn = {
            init: function () {
                eventManager.addListener(Header.eventTypes.TARGET_NAV_ITEM_CLICK, handlers.headerTargetNavItemClick);
                internal.$e.on('keydown', handlers.keydown);
            },
            destroy: function () {
                eventManager.removeListener(Header.eventTypes.TARGET_NAV_ITEM_CLICK, handlers.headerTargetNavItemClick);
                internal.$e.off('keydown', handlers.keydown);
            },

            activatePane: function (targetPane) {
                if (internal.currentPane) {
                    elements.body.removeClass(m.GLOBAL_DRAWER_PANE_PREFIX + internal.currentPane);
                    elements.panes.removeClass(m.CURRENT);
                    internal.currentPane = null;
                }

                if (targetPane) {
                    let $targetPane = elements.panes.filter('[data-pane="' + targetPane + '"]');
                    $targetPane.addClass(m.CURRENT);
                    internal.currentPane = targetPane;
                    elements.body.addClass(m.GLOBAL_DRAWER_PANE_PREFIX + targetPane);
                    fn.setPaneFocus($targetPane);
                }
            },
            setPaneFocus: function ($pane) {
                var $firstInput = $pane.find('input:visible:first');

                if ($firstInput.length > 0) {
                    $firstInput.focus();
                } else {
                    internal.$e.focus();
                }
            },

            open: function (targetPane) {
                fn.activatePane(targetPane);
                elements.body.addClass(m.GLOBAL_DRAWER_OPEN);
            },
            close: function () {
                elements.body.removeClass(m.GLOBAL_DRAWER_OPEN);
                fn.activatePane(null);
            },
            isOpen: function () {
                return elements.body.hasClass(m.GLOBAL_DRAWER_OPEN);
            }
        };

        handlers = {
            headerTargetNavItemClick: function (d) {
                let targetPane = d.target;
                let currentPane = internal.currentPane;

                if (currentPane && currentPane === targetPane) {
                    fn.close();
                } else {
                    fn.open(targetPane);
                }
            },

            keydown: function (event) {
                if (event.which === keycodes.ESCAPE && fn.isOpen()) {
                    fn.close();
                }
            }
        };

        self.destroy = fn.destroy;

        fn.init();
    };

    Drawer.markup = {
        GLOBAL_DRAWER_OPEN: 'state-drawer-open',
        GLOBAL_DRAWER_PANE_PREFIX: 'state-drawer-pane-',
        CURRENT: 'state-current'
    };
    statesUtil.extend(Drawer.markup);

    return Drawer;
});

/**!

 @license
 handlebars v4.7.7

Copyright (C) 2011-2019 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LImitED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function (a, b) { "object" == typeof exports && "object" == typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define('handlebars', [], b) : "object" == typeof exports ? exports.Handlebars = b() : a.Handlebars = b() }(this, function () {
    return function (a) { function b(d) { if (c[d]) return c[d].exports; var e = c[d] = { exports: {}, id: d, loaded: !1 }; return a[d].call(e.exports, e, e.exports, b), e.loaded = !0, e.exports } var c = {}; return b.m = a, b.c = c, b.p = "", b(0) }([function (a, b, c) { "use strict"; function d() { var a = r(); return a.compile = function (b, c) { return k.compile(b, c, a) }, a.precompile = function (b, c) { return k.precompile(b, c, a) }, a.AST = i["default"], a.Compiler = k.Compiler, a.JavaScriptCompiler = m["default"], a.Parser = j.parser, a.parse = j.parse, a.parseWithoutProcessing = j.parseWithoutProcessing, a } var e = c(1)["default"]; b.__esModule = !0; var f = c(2), g = e(f), h = c(45), i = e(h), j = c(46), k = c(51), l = c(52), m = e(l), n = c(49), o = e(n), p = c(44), q = e(p), r = g["default"].create, s = d(); s.create = d, q["default"](s), s.Visitor = o["default"], s["default"] = s, b["default"] = s, a.exports = b["default"] }, function (a, b) { "use strict"; b["default"] = function (a) { return a && a.__esModule ? a : { "default": a } }, b.__esModule = !0 }, function (a, b, c) { "use strict"; function d() { var a = new h.HandlebarsEnvironment; return n.extend(a, h), a.SafeString = j["default"], a.Exception = l["default"], a.Utils = n, a.escapeExpression = n.escapeExpression, a.VM = p, a.template = function (b) { return p.template(b, a) }, a } var e = c(3)["default"], f = c(1)["default"]; b.__esModule = !0; var g = c(4), h = e(g), i = c(37), j = f(i), k = c(6), l = f(k), m = c(5), n = e(m), o = c(38), p = e(o), q = c(44), r = f(q), s = d(); s.create = d, r["default"](s), s["default"] = s, b["default"] = s, a.exports = b["default"] }, function (a, b) { "use strict"; b["default"] = function (a) { if (a && a.__esModule) return a; var b = {}; if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]); return b["default"] = a, b }, b.__esModule = !0 }, function (a, b, c) { "use strict"; function d(a, b, c) { this.helpers = a || {}, this.partials = b || {}, this.decorators = c || {}, i.registerDefaultHelpers(this), j.registerDefaultDecorators(this) } var e = c(1)["default"]; b.__esModule = !0, b.HandlebarsEnvironment = d; var f = c(5), g = c(6), h = e(g), i = c(10), j = c(30), k = c(32), l = e(k), m = c(33), n = "4.7.7"; b.VERSION = n; var o = 8; b.COMPILER_REVISION = o; var p = 7; b.LAST_COMPATIBLE_COMPILER_REVISION = p; var q = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: "== 1.x.x", 5: "== 2.0.0-alpha.x", 6: ">= 2.0.0-beta.1", 7: ">= 4.0.0 <4.3.0", 8: ">= 4.3.0" }; b.REVISION_CHANGES = q; var r = "[object Object]"; d.prototype = { constructor: d, logger: l["default"], log: l["default"].log, registerHelper: function (a, b) { if (f.toString.call(a) === r) { if (b) throw new h["default"]("Arg not supported with multiple helpers"); f.extend(this.helpers, a) } else this.helpers[a] = b }, unregisterHelper: function (a) { delete this.helpers[a] }, registerPartial: function (a, b) { if (f.toString.call(a) === r) f.extend(this.partials, a); else { if ("undefined" == typeof b) throw new h["default"]('Attempting to register a partial called "' + a + '" as undefined'); this.partials[a] = b } }, unregisterPartial: function (a) { delete this.partials[a] }, registerDecorator: function (a, b) { if (f.toString.call(a) === r) { if (b) throw new h["default"]("Arg not supported with multiple decorators"); f.extend(this.decorators, a) } else this.decorators[a] = b }, unregisterDecorator: function (a) { delete this.decorators[a] }, resetLoggedPropertyAccesses: function () { m.resetLoggedProperties() } }; var s = l["default"].log; b.log = s, b.createFrame = f.createFrame, b.logger = l["default"] }, function (a, b) { "use strict"; function c(a) { return k[a] } function d(a) { for (var b = 1; b < arguments.length; b++)for (var c in arguments[b]) Object.prototype.hasOwnProperty.call(arguments[b], c) && (a[c] = arguments[b][c]); return a } function e(a, b) { for (var c = 0, d = a.length; c < d; c++)if (a[c] === b) return c; return -1 } function f(a) { if ("string" != typeof a) { if (a && a.toHTML) return a.toHTML(); if (null == a) return ""; if (!a) return a + ""; a = "" + a } return m.test(a) ? a.replace(l, c) : a } function g(a) { return !a && 0 !== a || !(!p(a) || 0 !== a.length) } function h(a) { var b = d({}, a); return b._parent = a, b } function i(a, b) { return a.path = b, a } function j(a, b) { return (a ? a + "." : "") + b } b.__esModule = !0, b.extend = d, b.indexOf = e, b.escapeExpression = f, b.isEmpty = g, b.createFrame = h, b.blockParams = i, b.appendContextPath = j; var k = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" }, l = /[&<>"'`=]/g, m = /[&<>"'`=]/, n = Object.prototype.toString; b.toString = n; var o = function (a) { return "function" == typeof a }; o(/x/) && (b.isFunction = o = function (a) { return "function" == typeof a && "[object Function]" === n.call(a) }), b.isFunction = o; var p = Array.isArray || function (a) { return !(!a || "object" != typeof a) && "[object Array]" === n.call(a) }; b.isArray = p }, function (a, b, c) { "use strict"; function d(a, b) { var c = b && b.loc, g = void 0, h = void 0, i = void 0, j = void 0; c && (g = c.start.line, h = c.end.line, i = c.start.column, j = c.end.column, a += " - " + g + ":" + i); for (var k = Error.prototype.constructor.call(this, a), l = 0; l < f.length; l++)this[f[l]] = k[f[l]]; Error.captureStackTrace && Error.captureStackTrace(this, d); try { c && (this.lineNumber = g, this.endLineNumber = h, e ? (Object.defineProperty(this, "column", { value: i, enumerable: !0 }), Object.defineProperty(this, "endColumn", { value: j, enumerable: !0 })) : (this.column = i, this.endColumn = j)) } catch (m) { } } var e = c(7)["default"]; b.__esModule = !0; var f = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"]; d.prototype = new Error, b["default"] = d, a.exports = b["default"] }, function (a, b, c) { a.exports = { "default": c(8), __esModule: !0 } }, function (a, b, c) { var d = c(9); a.exports = function (a, b, c) { return d.setDesc(a, b, c) } }, function (a, b) { var c = Object; a.exports = { create: c.create, getProto: c.getPrototypeOf, isEnum: {}.propertyIsEnumerable, getDesc: c.getOwnPropertyDescriptor, setDesc: c.defineProperty, setDescs: c.defineProperties, getKeys: c.keys, getNames: c.getOwnPropertyNames, getSymbols: c.getOwnPropertySymbols, each: [].forEach } }, function (a, b, c) { "use strict"; function d(a) { h["default"](a), j["default"](a), l["default"](a), n["default"](a), p["default"](a), r["default"](a), t["default"](a) } function e(a, b, c) { a.helpers[b] && (a.hooks[b] = a.helpers[b], c || delete a.helpers[b]) } var f = c(1)["default"]; b.__esModule = !0, b.registerDefaultHelpers = d, b.moveHelperToHooks = e; var g = c(11), h = f(g), i = c(12), j = f(i), k = c(25), l = f(k), m = c(26), n = f(m), o = c(27), p = f(o), q = c(28), r = f(q), s = c(29), t = f(s) }, function (a, b, c) { "use strict"; b.__esModule = !0; var d = c(5); b["default"] = function (a) { a.registerHelper("blockHelperMissing", function (b, c) { var e = c.inverse, f = c.fn; if (b === !0) return f(this); if (b === !1 || null == b) return e(this); if (d.isArray(b)) return b.length > 0 ? (c.ids && (c.ids = [c.name]), a.helpers.each(b, c)) : e(this); if (c.data && c.ids) { var g = d.createFrame(c.data); g.contextPath = d.appendContextPath(c.data.contextPath, c.name), c = { data: g } } return f(b, c) }) }, a.exports = b["default"] }, function (a, b, c) { (function (d) { "use strict"; var e = c(13)["default"], f = c(1)["default"]; b.__esModule = !0; var g = c(5), h = c(6), i = f(h); b["default"] = function (a) { a.registerHelper("each", function (a, b) { function c(b, c, d) { l && (l.key = b, l.index = c, l.first = 0 === c, l.last = !!d, m && (l.contextPath = m + b)), k += f(a[b], { data: l, blockParams: g.blockParams([a[b], b], [m + b, null]) }) } if (!b) throw new i["default"]("Must pass iterator to #each"); var f = b.fn, h = b.inverse, j = 0, k = "", l = void 0, m = void 0; if (b.data && b.ids && (m = g.appendContextPath(b.data.contextPath, b.ids[0]) + "."), g.isFunction(a) && (a = a.call(this)), b.data && (l = g.createFrame(b.data)), a && "object" == typeof a) if (g.isArray(a)) for (var n = a.length; j < n; j++)j in a && c(j, j, j === a.length - 1); else if (d.Symbol && a[d.Symbol.iterator]) { for (var o = [], p = a[d.Symbol.iterator](), q = p.next(); !q.done; q = p.next())o.push(q.value); a = o; for (var n = a.length; j < n; j++)c(j, j, j === a.length - 1) } else !function () { var b = void 0; e(a).forEach(function (a) { void 0 !== b && c(b, j - 1), b = a, j++ }), void 0 !== b && c(b, j - 1, !0) }(); return 0 === j && (k = h(this)), k }) }, a.exports = b["default"] }).call(b, function () { return this }()) }, function (a, b, c) { a.exports = { "default": c(14), __esModule: !0 } }, function (a, b, c) { c(15), a.exports = c(21).Object.keys }, function (a, b, c) { var d = c(16); c(18)("keys", function (a) { return function (b) { return a(d(b)) } }) }, function (a, b, c) { var d = c(17); a.exports = function (a) { return Object(d(a)) } }, function (a, b) { a.exports = function (a) { if (void 0 == a) throw TypeError("Can't call method on  " + a); return a } }, function (a, b, c) { var d = c(19), e = c(21), f = c(24); a.exports = function (a, b) { var c = (e.Object || {})[a] || Object[a], g = {}; g[a] = b(c), d(d.S + d.F * f(function () { c(1) }), "Object", g) } }, function (a, b, c) { var d = c(20), e = c(21), f = c(22), g = "prototype", h = function (a, b, c) { var i, j, k, l = a & h.F, m = a & h.G, n = a & h.S, o = a & h.P, p = a & h.B, q = a & h.W, r = m ? e : e[b] || (e[b] = {}), s = m ? d : n ? d[b] : (d[b] || {})[g]; m && (c = b); for (i in c) j = !l && s && i in s, j && i in r || (k = j ? s[i] : c[i], r[i] = m && "function" != typeof s[i] ? c[i] : p && j ? f(k, d) : q && s[i] == k ? function (a) { var b = function (b) { return this instanceof a ? new a(b) : a(b) }; return b[g] = a[g], b }(k) : o && "function" == typeof k ? f(Function.call, k) : k, o && ((r[g] || (r[g] = {}))[i] = k)) }; h.F = 1, h.G = 2, h.S = 4, h.P = 8, h.B = 16, h.W = 32, a.exports = h }, function (a, b) { var c = a.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")(); "number" == typeof __g && (__g = c) }, function (a, b) { var c = a.exports = { version: "1.2.6" }; "number" == typeof __e && (__e = c) }, function (a, b, c) { var d = c(23); a.exports = function (a, b, c) { if (d(a), void 0 === b) return a; switch (c) { case 1: return function (c) { return a.call(b, c) }; case 2: return function (c, d) { return a.call(b, c, d) }; case 3: return function (c, d, e) { return a.call(b, c, d, e) } }return function () { return a.apply(b, arguments) } } }, function (a, b) { a.exports = function (a) { if ("function" != typeof a) throw TypeError(a + " is not a function!"); return a } }, function (a, b) { a.exports = function (a) { try { return !!a() } catch (b) { return !0 } } }, function (a, b, c) { "use strict"; var d = c(1)["default"]; b.__esModule = !0; var e = c(6), f = d(e); b["default"] = function (a) { a.registerHelper("helperMissing", function () { if (1 !== arguments.length) throw new f["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"') }) }, a.exports = b["default"] }, function (a, b, c) { "use strict"; var d = c(1)["default"]; b.__esModule = !0; var e = c(5), f = c(6), g = d(f); b["default"] = function (a) { a.registerHelper("if", function (a, b) { if (2 != arguments.length) throw new g["default"]("#if requires exactly one argument"); return e.isFunction(a) && (a = a.call(this)), !b.hash.includeZero && !a || e.isEmpty(a) ? b.inverse(this) : b.fn(this) }), a.registerHelper("unless", function (b, c) { if (2 != arguments.length) throw new g["default"]("#unless requires exactly one argument"); return a.helpers["if"].call(this, b, { fn: c.inverse, inverse: c.fn, hash: c.hash }) }) }, a.exports = b["default"] }, function (a, b) { "use strict"; b.__esModule = !0, b["default"] = function (a) { a.registerHelper("log", function () { for (var b = [void 0], c = arguments[arguments.length - 1], d = 0; d < arguments.length - 1; d++)b.push(arguments[d]); var e = 1; null != c.hash.level ? e = c.hash.level : c.data && null != c.data.level && (e = c.data.level), b[0] = e, a.log.apply(a, b) }) }, a.exports = b["default"] }, function (a, b) { "use strict"; b.__esModule = !0, b["default"] = function (a) { a.registerHelper("lookup", function (a, b, c) { return a ? c.lookupProperty(a, b) : a }) }, a.exports = b["default"] }, function (a, b, c) { "use strict"; var d = c(1)["default"]; b.__esModule = !0; var e = c(5), f = c(6), g = d(f); b["default"] = function (a) { a.registerHelper("with", function (a, b) { if (2 != arguments.length) throw new g["default"]("#with requires exactly one argument"); e.isFunction(a) && (a = a.call(this)); var c = b.fn; if (e.isEmpty(a)) return b.inverse(this); var d = b.data; return b.data && b.ids && (d = e.createFrame(b.data), d.contextPath = e.appendContextPath(b.data.contextPath, b.ids[0])), c(a, { data: d, blockParams: e.blockParams([a], [d && d.contextPath]) }) }) }, a.exports = b["default"] }, function (a, b, c) { "use strict"; function d(a) { g["default"](a) } var e = c(1)["default"]; b.__esModule = !0, b.registerDefaultDecorators = d; var f = c(31), g = e(f) }, function (a, b, c) { "use strict"; b.__esModule = !0; var d = c(5); b["default"] = function (a) { a.registerDecorator("inline", function (a, b, c, e) { var f = a; return b.partials || (b.partials = {}, f = function (e, f) { var g = c.partials; c.partials = d.extend({}, g, b.partials); var h = a(e, f); return c.partials = g, h }), b.partials[e.args[0]] = e.fn, f }) }, a.exports = b["default"] }, function (a, b, c) { "use strict"; b.__esModule = !0; var d = c(5), e = { methodMap: ["debug", "info", "warn", "error"], level: "info", lookupLevel: function (a) { if ("string" == typeof a) { var b = d.indexOf(e.methodMap, a.toLowerCase()); a = b >= 0 ? b : parseInt(a, 10) } return a }, log: function (a) { if (a = e.lookupLevel(a), "undefined" != typeof console && e.lookupLevel(e.level) <= a) { var b = e.methodMap[a]; console[b] || (b = "log"); for (var c = arguments.length, d = Array(c > 1 ? c - 1 : 0), f = 1; f < c; f++)d[f - 1] = arguments[f]; console[b].apply(console, d) } } }; b["default"] = e, a.exports = b["default"] }, function (a, b, c) { "use strict"; function d(a) { var b = i(null); b.constructor = !1, b.__defineGetter__ = !1, b.__defineSetter__ = !1, b.__lookupGetter__ = !1; var c = i(null); return c.__proto__ = !1, { properties: { whitelist: l.createNewLookupObject(c, a.allowedProtoProperties), defaultValue: a.allowProtoPropertiesByDefault }, methods: { whitelist: l.createNewLookupObject(b, a.allowedProtoMethods), defaultValue: a.allowProtoMethodsByDefault } } } function e(a, b, c) { return "function" == typeof a ? f(b.methods, c) : f(b.properties, c) } function f(a, b) { return void 0 !== a.whitelist[b] ? a.whitelist[b] === !0 : void 0 !== a.defaultValue ? a.defaultValue : (g(b), !1) } function g(a) { o[a] !== !0 && (o[a] = !0, n.log("error", 'Handlebars: Access has been denied to resolve the property "' + a + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details')) } function h() { j(o).forEach(function (a) { delete o[a] }) } var i = c(34)["default"], j = c(13)["default"], k = c(3)["default"]; b.__esModule = !0, b.createProtoAccessControl = d, b.resultIsAllowed = e, b.resetLoggedProperties = h; var l = c(36), m = c(32), n = k(m), o = i(null) }, function (a, b, c) { a.exports = { "default": c(35), __esModule: !0 } }, function (a, b, c) { var d = c(9); a.exports = function (a, b) { return d.create(a, b) } }, function (a, b, c) { "use strict"; function d() { for (var a = arguments.length, b = Array(a), c = 0; c < a; c++)b[c] = arguments[c]; return f.extend.apply(void 0, [e(null)].concat(b)) } var e = c(34)["default"]; b.__esModule = !0, b.createNewLookupObject = d; var f = c(5) }, function (a, b) { "use strict"; function c(a) { this.string = a } b.__esModule = !0, c.prototype.toString = c.prototype.toHTML = function () { return "" + this.string }, b["default"] = c, a.exports = b["default"] }, function (a, b, c) { "use strict"; function d(a) { var b = a && a[0] || 1, c = v.COMPILER_REVISION; if (!(b >= v.LAST_COMPATIBLE_COMPILER_REVISION && b <= v.COMPILER_REVISION)) { if (b < v.LAST_COMPATIBLE_COMPILER_REVISION) { var d = v.REVISION_CHANGES[c], e = v.REVISION_CHANGES[b]; throw new u["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + d + ") or downgrade your runtime to an older version (" + e + ").") } throw new u["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + a[1] + ").") } } function e(a, b) { function c(c, d, e) { e.hash && (d = s.extend({}, d, e.hash), e.ids && (e.ids[0] = !0)), c = b.VM.resolvePartial.call(this, c, d, e); var f = s.extend({}, e, { hooks: this.hooks, protoAccessControl: this.protoAccessControl }), g = b.VM.invokePartial.call(this, c, d, f); if (null == g && b.compile && (e.partials[e.name] = b.compile(c, a.compilerOptions, b), g = e.partials[e.name](d, f)), null != g) { if (e.indent) { for (var h = g.split("\n"), i = 0, j = h.length; i < j && (h[i] || i + 1 !== j); i++)h[i] = e.indent + h[i]; g = h.join("\n") } return g } throw new u["default"]("The partial " + e.name + " could not be compiled when running in runtime-only mode") } function d(b) { function c(b) { return "" + a.main(g, b, g.helpers, g.partials, f, i, h) } var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], f = e.data; d._setup(e), !e.partial && a.useData && (f = j(b, f)); var h = void 0, i = a.useBlockParams ? [] : void 0; return a.useDepths && (h = e.depths ? b != e.depths[0] ? [b].concat(e.depths) : e.depths : [b]), (c = k(a.main, c, g, e.depths || [], f, i))(b, e) } if (!b) throw new u["default"]("No environment passed to template"); if (!a || !a.main) throw new u["default"]("Unknown template object: " + typeof a); a.main.decorator = a.main_d, b.VM.checkRevision(a.compiler); var e = a.compiler && 7 === a.compiler[0], g = { strict: function (a, b, c) { if (!(a && b in a)) throw new u["default"]('"' + b + '" not defined in ' + a, { loc: c }); return g.lookupProperty(a, b) }, lookupProperty: function (a, b) { var c = a[b]; return null == c ? c : Object.prototype.hasOwnProperty.call(a, b) ? c : y.resultIsAllowed(c, g.protoAccessControl, b) ? c : void 0 }, lookup: function (a, b) { for (var c = a.length, d = 0; d < c; d++) { var e = a[d] && g.lookupProperty(a[d], b); if (null != e) return a[d][b] } }, lambda: function (a, b) { return "function" == typeof a ? a.call(b) : a }, escapeExpression: s.escapeExpression, invokePartial: c, fn: function (b) { var c = a[b]; return c.decorator = a[b + "_d"], c }, programs: [], program: function (a, b, c, d, e) { var g = this.programs[a], h = this.fn(a); return b || e || d || c ? g = f(this, a, h, b, c, d, e) : g || (g = this.programs[a] = f(this, a, h)), g }, data: function (a, b) { for (; a && b--;)a = a._parent; return a }, mergeIfNeeded: function (a, b) { var c = a || b; return a && b && a !== b && (c = s.extend({}, b, a)), c }, nullContext: n({}), noop: b.VM.noop, compilerInfo: a.compiler }; return d.isTop = !0, d._setup = function (c) { if (c.partial) g.protoAccessControl = c.protoAccessControl, g.helpers = c.helpers, g.partials = c.partials, g.decorators = c.decorators, g.hooks = c.hooks; else { var d = s.extend({}, b.helpers, c.helpers); l(d, g), g.helpers = d, a.usePartial && (g.partials = g.mergeIfNeeded(c.partials, b.partials)), (a.usePartial || a.useDecorators) && (g.decorators = s.extend({}, b.decorators, c.decorators)), g.hooks = {}, g.protoAccessControl = y.createProtoAccessControl(c); var f = c.allowCallsToHelperMissing || e; w.moveHelperToHooks(g, "helperMissing", f), w.moveHelperToHooks(g, "blockHelperMissing", f) } }, d._child = function (b, c, d, e) { if (a.useBlockParams && !d) throw new u["default"]("must pass block params"); if (a.useDepths && !e) throw new u["default"]("must pass parent depths"); return f(g, b, a[b], c, 0, d, e) }, d } function f(a, b, c, d, e, f, g) { function h(b) { var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], h = g; return !g || b == g[0] || b === a.nullContext && null === g[0] || (h = [b].concat(g)), c(a, b, a.helpers, a.partials, e.data || d, f && [e.blockParams].concat(f), h) } return h = k(c, h, a, g, d, f), h.program = b, h.depth = g ? g.length : 0, h.blockParams = e || 0, h } function g(a, b, c) { return a ? a.call || c.name || (c.name = a, a = c.partials[a]) : a = "@partial-block" === c.name ? c.data["partial-block"] : c.partials[c.name], a } function h(a, b, c) { var d = c.data && c.data["partial-block"]; c.partial = !0, c.ids && (c.data.contextPath = c.ids[0] || c.data.contextPath); var e = void 0; if (c.fn && c.fn !== i && !function () { c.data = v.createFrame(c.data); var a = c.fn; e = c.data["partial-block"] = function (b) { var c = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1]; return c.data = v.createFrame(c.data), c.data["partial-block"] = d, a(b, c) }, a.partials && (c.partials = s.extend({}, c.partials, a.partials)) }(), void 0 === a && e && (a = e), void 0 === a) throw new u["default"]("The partial " + c.name + " could not be found"); if (a instanceof Function) return a(b, c) } function i() { return "" } function j(a, b) { return b && "root" in b || (b = b ? v.createFrame(b) : {}, b.root = a), b } function k(a, b, c, d, e, f) { if (a.decorator) { var g = {}; b = a.decorator(b, g, c, d && d[0], e, f, d), s.extend(b, g) } return b } function l(a, b) { o(a).forEach(function (c) { var d = a[c]; a[c] = m(d, b) }) } function m(a, b) { var c = b.lookupProperty; return x.wrapHelper(a, function (a) { return s.extend({ lookupProperty: c }, a) }) } var n = c(39)["default"], o = c(13)["default"], p = c(3)["default"], q = c(1)["default"]; b.__esModule = !0, b.checkRevision = d, b.template = e, b.wrapProgram = f, b.resolvePartial = g, b.invokePartial = h, b.noop = i; var r = c(5), s = p(r), t = c(6), u = q(t), v = c(4), w = c(10), x = c(43), y = c(33) }, function (a, b, c) { a.exports = { "default": c(40), __esModule: !0 } }, function (a, b, c) { c(41), a.exports = c(21).Object.seal }, function (a, b, c) { var d = c(42); c(18)("seal", function (a) { return function (b) { return a && d(b) ? a(b) : b } }) }, function (a, b) { a.exports = function (a) { return "object" == typeof a ? null !== a : "function" == typeof a } }, function (a, b) { "use strict"; function c(a, b) { if ("function" != typeof a) return a; var c = function () { var c = arguments[arguments.length - 1]; return arguments[arguments.length - 1] = b(c), a.apply(this, arguments) }; return c } b.__esModule = !0, b.wrapHelper = c }, function (a, b) { (function (c) { "use strict"; b.__esModule = !0, b["default"] = function (a) { var b = "undefined" != typeof c ? c : window, d = b.Handlebars; a.noConflict = function () { return b.Handlebars === a && (b.Handlebars = d), a } }, a.exports = b["default"] }).call(b, function () { return this }()) }, function (a, b) { "use strict"; b.__esModule = !0; var c = { helpers: { helperExpression: function (a) { return "SubExpression" === a.type || ("MustacheStatement" === a.type || "BlockStatement" === a.type) && !!(a.params && a.params.length || a.hash) }, scopedId: function (a) { return /^\.|this\b/.test(a.original) }, simpleId: function (a) { return 1 === a.parts.length && !c.helpers.scopedId(a) && !a.depth } } }; b["default"] = c, a.exports = b["default"] }, function (a, b, c) { "use strict"; function d(a, b) { if ("Program" === a.type) return a; i["default"].yy = o, o.locInfo = function (a) { return new o.SourceLocation(b && b.srcName, a) }; var c = i["default"].parse(a); return c } function e(a, b) { var c = d(a, b), e = new k["default"](b); return e.accept(c) } var f = c(1)["default"], g = c(3)["default"]; b.__esModule = !0, b.parseWithoutProcessing = d, b.parse = e; var h = c(47), i = f(h), j = c(48), k = f(j), l = c(50), m = g(l), n = c(5); b.parser = i["default"]; var o = {}; n.extend(o, m) }, function (a, b) {
        "use strict"; b.__esModule = !0; var c = function () {
            function a() { this.yy = {} } var b = {
                trace: function () { }, yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" }, productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]], performAction: function (a, b, c, d, e, f, g) { var h = f.length - 1; switch (e) { case 1: return f[h - 1]; case 2: this.$ = d.prepareProgram(f[h]); break; case 3: this.$ = f[h]; break; case 4: this.$ = f[h]; break; case 5: this.$ = f[h]; break; case 6: this.$ = f[h]; break; case 7: this.$ = f[h]; break; case 8: this.$ = f[h]; break; case 9: this.$ = { type: "CommentStatement", value: d.stripComment(f[h]), strip: d.stripFlags(f[h], f[h]), loc: d.locInfo(this._$) }; break; case 10: this.$ = { type: "ContentStatement", original: f[h], value: f[h], loc: d.locInfo(this._$) }; break; case 11: this.$ = d.prepareRawBlock(f[h - 2], f[h - 1], f[h], this._$); break; case 12: this.$ = { path: f[h - 3], params: f[h - 2], hash: f[h - 1] }; break; case 13: this.$ = d.prepareBlock(f[h - 3], f[h - 2], f[h - 1], f[h], !1, this._$); break; case 14: this.$ = d.prepareBlock(f[h - 3], f[h - 2], f[h - 1], f[h], !0, this._$); break; case 15: this.$ = { open: f[h - 5], path: f[h - 4], params: f[h - 3], hash: f[h - 2], blockParams: f[h - 1], strip: d.stripFlags(f[h - 5], f[h]) }; break; case 16: this.$ = { path: f[h - 4], params: f[h - 3], hash: f[h - 2], blockParams: f[h - 1], strip: d.stripFlags(f[h - 5], f[h]) }; break; case 17: this.$ = { path: f[h - 4], params: f[h - 3], hash: f[h - 2], blockParams: f[h - 1], strip: d.stripFlags(f[h - 5], f[h]) }; break; case 18: this.$ = { strip: d.stripFlags(f[h - 1], f[h - 1]), program: f[h] }; break; case 19: var i = d.prepareBlock(f[h - 2], f[h - 1], f[h], f[h], !1, this._$), j = d.prepareProgram([i], f[h - 1].loc); j.chained = !0, this.$ = { strip: f[h - 2].strip, program: j, chain: !0 }; break; case 20: this.$ = f[h]; break; case 21: this.$ = { path: f[h - 1], strip: d.stripFlags(f[h - 2], f[h]) }; break; case 22: this.$ = d.prepareMustache(f[h - 3], f[h - 2], f[h - 1], f[h - 4], d.stripFlags(f[h - 4], f[h]), this._$); break; case 23: this.$ = d.prepareMustache(f[h - 3], f[h - 2], f[h - 1], f[h - 4], d.stripFlags(f[h - 4], f[h]), this._$); break; case 24: this.$ = { type: "PartialStatement", name: f[h - 3], params: f[h - 2], hash: f[h - 1], indent: "", strip: d.stripFlags(f[h - 4], f[h]), loc: d.locInfo(this._$) }; break; case 25: this.$ = d.preparePartialBlock(f[h - 2], f[h - 1], f[h], this._$); break; case 26: this.$ = { path: f[h - 3], params: f[h - 2], hash: f[h - 1], strip: d.stripFlags(f[h - 4], f[h]) }; break; case 27: this.$ = f[h]; break; case 28: this.$ = f[h]; break; case 29: this.$ = { type: "SubExpression", path: f[h - 3], params: f[h - 2], hash: f[h - 1], loc: d.locInfo(this._$) }; break; case 30: this.$ = { type: "Hash", pairs: f[h], loc: d.locInfo(this._$) }; break; case 31: this.$ = { type: "HashPair", key: d.id(f[h - 2]), value: f[h], loc: d.locInfo(this._$) }; break; case 32: this.$ = d.id(f[h - 1]); break; case 33: this.$ = f[h]; break; case 34: this.$ = f[h]; break; case 35: this.$ = { type: "StringLiteral", value: f[h], original: f[h], loc: d.locInfo(this._$) }; break; case 36: this.$ = { type: "NumberLiteral", value: Number(f[h]), original: Number(f[h]), loc: d.locInfo(this._$) }; break; case 37: this.$ = { type: "BooleanLiteral", value: "true" === f[h], original: "true" === f[h], loc: d.locInfo(this._$) }; break; case 38: this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: d.locInfo(this._$) }; break; case 39: this.$ = { type: "NullLiteral", original: null, value: null, loc: d.locInfo(this._$) }; break; case 40: this.$ = f[h]; break; case 41: this.$ = f[h]; break; case 42: this.$ = d.preparePath(!0, f[h], this._$); break; case 43: this.$ = d.preparePath(!1, f[h], this._$); break; case 44: f[h - 2].push({ part: d.id(f[h]), original: f[h], separator: f[h - 1] }), this.$ = f[h - 2]; break; case 45: this.$ = [{ part: d.id(f[h]), original: f[h] }]; break; case 46: this.$ = []; break; case 47: f[h - 1].push(f[h]); break; case 48: this.$ = []; break; case 49: f[h - 1].push(f[h]); break; case 50: this.$ = []; break; case 51: f[h - 1].push(f[h]); break; case 58: this.$ = []; break; case 59: f[h - 1].push(f[h]); break; case 64: this.$ = []; break; case 65: f[h - 1].push(f[h]); break; case 70: this.$ = []; break; case 71: f[h - 1].push(f[h]); break; case 78: this.$ = []; break; case 79: f[h - 1].push(f[h]); break; case 82: this.$ = []; break; case 83: f[h - 1].push(f[h]); break; case 86: this.$ = []; break; case 87: f[h - 1].push(f[h]); break; case 90: this.$ = []; break; case 91: f[h - 1].push(f[h]); break; case 94: this.$ = []; break; case 95: f[h - 1].push(f[h]); break; case 98: this.$ = [f[h]]; break; case 99: f[h - 1].push(f[h]); break; case 100: this.$ = [f[h]]; break; case 101: f[h - 1].push(f[h]) } }, table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, {
                    33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41]
                }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }], defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] }, parseError: function (a, b) { throw new Error(a) }, parse: function (a) { function b() { var a; return a = c.lexer.lex() || 1, "number" != typeof a && (a = c.symbols_[a] || a), a } var c = this, d = [0], e = [null], f = [], g = this.table, h = "", i = 0, j = 0, k = 0; this.lexer.setInput(a), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, "undefined" == typeof this.lexer.yylloc && (this.lexer.yylloc = {}); var l = this.lexer.yylloc; f.push(l); var m = this.lexer.options && this.lexer.options.ranges; "function" == typeof this.yy.parseError && (this.parseError = this.yy.parseError); for (var n, o, p, q, r, s, t, u, v, w = {}; ;) { if (p = d[d.length - 1], this.defaultActions[p] ? q = this.defaultActions[p] : (null !== n && "undefined" != typeof n || (n = b()), q = g[p] && g[p][n]), "undefined" == typeof q || !q.length || !q[0]) { var x = ""; if (!k) { v = []; for (s in g[p]) this.terminals_[s] && s > 2 && v.push("'" + this.terminals_[s] + "'"); x = this.lexer.showPosition ? "Parse error on line " + (i + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + v.join(", ") + ", got '" + (this.terminals_[n] || n) + "'" : "Parse error on line " + (i + 1) + ": Unexpected " + (1 == n ? "end of input" : "'" + (this.terminals_[n] || n) + "'"), this.parseError(x, { text: this.lexer.match, token: this.terminals_[n] || n, line: this.lexer.yylineno, loc: l, expected: v }) } } if (q[0] instanceof Array && q.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + p + ", token: " + n); switch (q[0]) { case 1: d.push(n), e.push(this.lexer.yytext), f.push(this.lexer.yylloc), d.push(q[1]), n = null, o ? (n = o, o = null) : (j = this.lexer.yyleng, h = this.lexer.yytext, i = this.lexer.yylineno, l = this.lexer.yylloc, k > 0 && k--); break; case 2: if (t = this.productions_[q[1]][1], w.$ = e[e.length - t], w._$ = { first_line: f[f.length - (t || 1)].first_line, last_line: f[f.length - 1].last_line, first_column: f[f.length - (t || 1)].first_column, last_column: f[f.length - 1].last_column }, m && (w._$.range = [f[f.length - (t || 1)].range[0], f[f.length - 1].range[1]]), r = this.performAction.call(w, h, j, i, this.yy, q[1], e, f), "undefined" != typeof r) return r; t && (d = d.slice(0, -1 * t * 2), e = e.slice(0, -1 * t), f = f.slice(0, -1 * t)), d.push(this.productions_[q[1]][0]), e.push(w.$), f.push(w._$), u = g[d[d.length - 2]][d[d.length - 1]], d.push(u); break; case 3: return !0 } } return !0 }
            }, c = function () { var a = { EOF: 1, parseError: function (a, b) { if (!this.yy.parser) throw new Error(a); this.yy.parser.parseError(a, b) }, setInput: function (a) { return this._input = a, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this }, input: function () { var a = this._input[0]; this.yytext += a, this.yyleng++, this.offset++, this.match += a, this.matched += a; var b = a.match(/(?:\r\n?|\n).*/g); return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), a }, unput: function (a) { var b = a.length, c = a.split(/(?:\r\n?|\n)/g); this._input = a + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b; var d = this.match.split(/(?:\r\n?|\n)/g); this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), c.length - 1 && (this.yylineno -= c.length - 1); var e = this.yylloc.range; return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: c ? (c.length === d.length ? this.yylloc.first_column : 0) + d[d.length - c.length].length - c[0].length : this.yylloc.first_column - b }, this.options.ranges && (this.yylloc.range = [e[0], e[0] + this.yyleng - b]), this }, more: function () { return this._more = !0, this }, less: function (a) { this.unput(this.match.slice(a)) }, pastInput: function () { var a = this.matched.substr(0, this.matched.length - this.match.length); return (a.length > 20 ? "..." : "") + a.substr(-20).replace(/\n/g, "") }, upcomingInput: function () { var a = this.match; return a.length < 20 && (a += this._input.substr(0, 20 - a.length)), (a.substr(0, 20) + (a.length > 20 ? "..." : "")).replace(/\n/g, "") }, showPosition: function () { var a = this.pastInput(), b = new Array(a.length + 1).join("-"); return a + this.upcomingInput() + "\n" + b + "^" }, next: function () { if (this.done) return this.EOF; this._input || (this.done = !0); var a, b, c, d, e; this._more || (this.yytext = "", this.match = ""); for (var f = this._currentRules(), g = 0; g < f.length && (c = this._input.match(this.rules[f[g]]), !c || b && !(c[0].length > b[0].length) || (b = c, d = g, this.options.flex)); g++); return b ? (e = b[0].match(/(?:\r\n?|\n).*/g), e && (this.yylineno += e.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: e ? e[e.length - 1].length - e[e.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + b[0].length }, this.yytext += b[0], this.match += b[0], this.matches = b, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(b[0].length), this.matched += b[0], a = this.performAction.call(this, this.yy, this, f[d], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), a ? a : void 0) : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno }) }, lex: function () { var a = this.next(); return "undefined" != typeof a ? a : this.lex() }, begin: function (a) { this.conditionStack.push(a) }, popState: function () { return this.conditionStack.pop() }, _currentRules: function () { return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules }, topState: function () { return this.conditionStack[this.conditionStack.length - 2] }, pushState: function (a) { this.begin(a) } }; return a.options = {}, a.performAction = function (a, b, c, d) { function e(a, c) { return b.yytext = b.yytext.substring(a, b.yyleng - c + a) } switch (c) { case 0: if ("\\\\" === b.yytext.slice(-2) ? (e(0, 1), this.begin("mu")) : "\\" === b.yytext.slice(-1) ? (e(0, 1), this.begin("emu")) : this.begin("mu"), b.yytext) return 15; break; case 1: return 15; case 2: return this.popState(), 15; case 3: return this.begin("raw"), 15; case 4: return this.popState(), "raw" === this.conditionStack[this.conditionStack.length - 1] ? 15 : (e(5, 9), "END_RAW_BLOCK"); case 5: return 15; case 6: return this.popState(), 14; case 7: return 65; case 8: return 68; case 9: return 19; case 10: return this.popState(), this.begin("raw"), 23; case 11: return 55; case 12: return 60; case 13: return 29; case 14: return 47; case 15: return this.popState(), 44; case 16: return this.popState(), 44; case 17: return 34; case 18: return 39; case 19: return 51; case 20: return 48; case 21: this.unput(b.yytext), this.popState(), this.begin("com"); break; case 22: return this.popState(), 14; case 23: return 48; case 24: return 73; case 25: return 72; case 26: return 72; case 27: return 87; case 28: break; case 29: return this.popState(), 54; case 30: return this.popState(), 33; case 31: return b.yytext = e(1, 2).replace(/\\"/g, '"'), 80; case 32: return b.yytext = e(1, 2).replace(/\\'/g, "'"), 80; case 33: return 85; case 34: return 82; case 35: return 82; case 36: return 83; case 37: return 84; case 38: return 81; case 39: return 75; case 40: return 77; case 41: return 72; case 42: return b.yytext = b.yytext.replace(/\\([\\\]])/g, "$1"), 72; case 43: return "INVALID"; case 44: return 5 } }, a.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], a.conditions = { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: !1 }, emu: { rules: [2], inclusive: !1 }, com: { rules: [6], inclusive: !1 }, raw: { rules: [3, 4, 5], inclusive: !1 }, INITIAL: { rules: [0, 1, 44], inclusive: !0 } }, a }(); return b.lexer = c, a.prototype = b, b.Parser = a, new a
        }(); b["default"] = c, a.exports = b["default"]
    }, function (a, b, c) { "use strict"; function d() { var a = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]; this.options = a } function e(a, b, c) { void 0 === b && (b = a.length); var d = a[b - 1], e = a[b - 2]; return d ? "ContentStatement" === d.type ? (e || !c ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(d.original) : void 0 : c } function f(a, b, c) { void 0 === b && (b = -1); var d = a[b + 1], e = a[b + 2]; return d ? "ContentStatement" === d.type ? (e || !c ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(d.original) : void 0 : c } function g(a, b, c) { var d = a[null == b ? 0 : b + 1]; if (d && "ContentStatement" === d.type && (c || !d.rightStripped)) { var e = d.value; d.value = d.value.replace(c ? /^\s+/ : /^[ \t]*\r?\n?/, ""), d.rightStripped = d.value !== e } } function h(a, b, c) { var d = a[null == b ? a.length - 1 : b - 1]; if (d && "ContentStatement" === d.type && (c || !d.leftStripped)) { var e = d.value; return d.value = d.value.replace(c ? /\s+$/ : /[ \t]+$/, ""), d.leftStripped = d.value !== e, d.leftStripped } } var i = c(1)["default"]; b.__esModule = !0; var j = c(49), k = i(j); d.prototype = new k["default"], d.prototype.Program = function (a) { var b = !this.options.ignoreStandalone, c = !this.isRootSeen; this.isRootSeen = !0; for (var d = a.body, i = 0, j = d.length; i < j; i++) { var k = d[i], l = this.accept(k); if (l) { var m = e(d, i, c), n = f(d, i, c), o = l.openStandalone && m, p = l.closeStandalone && n, q = l.inlineStandalone && m && n; l.close && g(d, i, !0), l.open && h(d, i, !0), b && q && (g(d, i), h(d, i) && "PartialStatement" === k.type && (k.indent = /([ \t]+$)/.exec(d[i - 1].original)[1])), b && o && (g((k.program || k.inverse).body), h(d, i)), b && p && (g(d, i), h((k.inverse || k.program).body)) } } return a }, d.prototype.BlockStatement = d.prototype.DecoratorBlock = d.prototype.PartialBlockStatement = function (a) { this.accept(a.program), this.accept(a.inverse); var b = a.program || a.inverse, c = a.program && a.inverse, d = c, i = c; if (c && c.chained) for (d = c.body[0].program; i.chained;)i = i.body[i.body.length - 1].program; var j = { open: a.openStrip.open, close: a.closeStrip.close, openStandalone: f(b.body), closeStandalone: e((d || b).body) }; if (a.openStrip.close && g(b.body, null, !0), c) { var k = a.inverseStrip; k.open && h(b.body, null, !0), k.close && g(d.body, null, !0), a.closeStrip.open && h(i.body, null, !0), !this.options.ignoreStandalone && e(b.body) && f(d.body) && (h(b.body), g(d.body)) } else a.closeStrip.open && h(b.body, null, !0); return j }, d.prototype.Decorator = d.prototype.MustacheStatement = function (a) { return a.strip }, d.prototype.PartialStatement = d.prototype.CommentStatement = function (a) { var b = a.strip || {}; return { inlineStandalone: !0, open: b.open, close: b.close } }, b["default"] = d, a.exports = b["default"] }, function (a, b, c) { "use strict"; function d() { this.parents = [] } function e(a) { this.acceptRequired(a, "path"), this.acceptArray(a.params), this.acceptKey(a, "hash") } function f(a) { e.call(this, a), this.acceptKey(a, "program"), this.acceptKey(a, "inverse") } function g(a) { this.acceptRequired(a, "name"), this.acceptArray(a.params), this.acceptKey(a, "hash") } var h = c(1)["default"]; b.__esModule = !0; var i = c(6), j = h(i); d.prototype = { constructor: d, mutating: !1, acceptKey: function (a, b) { var c = this.accept(a[b]); if (this.mutating) { if (c && !d.prototype[c.type]) throw new j["default"]('Unexpected node type "' + c.type + '" found when accepting ' + b + " on " + a.type); a[b] = c } }, acceptRequired: function (a, b) { if (this.acceptKey(a, b), !a[b]) throw new j["default"](a.type + " requires " + b) }, acceptArray: function (a) { for (var b = 0, c = a.length; b < c; b++)this.acceptKey(a, b), a[b] || (a.splice(b, 1), b--, c--) }, accept: function (a) { if (a) { if (!this[a.type]) throw new j["default"]("Unknown type: " + a.type, a); this.current && this.parents.unshift(this.current), this.current = a; var b = this[a.type](a); return this.current = this.parents.shift(), !this.mutating || b ? b : b !== !1 ? a : void 0 } }, Program: function (a) { this.acceptArray(a.body) }, MustacheStatement: e, Decorator: e, BlockStatement: f, DecoratorBlock: f, PartialStatement: g, PartialBlockStatement: function (a) { g.call(this, a), this.acceptKey(a, "program") }, ContentStatement: function () { }, CommentStatement: function () { }, SubExpression: e, PathExpression: function () { }, StringLiteral: function () { }, NumberLiteral: function () { }, BooleanLiteral: function () { }, UndefinedLiteral: function () { }, NullLiteral: function () { }, Hash: function (a) { this.acceptArray(a.pairs) }, HashPair: function (a) { this.acceptRequired(a, "value") } }, b["default"] = d, a.exports = b["default"] }, function (a, b, c) { "use strict"; function d(a, b) { if (b = b.path ? b.path.original : b, a.path.original !== b) { var c = { loc: a.path.loc }; throw new q["default"](a.path.original + " doesn't match " + b, c) } } function e(a, b) { this.source = a, this.start = { line: b.first_line, column: b.first_column }, this.end = { line: b.last_line, column: b.last_column } } function f(a) { return /^\[.*\]$/.test(a) ? a.substring(1, a.length - 1) : a } function g(a, b) { return { open: "~" === a.charAt(2), close: "~" === b.charAt(b.length - 3) } } function h(a) { return a.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "") } function i(a, b, c) { c = this.locInfo(c); for (var d = a ? "@" : "", e = [], f = 0, g = 0, h = b.length; g < h; g++) { var i = b[g].part, j = b[g].original !== i; if (d += (b[g].separator || "") + i, j || ".." !== i && "." !== i && "this" !== i) e.push(i); else { if (e.length > 0) throw new q["default"]("Invalid path: " + d, { loc: c }); ".." === i && f++ } } return { type: "PathExpression", data: a, depth: f, parts: e, original: d, loc: c } } function j(a, b, c, d, e, f) { var g = d.charAt(3) || d.charAt(2), h = "{" !== g && "&" !== g, i = /\*/.test(d); return { type: i ? "Decorator" : "MustacheStatement", path: a, params: b, hash: c, escaped: h, strip: e, loc: this.locInfo(f) } } function k(a, b, c, e) { d(a, c), e = this.locInfo(e); var f = { type: "Program", body: b, strip: {}, loc: e }; return { type: "BlockStatement", path: a.path, params: a.params, hash: a.hash, program: f, openStrip: {}, inverseStrip: {}, closeStrip: {}, loc: e } } function l(a, b, c, e, f, g) { e && e.path && d(a, e); var h = /\*/.test(a.open); b.blockParams = a.blockParams; var i = void 0, j = void 0; if (c) { if (h) throw new q["default"]("Unexpected inverse block on decorator", c); c.chain && (c.program.body[0].closeStrip = e.strip), j = c.strip, i = c.program } return f && (f = i, i = b, b = f), { type: h ? "DecoratorBlock" : "BlockStatement", path: a.path, params: a.params, hash: a.hash, program: b, inverse: i, openStrip: a.strip, inverseStrip: j, closeStrip: e && e.strip, loc: this.locInfo(g) } } function m(a, b) { if (!b && a.length) { var c = a[0].loc, d = a[a.length - 1].loc; c && d && (b = { source: c.source, start: { line: c.start.line, column: c.start.column }, end: { line: d.end.line, column: d.end.column } }) } return { type: "Program", body: a, strip: {}, loc: b } } function n(a, b, c, e) { return d(a, c), { type: "PartialBlockStatement", name: a.path, params: a.params, hash: a.hash, program: b, openStrip: a.strip, closeStrip: c && c.strip, loc: this.locInfo(e) } } var o = c(1)["default"]; b.__esModule = !0, b.SourceLocation = e, b.id = f, b.stripFlags = g, b.stripComment = h, b.preparePath = i, b.prepareMustache = j, b.prepareRawBlock = k, b.prepareBlock = l, b.prepareProgram = m, b.preparePartialBlock = n; var p = c(6), q = o(p) }, function (a, b, c) { "use strict"; function d() { } function e(a, b, c) { if (null == a || "string" != typeof a && "Program" !== a.type) throw new l["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + a); b = b || {}, "data" in b || (b.data = !0), b.compat && (b.useDepths = !0); var d = c.parse(a, b), e = (new c.Compiler).compile(d, b); return (new c.JavaScriptCompiler).compile(e, b) } function f(a, b, c) { function d() { var d = c.parse(a, b), e = (new c.Compiler).compile(d, b), f = (new c.JavaScriptCompiler).compile(e, b, void 0, !0); return c.template(f) } function e(a, b) { return f || (f = d()), f.call(this, a, b) } if (void 0 === b && (b = {}), null == a || "string" != typeof a && "Program" !== a.type) throw new l["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + a); b = m.extend({}, b), "data" in b || (b.data = !0), b.compat && (b.useDepths = !0); var f = void 0; return e._setup = function (a) { return f || (f = d()), f._setup(a) }, e._child = function (a, b, c, e) { return f || (f = d()), f._child(a, b, c, e) }, e } function g(a, b) { if (a === b) return !0; if (m.isArray(a) && m.isArray(b) && a.length === b.length) { for (var c = 0; c < a.length; c++)if (!g(a[c], b[c])) return !1; return !0 } } function h(a) { if (!a.path.parts) { var b = a.path; a.path = { type: "PathExpression", data: !1, depth: 0, parts: [b.original + ""], original: b.original + "", loc: b.loc } } } var i = c(34)["default"], j = c(1)["default"]; b.__esModule = !0, b.Compiler = d, b.precompile = e, b.compile = f; var k = c(6), l = j(k), m = c(5), n = c(45), o = j(n), p = [].slice; d.prototype = { compiler: d, equals: function (a) { var b = this.opcodes.length; if (a.opcodes.length !== b) return !1; for (var c = 0; c < b; c++) { var d = this.opcodes[c], e = a.opcodes[c]; if (d.opcode !== e.opcode || !g(d.args, e.args)) return !1 } b = this.children.length; for (var c = 0; c < b; c++)if (!this.children[c].equals(a.children[c])) return !1; return !0 }, guid: 0, compile: function (a, b) { return this.sourceNode = [], this.opcodes = [], this.children = [], this.options = b, this.stringParams = b.stringParams, this.trackIds = b.trackIds, b.blockParams = b.blockParams || [], b.knownHelpers = m.extend(i(null), { helperMissing: !0, blockHelperMissing: !0, each: !0, "if": !0, unless: !0, "with": !0, log: !0, lookup: !0 }, b.knownHelpers), this.accept(a) }, compileProgram: function (a) { var b = new this.compiler, c = b.compile(a, this.options), d = this.guid++; return this.usePartial = this.usePartial || c.usePartial, this.children[d] = c, this.useDepths = this.useDepths || c.useDepths, d }, accept: function (a) { if (!this[a.type]) throw new l["default"]("Unknown type: " + a.type, a); this.sourceNode.unshift(a); var b = this[a.type](a); return this.sourceNode.shift(), b }, Program: function (a) { this.options.blockParams.unshift(a.blockParams); for (var b = a.body, c = b.length, d = 0; d < c; d++)this.accept(b[d]); return this.options.blockParams.shift(), this.isSimple = 1 === c, this.blockParams = a.blockParams ? a.blockParams.length : 0, this }, BlockStatement: function (a) { h(a); var b = a.program, c = a.inverse; b = b && this.compileProgram(b), c = c && this.compileProgram(c); var d = this.classifySexpr(a); "helper" === d ? this.helperSexpr(a, b, c) : "simple" === d ? (this.simpleSexpr(a), this.opcode("pushProgram", b), this.opcode("pushProgram", c), this.opcode("emptyHash"), this.opcode("blockValue", a.path.original)) : (this.ambiguousSexpr(a, b, c), this.opcode("pushProgram", b), this.opcode("pushProgram", c), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append") }, DecoratorBlock: function (a) { var b = a.program && this.compileProgram(a.program), c = this.setupFullMustacheParams(a, b, void 0), d = a.path; this.useDecorators = !0, this.opcode("registerDecorator", c.length, d.original) }, PartialStatement: function (a) { this.usePartial = !0; var b = a.program; b && (b = this.compileProgram(a.program)); var c = a.params; if (c.length > 1) throw new l["default"]("Unsupported number of partial arguments: " + c.length, a); c.length || (this.options.explicitPartialContext ? this.opcode("pushLiteral", "undefined") : c.push({ type: "PathExpression", parts: [], depth: 0 })); var d = a.name.original, e = "SubExpression" === a.name.type; e && this.accept(a.name), this.setupFullMustacheParams(a, b, void 0, !0); var f = a.indent || ""; this.options.preventIndent && f && (this.opcode("appendContent", f), f = ""), this.opcode("invokePartial", e, d, f), this.opcode("append") }, PartialBlockStatement: function (a) { this.PartialStatement(a) }, MustacheStatement: function (a) { this.SubExpression(a), a.escaped && !this.options.noEscape ? this.opcode("appendEscaped") : this.opcode("append") }, Decorator: function (a) { this.DecoratorBlock(a) }, ContentStatement: function (a) { a.value && this.opcode("appendContent", a.value) }, CommentStatement: function () { }, SubExpression: function (a) { h(a); var b = this.classifySexpr(a); "simple" === b ? this.simpleSexpr(a) : "helper" === b ? this.helperSexpr(a) : this.ambiguousSexpr(a) }, ambiguousSexpr: function (a, b, c) { var d = a.path, e = d.parts[0], f = null != b || null != c; this.opcode("getContext", d.depth), this.opcode("pushProgram", b), this.opcode("pushProgram", c), d.strict = !0, this.accept(d), this.opcode("invokeAmbiguous", e, f) }, simpleSexpr: function (a) { var b = a.path; b.strict = !0, this.accept(b), this.opcode("resolvePossibleLambda") }, helperSexpr: function (a, b, c) { var d = this.setupFullMustacheParams(a, b, c), e = a.path, f = e.parts[0]; if (this.options.knownHelpers[f]) this.opcode("invokeKnownHelper", d.length, f); else { if (this.options.knownHelpersOnly) throw new l["default"]("You specified knownHelpersOnly, but used the unknown helper " + f, a); e.strict = !0, e.falsy = !0, this.accept(e), this.opcode("invokeHelper", d.length, e.original, o["default"].helpers.simpleId(e)) } }, PathExpression: function (a) { this.addDepth(a.depth), this.opcode("getContext", a.depth); var b = a.parts[0], c = o["default"].helpers.scopedId(a), d = !a.depth && !c && this.blockParamIndex(b); d ? this.opcode("lookupBlockParam", d, a.parts) : b ? a.data ? (this.options.data = !0, this.opcode("lookupData", a.depth, a.parts, a.strict)) : this.opcode("lookupOnContext", a.parts, a.falsy, a.strict, c) : this.opcode("pushContext") }, StringLiteral: function (a) { this.opcode("pushString", a.value) }, NumberLiteral: function (a) { this.opcode("pushLiteral", a.value) }, BooleanLiteral: function (a) { this.opcode("pushLiteral", a.value) }, UndefinedLiteral: function () { this.opcode("pushLiteral", "undefined") }, NullLiteral: function () { this.opcode("pushLiteral", "null") }, Hash: function (a) { var b = a.pairs, c = 0, d = b.length; for (this.opcode("pushHash"); c < d; c++)this.pushParam(b[c].value); for (; c--;)this.opcode("assignToHash", b[c].key); this.opcode("popHash") }, opcode: function (a) { this.opcodes.push({ opcode: a, args: p.call(arguments, 1), loc: this.sourceNode[0].loc }) }, addDepth: function (a) { a && (this.useDepths = !0) }, classifySexpr: function (a) { var b = o["default"].helpers.simpleId(a.path), c = b && !!this.blockParamIndex(a.path.parts[0]), d = !c && o["default"].helpers.helperExpression(a), e = !c && (d || b); if (e && !d) { var f = a.path.parts[0], g = this.options; g.knownHelpers[f] ? d = !0 : g.knownHelpersOnly && (e = !1) } return d ? "helper" : e ? "ambiguous" : "simple" }, pushParams: function (a) { for (var b = 0, c = a.length; b < c; b++)this.pushParam(a[b]) }, pushParam: function (a) { var b = null != a.value ? a.value : a.original || ""; if (this.stringParams) b.replace && (b = b.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".")), a.depth && this.addDepth(a.depth), this.opcode("getContext", a.depth || 0), this.opcode("pushStringParam", b, a.type), "SubExpression" === a.type && this.accept(a); else { if (this.trackIds) { var c = void 0; if (!a.parts || o["default"].helpers.scopedId(a) || a.depth || (c = this.blockParamIndex(a.parts[0])), c) { var d = a.parts.slice(1).join("."); this.opcode("pushId", "BlockParam", c, d) } else b = a.original || b, b.replace && (b = b.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "")), this.opcode("pushId", a.type, b) } this.accept(a) } }, setupFullMustacheParams: function (a, b, c, d) { var e = a.params; return this.pushParams(e), this.opcode("pushProgram", b), this.opcode("pushProgram", c), a.hash ? this.accept(a.hash) : this.opcode("emptyHash", d), e }, blockParamIndex: function (a) { for (var b = 0, c = this.options.blockParams.length; b < c; b++) { var d = this.options.blockParams[b], e = d && m.indexOf(d, a); if (d && e >= 0) return [b, e] } } } }, function (a, b, c) {
        "use strict"; function d(a) { this.value = a } function e() { } function f(a, b, c, d) { var e = b.popStack(), f = 0, g = c.length; for (a && g--; f < g; f++)e = b.nameLookup(e, c[f], d); return a ? [b.aliasable("container.strict"), "(", e, ", ", b.quotedString(c[f]), ", ", JSON.stringify(b.source.currentLocation), " )"] : e } var g = c(13)["default"], h = c(1)["default"]; b.__esModule = !0; var i = c(4), j = c(6), k = h(j), l = c(5), m = c(53), n = h(m); e.prototype = {
            nameLookup: function (a, b) { return this.internalNameLookup(a, b) }, depthedLookup: function (a) { return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(a), ")"] }, compilerInfo: function () { var a = i.COMPILER_REVISION, b = i.REVISION_CHANGES[a]; return [a, b] }, appendToBuffer: function (a, b, c) { return l.isArray(a) || (a = [a]), a = this.source.wrap(a, b), this.environment.isSimple ? ["return ", a, ";"] : c ? ["buffer += ", a, ";"] : (a.appendToBuffer = !0, a) }, initializeBuffer: function () { return this.quotedString("") }, internalNameLookup: function (a, b) { return this.lookupPropertyFunctionIsUsed = !0, ["lookupProperty(", a, ",", JSON.stringify(b), ")"] }, lookupPropertyFunctionIsUsed: !1, compile: function (a, b, c, d) {
                this.environment = a, this.options = b, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !d, this.name = this.environment.name, this.isChild = !!c, this.context = c || { decorators: [], programs: [], environments: [] }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(a, b), this.useDepths = this.useDepths || a.useDepths || a.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || a.useBlockParams; var e = a.opcodes, f = void 0, g = void 0, h = void 0, i = void 0; for (h = 0, i = e.length; h < i; h++)f = e[h], this.source.currentLocation = f.loc, g = g || f.loc, this[f.opcode].apply(this, f.args); if (this.source.currentLocation = g, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length) throw new k["default"]("Compile completed with content left on stack"); this.decorators.isEmpty() ? this.decorators = void 0 : (this.useDecorators = !0, this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]),
                    this.decorators.push("return fn;"), d ? this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]) : (this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n"), this.decorators.push("}\n"), this.decorators = this.decorators.merge())); var j = this.createFunctionContext(d); if (this.isChild) return j; var l = { compiler: this.compilerInfo(), main: j }; this.decorators && (l.main_d = this.decorators, l.useDecorators = !0); var m = this.context, n = m.programs, o = m.decorators; for (h = 0, i = n.length; h < i; h++)n[h] && (l[h] = n[h], o[h] && (l[h + "_d"] = o[h], l.useDecorators = !0)); return this.environment.usePartial && (l.usePartial = !0), this.options.data && (l.useData = !0), this.useDepths && (l.useDepths = !0), this.useBlockParams && (l.useBlockParams = !0), this.options.compat && (l.compat = !0), d ? l.compilerOptions = this.options : (l.compiler = JSON.stringify(l.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, l = this.objectLiteral(l), b.srcName ? (l = l.toStringWithSourceMap({ file: b.destName }), l.map = l.map && l.map.toString()) : l = l.toString()), l
            }, preamble: function () { this.lastContext = 0, this.source = new n["default"](this.options.srcName), this.decorators = new n["default"](this.options.srcName) }, createFunctionContext: function (a) { var b = this, c = "", d = this.stackVars.concat(this.registers.list); d.length > 0 && (c += ", " + d.join(", ")); var e = 0; g(this.aliases).forEach(function (a) { var d = b.aliases[a]; d.children && d.referenceCount > 1 && (c += ", alias" + ++e + "=" + a, d.children[0] = "alias" + e) }), this.lookupPropertyFunctionIsUsed && (c += ", " + this.lookupPropertyFunctionVarDeclaration()); var f = ["container", "depth0", "helpers", "partials", "data"]; (this.useBlockParams || this.useDepths) && f.push("blockParams"), this.useDepths && f.push("depths"); var h = this.mergeSource(c); return a ? (f.push(h), Function.apply(this, f)) : this.source.wrap(["function(", f.join(","), ") {\n  ", h, "}"]) }, mergeSource: function (a) { var b = this.environment.isSimple, c = !this.forceBuffer, d = void 0, e = void 0, f = void 0, g = void 0; return this.source.each(function (a) { a.appendToBuffer ? (f ? a.prepend("  + ") : f = a, g = a) : (f && (e ? f.prepend("buffer += ") : d = !0, g.add(";"), f = g = void 0), e = !0, b || (c = !1)) }), c ? f ? (f.prepend("return "), g.add(";")) : e || this.source.push('return "";') : (a += ", buffer = " + (d ? "" : this.initializeBuffer()), f ? (f.prepend("return buffer + "), g.add(";")) : this.source.push("return buffer;")), a && this.source.prepend("var " + a.substring(2) + (d ? "" : ";\n")), this.source.merge() }, lookupPropertyFunctionVarDeclaration: function () { return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim() }, blockValue: function (a) { var b = this.aliasable("container.hooks.blockHelperMissing"), c = [this.contextName(0)]; this.setupHelperArgs(a, 0, c); var d = this.popStack(); c.splice(1, 0, d), this.push(this.source.functionCall(b, "call", c)) }, ambiguousBlockValue: function () { var a = this.aliasable("container.hooks.blockHelperMissing"), b = [this.contextName(0)]; this.setupHelperArgs("", 0, b, !0), this.flushInline(); var c = this.topStack(); b.splice(1, 0, c), this.pushSource(["if (!", this.lastHelper, ") { ", c, " = ", this.source.functionCall(a, "call", b), "}"]) }, appendContent: function (a) { this.pendingContent ? a = this.pendingContent + a : this.pendingLocation = this.source.currentLocation, this.pendingContent = a }, append: function () { if (this.isInline()) this.replaceStack(function (a) { return [" != null ? ", a, ' : ""'] }), this.pushSource(this.appendToBuffer(this.popStack())); else { var a = this.popStack(); this.pushSource(["if (", a, " != null) { ", this.appendToBuffer(a, void 0, !0), " }"]), this.environment.isSimple && this.pushSource(["else { ", this.appendToBuffer("''", void 0, !0), " }"]) } }, appendEscaped: function () { this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"])) }, getContext: function (a) { this.lastContext = a }, pushContext: function () { this.pushStackLiteral(this.contextName(this.lastContext)) }, lookupOnContext: function (a, b, c, d) { var e = 0; d || !this.options.compat || this.lastContext ? this.pushContext() : this.push(this.depthedLookup(a[e++])), this.resolvePath("context", a, e, b, c) }, lookupBlockParam: function (a, b) { this.useBlockParams = !0, this.push(["blockParams[", a[0], "][", a[1], "]"]), this.resolvePath("context", b, 1) }, lookupData: function (a, b, c) { a ? this.pushStackLiteral("container.data(data, " + a + ")") : this.pushStackLiteral("data"), this.resolvePath("data", b, 0, !0, c) }, resolvePath: function (a, b, c, d, e) { var g = this; if (this.options.strict || this.options.assumeObjects) return void this.push(f(this.options.strict && e, this, b, a)); for (var h = b.length; c < h; c++)this.replaceStack(function (e) { var f = g.nameLookup(e, b[c], a); return d ? [" && ", f] : [" != null ? ", f, " : ", e] }) }, resolvePossibleLambda: function () { this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]) }, pushStringParam: function (a, b) { this.pushContext(), this.pushString(b), "SubExpression" !== b && ("string" == typeof a ? this.pushString(a) : this.pushStackLiteral(a)) }, emptyHash: function (a) { this.trackIds && this.push("{}"), this.stringParams && (this.push("{}"), this.push("{}")), this.pushStackLiteral(a ? "undefined" : "{}") }, pushHash: function () { this.hash && this.hashes.push(this.hash), this.hash = { values: {}, types: [], contexts: [], ids: [] } }, popHash: function () { var a = this.hash; this.hash = this.hashes.pop(), this.trackIds && this.push(this.objectLiteral(a.ids)), this.stringParams && (this.push(this.objectLiteral(a.contexts)), this.push(this.objectLiteral(a.types))), this.push(this.objectLiteral(a.values)) }, pushString: function (a) { this.pushStackLiteral(this.quotedString(a)) }, pushLiteral: function (a) { this.pushStackLiteral(a) }, pushProgram: function (a) { null != a ? this.pushStackLiteral(this.programExpression(a)) : this.pushStackLiteral(null) }, registerDecorator: function (a, b) { var c = this.nameLookup("decorators", b, "decorator"), d = this.setupHelperArgs(b, a); this.decorators.push(["fn = ", this.decorators.functionCall(c, "", ["fn", "props", "container", d]), " || fn;"]) }, invokeHelper: function (a, b, c) { var d = this.popStack(), e = this.setupHelper(a, b), f = []; c && f.push(e.name), f.push(d), this.options.strict || f.push(this.aliasable("container.hooks.helperMissing")); var g = ["(", this.itemsSeparatedBy(f, "||"), ")"], h = this.source.functionCall(g, "call", e.callParams); this.push(h) }, itemsSeparatedBy: function (a, b) { var c = []; c.push(a[0]); for (var d = 1; d < a.length; d++)c.push(b, a[d]); return c }, invokeKnownHelper: function (a, b) { var c = this.setupHelper(a, b); this.push(this.source.functionCall(c.name, "call", c.callParams)) }, invokeAmbiguous: function (a, b) { this.useRegister("helper"); var c = this.popStack(); this.emptyHash(); var d = this.setupHelper(0, a, b), e = this.lastHelper = this.nameLookup("helpers", a, "helper"), f = ["(", "(helper = ", e, " || ", c, ")"]; this.options.strict || (f[0] = "(helper = ", f.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"))), this.push(["(", f, d.paramsInit ? ["),(", d.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", d.callParams), " : helper))"]) }, invokePartial: function (a, b, c) { var d = [], e = this.setupParams(b, 1, d); a && (b = this.popStack(), delete e.name), c && (e.indent = JSON.stringify(c)), e.helpers = "helpers", e.partials = "partials", e.decorators = "container.decorators", a ? d.unshift(b) : d.unshift(this.nameLookup("partials", b, "partial")), this.options.compat && (e.depths = "depths"), e = this.objectLiteral(e), d.push(e), this.push(this.source.functionCall("container.invokePartial", "", d)) }, assignToHash: function (a) { var b = this.popStack(), c = void 0, d = void 0, e = void 0; this.trackIds && (e = this.popStack()), this.stringParams && (d = this.popStack(), c = this.popStack()); var f = this.hash; c && (f.contexts[a] = c), d && (f.types[a] = d), e && (f.ids[a] = e), f.values[a] = b }, pushId: function (a, b, c) { "BlockParam" === a ? this.pushStackLiteral("blockParams[" + b[0] + "].path[" + b[1] + "]" + (c ? " + " + JSON.stringify("." + c) : "")) : "PathExpression" === a ? this.pushString(b) : "SubExpression" === a ? this.pushStackLiteral("true") : this.pushStackLiteral("null") }, compiler: e, compileChildren: function (a, b) { for (var c = a.children, d = void 0, e = void 0, f = 0, g = c.length; f < g; f++) { d = c[f], e = new this.compiler; var h = this.matchExistingProgram(d); if (null == h) { this.context.programs.push(""); var i = this.context.programs.length; d.index = i, d.name = "program" + i, this.context.programs[i] = e.compile(d, b, this.context, !this.precompile), this.context.decorators[i] = e.decorators, this.context.environments[i] = d, this.useDepths = this.useDepths || e.useDepths, this.useBlockParams = this.useBlockParams || e.useBlockParams, d.useDepths = this.useDepths, d.useBlockParams = this.useBlockParams } else d.index = h.index, d.name = "program" + h.index, this.useDepths = this.useDepths || h.useDepths, this.useBlockParams = this.useBlockParams || h.useBlockParams } }, matchExistingProgram: function (a) { for (var b = 0, c = this.context.environments.length; b < c; b++) { var d = this.context.environments[b]; if (d && d.equals(a)) return d } }, programExpression: function (a) { var b = this.environment.children[a], c = [b.index, "data", b.blockParams]; return (this.useBlockParams || this.useDepths) && c.push("blockParams"), this.useDepths && c.push("depths"), "container.program(" + c.join(", ") + ")" }, useRegister: function (a) { this.registers[a] || (this.registers[a] = !0, this.registers.list.push(a)) }, push: function (a) { return a instanceof d || (a = this.source.wrap(a)), this.inlineStack.push(a), a }, pushStackLiteral: function (a) { this.push(new d(a)) }, pushSource: function (a) { this.pendingContent && (this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0), a && this.source.push(a) }, replaceStack: function (a) { var b = ["("], c = void 0, e = void 0, f = void 0; if (!this.isInline()) throw new k["default"]("replaceStack on non-inline"); var g = this.popStack(!0); if (g instanceof d) c = [g.value], b = ["(", c], f = !0; else { e = !0; var h = this.incrStack(); b = ["((", this.push(h), " = ", g, ")"], c = this.topStack() } var i = a.call(this, c); f || this.popStack(), e && this.stackSlot--, this.push(b.concat(i, ")")) }, incrStack: function () { return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName() }, topStackName: function () { return "stack" + this.stackSlot }, flushInline: function () { var a = this.inlineStack; this.inlineStack = []; for (var b = 0, c = a.length; b < c; b++) { var e = a[b]; if (e instanceof d) this.compileStack.push(e); else { var f = this.incrStack(); this.pushSource([f, " = ", e, ";"]), this.compileStack.push(f) } } }, isInline: function () { return this.inlineStack.length }, popStack: function (a) { var b = this.isInline(), c = (b ? this.inlineStack : this.compileStack).pop(); if (!a && c instanceof d) return c.value; if (!b) { if (!this.stackSlot) throw new k["default"]("Invalid stack pop"); this.stackSlot-- } return c }, topStack: function () { var a = this.isInline() ? this.inlineStack : this.compileStack, b = a[a.length - 1]; return b instanceof d ? b.value : b }, contextName: function (a) { return this.useDepths && a ? "depths[" + a + "]" : "depth" + a }, quotedString: function (a) { return this.source.quotedString(a) }, objectLiteral: function (a) { return this.source.objectLiteral(a) }, aliasable: function (a) { var b = this.aliases[a]; return b ? (b.referenceCount++, b) : (b = this.aliases[a] = this.source.wrap(a), b.aliasable = !0, b.referenceCount = 1, b) }, setupHelper: function (a, b, c) { var d = [], e = this.setupHelperArgs(b, a, d, c), f = this.nameLookup("helpers", b, "helper"), g = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})"); return { params: d, paramsInit: e, name: f, callParams: [g].concat(d) } }, setupParams: function (a, b, c) { var d = {}, e = [], f = [], g = [], h = !c, i = void 0; h && (c = []), d.name = this.quotedString(a), d.hash = this.popStack(), this.trackIds && (d.hashIds = this.popStack()), this.stringParams && (d.hashTypes = this.popStack(), d.hashContexts = this.popStack()); var j = this.popStack(), k = this.popStack(); (k || j) && (d.fn = k || "container.noop", d.inverse = j || "container.noop"); for (var l = b; l--;)i = this.popStack(), c[l] = i, this.trackIds && (g[l] = this.popStack()), this.stringParams && (f[l] = this.popStack(), e[l] = this.popStack()); return h && (d.args = this.source.generateArray(c)), this.trackIds && (d.ids = this.source.generateArray(g)), this.stringParams && (d.types = this.source.generateArray(f), d.contexts = this.source.generateArray(e)), this.options.data && (d.data = "data"), this.useBlockParams && (d.blockParams = "blockParams"), d }, setupHelperArgs: function (a, b, c, d) { var e = this.setupParams(a, b, c); return e.loc = JSON.stringify(this.source.currentLocation), e = this.objectLiteral(e), d ? (this.useRegister("options"), c.push("options"), ["options=", e]) : c ? (c.push(e), "") : e }
        }, function () { for (var a = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), b = e.RESERVED_WORDS = {}, c = 0, d = a.length; c < d; c++)b[a[c]] = !0 }(), e.isValidJavaScriptVariableName = function (a) { return !e.RESERVED_WORDS[a] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(a) }, b["default"] = e, a.exports = b["default"]
    }, function (a, b, c) { "use strict"; function d(a, b, c) { if (g.isArray(a)) { for (var d = [], e = 0, f = a.length; e < f; e++)d.push(b.wrap(a[e], c)); return d } return "boolean" == typeof a || "number" == typeof a ? a + "" : a } function e(a) { this.srcFile = a, this.source = [] } var f = c(13)["default"]; b.__esModule = !0; var g = c(5), h = void 0; try { } catch (i) { } h || (h = function (a, b, c, d) { this.src = "", d && this.add(d) }, h.prototype = { add: function (a) { g.isArray(a) && (a = a.join("")), this.src += a }, prepend: function (a) { g.isArray(a) && (a = a.join("")), this.src = a + this.src }, toStringWithSourceMap: function () { return { code: this.toString() } }, toString: function () { return this.src } }), e.prototype = { isEmpty: function () { return !this.source.length }, prepend: function (a, b) { this.source.unshift(this.wrap(a, b)) }, push: function (a, b) { this.source.push(this.wrap(a, b)) }, merge: function () { var a = this.empty(); return this.each(function (b) { a.add(["  ", b, "\n"]) }), a }, each: function (a) { for (var b = 0, c = this.source.length; b < c; b++)a(this.source[b]) }, empty: function () { var a = this.currentLocation || { start: {} }; return new h(a.start.line, a.start.column, this.srcFile) }, wrap: function (a) { var b = arguments.length <= 1 || void 0 === arguments[1] ? this.currentLocation || { start: {} } : arguments[1]; return a instanceof h ? a : (a = d(a, this, b), new h(b.start.line, b.start.column, this.srcFile, a)) }, functionCall: function (a, b, c) { return c = this.generateList(c), this.wrap([a, b ? "." + b + "(" : "(", c, ")"]) }, quotedString: function (a) { return '"' + (a + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"' }, objectLiteral: function (a) { var b = this, c = []; f(a).forEach(function (e) { var f = d(a[e], b); "undefined" !== f && c.push([b.quotedString(e), ":", f]) }); var e = this.generateList(c); return e.prepend("{"), e.add("}"), e }, generateList: function (a) { for (var b = this.empty(), c = 0, e = a.length; c < e; c++)c && b.add(","), b.add(d(a[c], this)); return b }, generateArray: function (a) { var b = this.generateList(a); return b.prepend("["), b.add("]"), b } }, b["default"] = e, a.exports = b["default"] }])
});
define('utils/stringUtil', [], function () {
    'use strict';

    var stringUtil = {};

    stringUtil.camelCaseify = function (string) {
        var stringParts = string.split('-'),
            stringLead = stringParts.shift();

        stringParts = stringParts.map(function (stringPart) {
            return stringUtil.capitalize(stringPart);
        });

        return stringLead + stringParts.join('');
    };

    stringUtil.capitalize = function (string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };

    stringUtil.decapitalize = function (string) {
        return string.charAt(0).toLowerCase() + string.slice(1);
    };

    stringUtil.slugify = function (string) {
        return $.trim(string.replace(/\W/g, " ")).replace(/\s\s+/g, ' ').replace(/\s/g, '-').toLowerCase();
    };

    return stringUtil;
});

define('factories/moduleFactory', [
    'jquery',
    'handlebars',
    'utils/stringUtil',
    'utils/statesUtil'
], function (
    $,
    handlebars,
    stringUtil,
    statesUtil
) {
    'use strict';
    /*
        moduleFactory
        =============

        A factory for creating modules by offering base and common methods
        to be executed at initialization. These include:

        - Getting the DOM components of the module and mapping them to the elements
          object
        - Getting the variants applied to the module instance
        - Binding of events based on the events map provided by the module and
          any of its extensions

        It also accepts extensions that can be applied to allow for sharable
        composable objects

        Example:
        moduleFactory({
            self: self,
            o: o,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers
        }).create();

        or (with extension)

        moduleFactory({
            self: self,
            o: o,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers
        }).extend({
            ...any of the attributes that make up a module...
        }).create();
    */

    var moduleFactory = function (module) {
        var fn, factoryInterface, markup, api;


        // Primary methods used to create a module
        fn = {
            // Setup the module and return the factoryInterface
            setup: function () {
                var initModule;

                fn.buildModule();

                initModule = function () {
                    // If the module isn't set to explicitly init then auto init it
                    if (!module.internal.explicitInit) {
                        fn.init();
                    }
                };

                if (typeof module.fn.afterSetup === 'function') {
                    module.fn.afterSetup(initModule);
                } else {
                    initModule();
                }

                // // HACK - DEBUG
                // // uncomment the below to expose all modules on
                // // the window, with all internals hung off them
                // module.self.elements = module.elements;
                // module.self.fn = module.fn;
                // module.self.handlers = module.handlers;
                // module.self.internal = module.internal;
                // window[module.internal.name] = module.self;

                return factoryInterface;
            },

            // The init flow for each module. Is called by default but can be
            // set to be required explicitly by setting `explicitInit: true`
            // on the module's internal object.
            init: function () {
                if (module.internal.$e.data(module.internal.name + 'Inited')) {
                    return;
                }

                if (typeof module.fn.beforeInit === 'function') {
                    module.fn.beforeInit();
                }

                fn.bindEvents();
                fn.applyInitedState();
                module.fn.init();

                if (typeof module.fn.afterInit === 'function') {
                    module.fn.afterInit();
                }

                module.internal.$e.trigger('initComplete');
            },

            isInited: function () {
                return (
                    module.internal.$e.hasClass(markup.INITED) &&
                    !!module.internal.$e.data(module.internal.name + 'Inited')
                );
            },

            // Perform the necessary base methods on the module to construct it
            // such as:
            // - Ensuring it has a root element
            // - Getting its components
            // - Parsing its variants
            // - Binding its events
            buildModule: function () {
                var instanceKey;

                fn.ensureRootEl();

                if (!module.internal.$e.length) {
                    return;
                }

                instanceKey = stringUtil.decapitalize(module.internal.name) + 'Instance';

                fn.extend({
                    fn: api,
                    m: markup
                });

                fn.getComponents();
                fn.getTemplates();
                fn.getModuleVariants();
                fn.extendModuleWithApi();

                module.internal.$e.addClass(markup.SETUP);
                module.internal.$e.data(instanceKey, module.self);
            },

            // Ensure that the module has a root element by trying to apply the
            // $e passed in as an option, or using the selector option
            ensureRootEl: function () {
                if (!module.internal.$e || !module.internal.$e.length) {
                    module.internal.$e = (
                        module.o.$e ||
                        $(module.o.selector)
                    );
                }
            },

            // Extend the module by deep merging the extension into the module.
            extend: function (extension) {
                $.each(extension, function (extensionKey, extensionComponent) {
                    var extendedComponent = {};
                    if (module[extensionKey]) {
                        $.extend(true, extendedComponent, extensionComponent, module[extensionKey]);
                        $.extend(true, module[extensionKey], extendedComponent);
                    } else {
                        module[extensionKey] = extensionComponent;
                    }
                });

                return factoryInterface;
            },

            // Get the DOM components as described by the internal.components map
            // and cache the jQuery objects in the module's elements object.
            getComponents: function () {
                if (!module || !module.internal.components) {
                    return;
                }

                $.each(module.internal.components, function (key, component) {
                    var $component;

                    $component = fn.getDomEl(component);

                    if ($component.length) {
                        module.elements[key] = $component;

                        if (component.constructor) {
                            $component.each(function (i, compEl) {
                                var $e, moduleOpts;

                                $e = $(compEl);

                                if (!$e.hasClass(markup.INITED)) {
                                    moduleOpts = $.extend({
                                        $e: $e
                                    }, component.moduleOptions);

                                    new component.constructor(moduleOpts);
                                }
                            });
                        }
                    }
                });
            },

            // For modules that rely on html templates, get the template elements
            // from the dom, grab their HTML and cache them as jQuery objects
            // to the supplied templates object.
            getTemplates: function () {
                if (!module.internal.templates) {
                    return;
                }

                $.each(module.internal.templates, function (key, template) {
                    var $templateWrapper, $template;

                    $templateWrapper = fn.getDomEl(template);

                    if ($templateWrapper.first().data('type') === 'handlebars') {
                        $template = handlebars.compile($templateWrapper.first().html());
                    } else {
                        $template = $();

                        $templateWrapper.each(function (i, templateWrapper) {
                            $template = $template.add($(templateWrapper).html());
                        });
                    }

                    if (
                        typeof $template === 'function' ||
                        $template.length
                    ) {
                        module.templates[key] = $template;
                    }
                });
            },

            // A DOM parsing method to get a required DOM element based on the
            // supplied component
            getDomEl: function (component) {
                var domMethod, selector, selectorParts, subSelectors, $el,
                    $componentsRoot;

                domMethod = 'find';
                selector = component.selector;
                $componentsRoot = module.internal.$componentsRoot || module.internal.$e;

                if (selector.indexOf('!') === 0) {
                    selector = selector.replace('!', '');
                    $el = $(selector);
                } else {
                    if (selector.indexOf('^') === 0) {
                        selector = selector.replace('^', '');
                        domMethod = 'closest';
                        selectorParts = selector.split(' ');
                        selector = selectorParts[0];
                        subSelectors = selectorParts.slice(1);
                    }

                    $el = $componentsRoot[domMethod](selector);

                    if (subSelectors && subSelectors.length) {
                        $el = $el.find(subSelectors.join(' '));
                    }
                }

                if (component.ignoreNested) {
                    $el = fn.removeNestedComponents($el, selector);
                }

                if (component.directChildrenOnly) {
                    $el = fn.reduceToDirectChildren($el, module.o.selector);
                }

                return $el;
            },

            // If a component is required to not have any nested elements based
            // on the componentSelector, this method will removed any nested
            // elements from the jQuery object.
            removeNestedComponents: function ($component, componentSelector) {
                var nestedChildren, filteredComponent;

                nestedChildren = [];
                filteredComponent = [];

                $component.each(function (i, componentEl) {

                    if (nestedChildren.indexOf(componentEl) < 0) {
                        filteredComponent.push(componentEl);

                        $(componentEl).find(componentSelector).each(function (i, el) {
                            var filteredChildIndex = filteredComponent.indexOf(el);

                            if (filteredChildIndex > -1) {
                                filteredComponent.splice(filteredChildIndex, i);
                            } else {
                                nestedChildren.push(el);
                            }
                        });

                        $.each(filteredComponent, function (i, filteredComponentEl) {
                            if (nestedChildren.indexOf(filteredComponentEl) > -1) {
                                filteredComponent.splice(i, 1);
                            }
                        });
                    }
                });

                return $(filteredComponent);
            },

            reduceToDirectChildren: function ($component, parentSelector) {
                var filteredChildren;

                filteredChildren = [];

                $component.each(function (i, componentEl) {
                    var $closestParent;

                    $closestParent = $(componentEl).closest(parentSelector);

                    if ($closestParent[0] === module.internal.$e[0]) {
                        filteredChildren.push(componentEl);
                    }
                });

                return $(filteredChildren);
            },

            // Parse the classes applied to the root element of the module and
            // map the variants to the internal.isVariant object. Variants are
            // interpreted from everything after the variant- prefix, and are
            // camelCased and normalized from any multi-word-names to multiWordNames.
            getModuleVariants: function () {
                var moduleClasses, moduleVariants;

                if (!module.internal.$e.length) {
                    return;
                }

                moduleClasses = module.internal.$e[0].className;
                moduleVariants = moduleClasses.match(/variant-([^\s]+)/g);

                module.internal.isVariant = module.internal.isVariant || {};

                if (moduleVariants) {
                    moduleVariants.forEach(function (variant) {
                        variant = variant.replace(/variant-/, '');
                        variant = stringUtil.camelCaseify(variant);
                        module.internal.isVariant[variant] = true;
                    });
                }
            },

            // The event binding will iterate over the internal.events map and
            // extract the event type, component to delegate to, and any other sub
            // selectors given, and bind them to the named handler.
            // Example:
            // 'click @componentName .child-selector' : 'handlerName'
            bindEvents: function () {
                if (module.internal.events) {
                    $.each(module.internal.events, function (eventStr, handlerName) {
                        fn.bindEvent(eventStr, handlerName);
                    });
                }

                // If any other instance that share this internal.$e are destroy
                // they will remove the internal.$e, so other instances on the same
                // element need to be destroyed as well.
                module.internal.$e.on('modremove.' + module.internal.name, function (evnt, el) {
                    if (el === module.internal.$e[0]) {
                        fn.destroy();
                        fn.removeEl();
                    }
                });
            },


            // Bind a single event
            bindEvent: function (eventStr, handlerName) {
                var eventStrParts, eventType, eventSelectors, componentKey,
                    eventHandler, $elem, elementKey;

                eventStrParts = eventStr.split(' ');
                eventType = eventStrParts.shift();
                eventSelectors = eventStrParts.slice(0);
                eventHandler = module.handlers[handlerName];
                $elem = module.internal.$componentsRoot || module.internal.$e;

                if (eventSelectors.length) {
                    if (eventSelectors[0].indexOf('@') === 0) {
                        componentKey = eventSelectors[0].replace('@', '');

                        if (!module.internal.components[componentKey]) {
                            return;
                        }

                        eventSelectors[0] = module.internal.components[componentKey].selector;
                    } else if (eventSelectors[0].indexOf('!') === 0) {
                        elementKey = eventSelectors.shift().replace('!', '');
                        if (elementKey === 'window') {
                            $elem = $(window);
                        } else {
                            $elem = module.elements[elementKey];
                        }
                    }
                }

                if (!$elem) {
                    return;
                }

                if (eventType.indexOf('.') < 0) {
                    eventType = eventType + '.' + module.internal.name;
                }

                if (!$.isFunction(eventHandler)) {
                    throw '[moduleFactory] : Event handler is with name ' + handlerName + ' undefined. Module:' + module.internal.name;
                }

                if (eventSelectors.length) {
                    $elem.off(eventType, eventSelectors.join(' '), eventHandler);
                    $elem.on(eventType, eventSelectors.join(' '), eventHandler);
                } else {
                    $elem.off(eventType, eventHandler);
                    $elem.on(eventType, eventHandler);
                }
            },

            // Essentially the opposite of the bindEvents method above.
            unbindEvents: function () {
                if (!module.internal.events) {
                    return;
                }

                $.each(module.internal.events, function (eventStr, handlerName) {
                    var eventStrParts, eventType, eventSelectors, componentKey,
                        eventHandler, $elem, elementKey;

                    eventStrParts = eventStr.split(' ');
                    eventType = eventStrParts.shift();
                    eventSelectors = eventStrParts.slice(0);
                    eventHandler = module.handlers[handlerName];
                    $elem = module.internal.$componentsRoot || module.internal.$e;

                    if (eventSelectors.length) {
                        if (eventSelectors[0].indexOf('@') === 0) {
                            componentKey = eventSelectors[0].replace('@', '');

                            if (!module.internal.components[componentKey]) {
                                return;
                            }

                            eventSelectors[0] = module.internal.components[componentKey].selector;
                        } else if (eventSelectors[0].indexOf('!') === 0) {
                            elementKey = eventSelectors.shift().replace('!', '');
                            if (elementKey === 'window') {
                                $elem = $(window);
                            } else {
                                $elem = module.elements[elementKey];
                            }
                        }
                    }

                    if (!$elem) {
                        return;
                    }

                    if (eventType.indexOf('.') < 0) {
                        eventType = eventType + '.' + module.internal.name;
                    }

                    if (!$.isFunction(eventHandler)) {
                        throw '[moduleFactory] : Event handler is with name ' + handlerName + ' undefined. Module:' + module.internal.name;
                    }

                    if (eventSelectors.length) {
                        $elem.off(eventType, eventSelectors.join(' '), eventHandler);
                    } else {
                        $elem.off(eventType, eventHandler);
                    }
                });

                module.internal.$e.off('modremove.' + module.internal.name);
            },

            reBindEvents: function () {
                fn.unbindEvents();
                fn.bindEvents();
            },

            // Extend the `self` of a module with the api it exposed + the init
            // and destroy methods from this factory
            extendModuleWithApi: function () {
                $.extend(module.self, api);

                module.self.init = fn.init;
                module.self.destroy = fn.destroy;
                module.self.removeEl = fn.removeEl;
                module.self.removeChildren = fn.removeChildren;

                if (module.api) {
                    $.extend(module.self, module.api);
                }
            },

            // Get the root $el for the module
            getEl: function () {
                return module ? module.internal.$e : $();
            },

            // A teardown method for destroying modules
            destroy: function (options) {
                var instanceKey, $rootEl;

                options = options || {};

                if (
                    !module ||
                    module.destroyed ||
                    module.removed
                ) {
                    return;
                }

                $rootEl = module.internal.$componentsRoot || module.internal.$e;

                if (options.removeChildren) {
                    fn.removeChildren();
                }

                module.destroyed = true;
                instanceKey = stringUtil.decapitalize(module.internal.name) + 'Instance';

                if (typeof module.fn.beforeDestroy === 'function') {
                    module.fn.beforeDestroy();
                }

                fn.unbindEvents();

                $rootEl.trigger('destroy', module);
                $rootEl.data(instanceKey, null);
                $rootEl.data(module.internal.name + 'Inited', false);

                if (typeof module.fn.destroy === 'function') {
                    module.fn.destroy();
                }
            },

            removeEl: function () {
                if (
                    !module ||
                    module.removed ||
                    module.internal.$e[0].isRemoving
                ) {
                    return;
                }

                if (!module.destroyed) {
                    fn.destroy();
                }

                module.internal.$e[0].isRemoving = true;
                module.removed = true;

                fn.removeChildren();

                module.internal.$e.trigger('moderemove', module.internal.$e[0]);
                module.internal.$e.remove();

                module = null;
            },

            removeChildren: function () {
                var $rootEl;
                $rootEl = module.internal.$componentsRoot || module.internal.$e;
                $rootEl.find('.' + markup.INITED).each(function (i, el) {
                    var $el = $(el);

                    if (
                        !el.isRemoving
                    ) {
                        $el.trigger('modremove', el);
                    }

                    el.isRemoving = true;
                });
            },

            // Set the m.INITED class state + a data state
            applyInitedState: function () {
                module.internal.$e.data(module.internal.name + 'Inited', true);
                module.internal.$e.addClass(markup.INITED);
            }
        };

        markup = {};
        statesUtil.extend(markup);

        api = {
            getEl: fn.getEl,
            getComponents: fn.getComponents,
            isInited: fn.isInited,
            reBindEvents: fn.reBindEvents,
            destroy: fn.destroy
        };

        // A thin interface to allow for creating and extending the module
        factoryInterface = {
            create: fn.setup,
            extend: fn.extend
        };

        return factoryInterface;
    };


    return moduleFactory;
});

var jss = function () { function e(e) { for (var t = e.cssRules || e.rules || [], r = {}, n = 0; n < t.length; n++) { var s = u(t[n].selectorText); r[s] || (r[s] = []), r[s].push({ sheet: e, index: n, style: t[n].style }) } return r } function t(e, t) { var r = e.cssRules || e.rules || [], n = []; t = t.toLowerCase(); for (var s = 0; s < r.length; s++) { var u = r[s].selectorText; !u || u != t && u != f(t) && u != c(t) || n.push({ sheet: e, index: s, style: r[s].style }) } return n } function r(e, t) { var r = e.cssRules || e.rules || [], u = r.length, i = s(e, t, r, u); return i || n(e, t, u), { sheet: e, index: u, style: r[u].style } } function n(e, t, r) { e.insertRule ? e.insertRule(t + " { }", r) : e.addRule(t, null, r) } function s(e, t, r, s) { var o, h; if (x.exec(t)) o = t, h = i(t); else { if (!S.exec(t)) return !1; o = u(t), h = t } return p || (n(e, o, s), r.length <= s && (p = !0)), p && n(e, h, s), !0 } function u(e) { return e.replace(S, function (e, t, r, n) { return t + "::" + n }) } function i(e) { return e.replace(x, function (e, t, r) { return ":" + r }) } function o(e) { var t = e.sheet; t.deleteRule ? t.deleteRule(e.index) : t.removeRule && t.removeRule(e.index) } function h(e, t) { for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]); return e } function l(e) { for (var t = {}, r = 0; r < e.length; r++)h(t, a(e[r].style)); return t } function a(e) { for (var t = {}, r = 0; r < e.length; r++)t[e[r]] = e[v(e[r])]; return t } function f(e) { for (var t = "", r = 0; null != (match = y.exec(e)) && "" !== match[0];)t += e.substring(r, match.index), t += e.substr(match.index + match[1].length, match[2].length), t += e.substr(match.index, match[1].length), r = match.index + match[0].length; return t += e.substr(r) } function c(e) { return x.exec(e) ? i(e) : e } function d(e, t) { for (var r in t) { var n = t[r], s = n.indexOf(" !important"); e.style.removeProperty(r), s > 0 ? e.style.setProperty(r, n.substr(0, s), "important") : e.style.setProperty(r, n) } } function v(e) { return e.replace(/-([a-z])/g, function (e, t) { return t.toUpperCase() }) } function m(e) { var t = {}; for (var r in e) t[g(r)] = e[r]; return t } function g(e) { return e.replace(/([A-Z])/g, function (e, t) { return "-" + t.toLowerCase() }) } var p, y = /((?:\.|#)[^\.\s#]+)((?:\.|#)[^\.\s#]+)/g, x = /(::)(before|after|first-line|first-letter|selection)/, S = /([^:])(:)(before|after|first-line|first-letter|selection)/, R = function (e) { this.doc = e, this.head = this.doc.head || this.doc.getElementsByTagName("head")[0], this.sheets = this.doc.styleSheets || [] }; R.prototype = { get: function (r) { if (!this.defaultSheet) return {}; if (r) return l(t(this.defaultSheet, r)); var n = e(this.defaultSheet); for (r in n) n[r] = l(n[r]); return n }, getAll: function (e) { for (var r = {}, n = 0; n < this.sheets.length; n++)h(r, l(t(this.sheets[n], e))); return r }, set: function (e, n) { this.defaultSheet || (this.defaultSheet = this._createSheet()), n = m(n); var s = t(this.defaultSheet, e); s.length || (s = [r(this.defaultSheet, e)]); for (var u = 0; u < s.length; u++)d(s[u], n) }, remove: function (e) { if (this.defaultSheet) { if (!e) return this._removeSheet(this.defaultSheet), void delete this.defaultSheet; for (var r = t(this.defaultSheet, e), n = 0; n < r.length; n++)o(r[n]); return r.length } }, _createSheet: function () { var e = this.doc.createElement("style"); return e.type = "text/css", e.rel = "stylesheet", this.head.appendChild(e), e.sheet }, _removeSheet: function (e) { var t = e.ownerNode; t.parentNode.removeChild(t) } }; var b = new R(document); return b.forDocument = function (e) { return new R(e) }, b }(); "undefined" != typeof module && module.exports && (module.exports = jss);
define("jss", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.jss;
    };
}(this)));

define('utils/arrayUtil', [], function () {
    'use strict';

    var arrayUtil = {};

    arrayUtil.shuffle = function (array) {
        var initialArray = array.slice(0),
            isIdentical = true;

        array.sort(function () {
            return 0.5 - Math.random();
        });

        array.forEach(function (item, i) {
            if (item !== initialArray[i]) {
                isIdentical = false;
            }
        });

        if (isIdentical) {
            arrayUtil.shuffle(array);
        }
    };

    arrayUtil.contains = function (val) {
        return this.indexOf(val) >= 0;
    };

    arrayUtil.excludes = function (val) {
        return this.indexOf(val) < 0;
    };

    arrayUtil.union = function (arr1, arr2) {
        var union = arr1;
        $.each(arr2, function (idx, val) {
            if (union.indexOf(val) < 0) {
                union.push(val);
            }
        });
        return union;
    };

    return arrayUtil;
});

/*!
 * Copyright 2012, Chris Wanstrath
 * Released under the mit License
 * https://github.com/defunkt/jquery-pjax
 */

(function ($) {

    // When called on a container with a selector, fetches the href with
    // ajax into the container or with the data-pjax attribute on the link
    // itself.
    //
    // Tries to make sure the back button and ctrl+click work the way
    // you'd expect.
    //
    // Exported as $.fn.pjax
    //
    // Accepts a jQuery ajax options object that may include these
    // pjax specific options:
    //
    //
    // container - String selector for the element where to place the response body.
    //      push - Whether to pushState the URL. Defaults to true (of course).
    //   replace - Want to use replaceState instead? That's cool.
    //
    // For convenience the second parameter can be either the container or
    // the options object.
    //
    // Returns the jQuery object
    function fnPjax(selector, container, options) {
        options = optionsFor(container, options)
        return this.on('click.pjax', selector, function (event) {
            var opts = options
            if (!opts.container) {
                opts = $.extend({}, options)
                opts.container = $(this).attr('data-pjax')
            }
            handleClick(event, opts)
        })
    }

    // Public: pjax on click handler
    //
    // Exported as $.pjax.click.
    //
    // event   - "click" jQuery.Event
    // options - pjax options
    //
    // Examples
    //
    //   $(document).on('click', 'a', $.pjax.click)
    //   // is the same as
    //   $(document).pjax('a')
    //
    // Returns nothing.
    function handleClick(event, container, options) {
        options = optionsFor(container, options)

        var link = event.currentTarget
        var $link = $(link)

        if (link.tagName.toUpperCase() !== 'A')
            throw "$.fn.pjax or $.pjax.click requires an anchor element"

        // Middle click, cmd click, and ctrl click should open
        // links in a new tab as normal.
        if (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey)
            return

        // Ignore cross origin links
        if (location.protocol !== link.protocol || location.hostname !== link.hostname)
            return

        // Ignore case when a hash is being tacked on the current URL
        if (link.href.indexOf('#') > -1 && stripHash(link) == stripHash(location))
            return

        // Ignore event with default prevented
        if (event.isDefaultPrevented())
            return

        var defaults = {
            url: link.href,
            container: $link.attr('data-pjax'),
            target: link
        }

        var opts = $.extend({}, defaults, options)
        var clickEvent = $.Event('pjax:click')
        $link.trigger(clickEvent, [opts])

        if (!clickEvent.isDefaultPrevented()) {
            pjax(opts)
            event.preventDefault()
            $link.trigger('pjax:clicked', [opts])
        }
    }

    // Public: pjax on form submit handler
    //
    // Exported as $.pjax.submit
    //
    // event   - "click" jQuery.Event
    // options - pjax options
    //
    // Examples
    //
    //  $(document).on('submit', 'form', function(event) {
    //    $.pjax.submit(event, '[data-pjax-container]')
    //  })
    //
    // Returns nothing.
    function handleSubmit(event, container, options) {
        options = optionsFor(container, options)

        var form = event.currentTarget
        var $form = $(form)

        if (form.tagName.toUpperCase() !== 'FORM')
            throw "$.pjax.submit requires a form element"

        var defaults = {
            type: ($form.attr('method') || 'GET').toUpperCase(),
            url: $form.attr('action'),
            container: $form.attr('data-pjax'),
            target: form
        }

        if (defaults.type !== 'GET' && window.FormData !== undefined) {
            defaults.data = new FormData(form)
            defaults.processData = false
            defaults.contentType = false
        } else {
            // Can't handle file uploads, exit
            if ($form.find(':file').length) {
                return
            }

            // Fallback to manually serializing the fields
            defaults.data = $form.serializeArray()
        }

        pjax($.extend({}, defaults, options))

        event.preventDefault()
    }

    // Loads a URL with ajax, puts the response body inside a container,
    // then pushState()'s the loaded URL.
    //
    // Works just like $.ajax in that it accepts a jQuery ajax
    // settings object (with keys like url, type, data, etc).
    //
    // Accepts these extra keys:
    //
    // container - String selector for where to stick the response body.
    //      push - Whether to pushState the URL. Defaults to true (of course).
    //   replace - Want to use replaceState instead? That's cool.
    //
    // Use it just like $.ajax:
    //
    //   var xhr = $.pjax({ url: this.href, container: '#main' })
    //   console.log( xhr.readyState )
    //
    // Returns whatever $.ajax returns.
    function pjax(options) {
        options = $.extend(true, {}, $.ajaxSettings, pjax.defaults, options)

        if ($.isFunction(options.url)) {
            options.url = options.url()
        }

        var hash = parseURL(options.url).hash

        var containerType = $.type(options.container)
        if (containerType !== 'string') {
            throw "expected string value for 'container' option; got " + containerType
        }
        var context = options.context = $(options.container)
        if (!context.length) {
            throw "the container selector '" + options.container + "' did not match anything"
        }

        // We want the browser to maintain two separate internal caches: one
        // for pjax'd partial page loads and one for normal page loads.
        // Without adding this secret parameter, some browsers will often
        // confuse the two.
        if (!options.data) options.data = {}
        if ($.isArray(options.data)) {
            options.data.push({ name: '_pjax', value: options.container })
        } else {
            options.data._pjax = options.container
        }

        function fire(type, args, props) {
            if (!props) props = {}
            props.relatedTarget = options.target
            var event = $.Event(type, props)
            context.trigger(event, args)
            return !event.isDefaultPrevented()
        }

        var timeoutTimer

        options.beforeSend = function (xhr, settings) {
            // No timeout for non-GET requests
            // Its not safe to request the resource again with a fallback method.
            if (settings.type !== 'GET') {
                settings.timeout = 0
            }

            xhr.setRequestHeader('X-PJAX', 'true')
            xhr.setRequestHeader('X-PJAX-Container', options.container)

            if (!fire('pjax:beforeSend', [xhr, settings]))
                return false

            if (settings.timeout > 0) {
                timeoutTimer = setTimeout(function () {
                    if (fire('pjax:timeout', [xhr, options]))
                        xhr.abort('timeout')
                }, settings.timeout)

                // Clear timeout setting so jquerys internal timeout isn't invoked
                settings.timeout = 0
            }

            var url = parseURL(settings.url)
            if (hash) url.hash = hash
            options.requestUrl = stripInternalParams(url)
        }

        options.complete = function (xhr, textStatus) {
            if (timeoutTimer)
                clearTimeout(timeoutTimer)

            fire('pjax:complete', [xhr, textStatus, options])

            fire('pjax:end', [xhr, options])
        }

        options.error = function (xhr, textStatus, errorThrown) {
            var container = extractContainer("", xhr, options)

            var allowed = fire('pjax:error', [xhr, textStatus, errorThrown, options])
            if (options.type == 'GET' && textStatus !== 'abort' && allowed) {
                locationReplace(container.url)
            }
        }

        options.success = function (data, status, xhr) {
            var previousState = pjax.state

            // If $.pjax.defaults.version is a function, invoke it first.
            // Otherwise it can be a static string.
            var currentVersion = typeof $.pjax.defaults.version === 'function' ?
                $.pjax.defaults.version() :
                $.pjax.defaults.version

            var latestVersion = xhr.getResponseHeader('X-PJAX-Version')

            var container = extractContainer(data, xhr, options)

            var url = parseURL(container.url)
            if (hash) {
                url.hash = hash
                container.url = url.href
            }

            // If there is a layout version mismatch, hard load the new url
            if (currentVersion && latestVersion && currentVersion !== latestVersion) {
                locationReplace(container.url)
                return
            }

            // If the new response is missing a body, hard load the page
            if (!container.contents) {
                locationReplace(container.url)
                return
            }

            pjax.state = {
                id: options.id || uniqueId(),
                url: container.url,
                title: container.title,
                container: options.container,
                fragment: options.fragment,
                timeout: options.timeout
            }

            if (options.push || options.replace) {
                window.history.replaceState(pjax.state, container.title, container.url)
            }

            // Only blur the focus if the focused element is within the container.
            var blurFocus = $.contains(context, document.activeElement)

            // Clear out any focused controls before inserting new page contents.
            if (blurFocus) {
                try {
                    document.activeElement.blur()
                } catch (e) { /* ignore */ }
            }

            if (container.title) document.title = container.title

            if (options.append) {
                context.append(container.contents)
            } else {
                fire('pjax:beforeReplace', [container.contents, options], {
                    state: pjax.state,
                    previousState: previousState
                })
                context.html(container.contents)
            }

            // FF bug: Won't autofocus fields that are inserted via JS.
            // This behavior is incorrect. So if theres no current focus, autofocus
            // the last field.
            //
            // http://www.w3.org/html/wg/drafts/html/master/forms.html
            var autofocusEl = context.find('input[autofocus], textarea[autofocus]').last()[0]
            if (autofocusEl && document.activeElement !== autofocusEl) {
                autofocusEl.focus();
            }

            executeScriptTags(container.scripts)

            var scrollTo = options.scrollTo

            // Ensure browser scrolls to the element referenced by the URL anchor
            if (hash) {
                var name = decodeURIComponent(hash.slice(1))
                var target = document.getElementById(name) || document.getElementsByName(name)[0]
                if (target) scrollTo = $(target).offset().top
            }

            if (typeof scrollTo == 'number') {
                if (options.scrollTarget) {
                    options.scrollTarget.scrollTop(scrollTo)
                } else {
                    $(window).scrollTop(scrollTo)
                }
            }

            fire('pjax:success', [data, status, xhr, options])
        }


        // Initialize pjax.state for the initial page load. Assume we're
        // using the container and options of the link we're loading for the
        // back button to the initial page. This ensures good back button
        // behavior.
        if (!pjax.state) {
            pjax.state = {
                id: uniqueId(),
                url: window.location.href,
                title: document.title,
                container: options.container,
                fragment: options.fragment,
                timeout: options.timeout
            }
            window.history.replaceState(pjax.state, document.title)
        }

        // Cancel the current request if we're already pjaxing
        abortXHR(pjax.xhr)

        pjax.options = options
        var xhr = pjax.xhr = $.ajax(options)

        if (xhr.readyState > 0) {
            if (options.push && !options.replace) {
                // Cache current container element before replacing it
                cachePush(pjax.state.id, [options.container, cloneContents(context)])

                window.history.pushState(null, "", options.requestUrl)
            }

            fire('pjax:start', [xhr, options])
            fire('pjax:send', [xhr, options])
        }

        return pjax.xhr
    }

    // Public: Reload current page with pjax.
    //
    // Returns whatever $.pjax returns.
    function pjaxReload(container, options) {
        var defaults = {
            url: window.location.href,
            push: false,
            replace: true,
            scrollTo: false
        }

        return pjax($.extend(defaults, optionsFor(container, options)))
    }

    // Internal: Hard replace current state with url.
    //
    // Work for around WebKit
    //   https://bugs.webkit.org/show_bug.cgi?id=93506
    //
    // Returns nothing.
    function locationReplace(url) {
        window.history.replaceState(null, "", pjax.state.url)
        window.location.replace(url)
    }


    var initialPop = true
    var initialURL = window.location.href
    var initialState = window.history.state

    // Initialize $.pjax.state if possible
    // Happens when reloading a page and coming forward from a different
    // session history.
    if (initialState && initialState.container) {
        pjax.state = initialState
    }

    // Non-webkit browsers don't fire an initial popstate event
    if ('state' in window.history) {
        initialPop = false
    }

    // popstate handler takes care of the back and forward buttons
    //
    // You probably shouldn't use pjax on pages with other pushState
    // stuff yet.
    function onPjaxPopstate(event) {

        // Hitting back or forward should override any pending PJAX request.
        if (!initialPop) {
            abortXHR(pjax.xhr)
        }

        var previousState = pjax.state
        var state = event.state
        var direction

        if (state && state.container) {
            // When coming forward from a separate history session, will get an
            // initial pop with a state we are already at. Skip reloading the current
            // page.
            if (initialPop && initialURL == state.url) return

            if (previousState) {
                // If popping back to the same state, just skip.
                // Could be clicking back from hashchange rather than a pushState.
                if (previousState.id === state.id) return

                // Since state IDs always increase, we can deduce the navigation direction
                direction = previousState.id < state.id ? 'forward' : 'back'
            }

            var cache = cacheMapping[state.id] || []
            var containerSelector = cache[0] || state.container
            var container = $(containerSelector), contents = cache[1]

            if (container.length) {
                if (previousState) {
                    // Cache current container before replacement and inform the
                    // cache which direction the history shifted.
                    cachePop(direction, previousState.id, [containerSelector, cloneContents(container)])
                }

                var popstateEvent = $.Event('pjax:popstate', {
                    state: state,
                    direction: direction
                })
                container.trigger(popstateEvent)

                var options = {
                    id: state.id,
                    url: state.url,
                    container: containerSelector,
                    push: false,
                    fragment: state.fragment,
                    timeout: state.timeout,
                    scrollTo: false
                }

                if (contents) {
                    container.trigger('pjax:start', [null, options])

                    pjax.state = state
                    if (state.title) document.title = state.title
                    var beforeReplaceEvent = $.Event('pjax:beforeReplace', {
                        state: state,
                        previousState: previousState
                    })
                    container.trigger(beforeReplaceEvent, [contents, options])
                    container.html(contents)

                    container.trigger('pjax:end', [null, options])
                } else {
                    pjax(options)
                }

                // Force reflow/relayout before the browser tries to restore the
                // scroll position.
                container[0].offsetHeight // eslint-disable-line no-unused-expressions
            } else {
                locationReplace(location.href)
            }
        }
        initialPop = false
    }

    // Fallback version of main pjax function for browsers that don't
    // support pushState.
    //
    // Returns nothing since it retriggers a hard form submission.
    function fallbackPjax(options) {
        var url = $.isFunction(options.url) ? options.url() : options.url,
            method = options.type ? options.type.toUpperCase() : 'GET'

        var form = $('<form>', {
            method: method === 'GET' ? 'GET' : 'POST',
            action: url,
            style: 'display:none'
        })

        if (method !== 'GET' && method !== 'POST') {
            form.append($('<input>', {
                type: 'hidden',
                name: '_method',
                value: method.toLowerCase()
            }))
        }

        var data = options.data
        if (typeof data === 'string') {
            $.each(data.split('&'), function (index, value) {
                var pair = value.split('=')
                form.append($('<input>', { type: 'hidden', name: pair[0], value: pair[1] }))
            })
        } else if ($.isArray(data)) {
            $.each(data, function (index, value) {
                form.append($('<input>', { type: 'hidden', name: value.name, value: value.value }))
            })
        } else if (typeof data === 'object') {
            var key
            for (key in data)
                form.append($('<input>', { type: 'hidden', name: key, value: data[key] }))
        }

        $(document.body).append(form)
        form.submit()
    }

    // Internal: Abort an XmlHttpRequest if it hasn't been completed,
    // also removing its event handlers.
    function abortXHR(xhr) {
        if (xhr && xhr.readyState < 4) {
            xhr.onreadystatechange = $.noop
            xhr.abort()
        }
    }

    // Internal: Generate unique id for state object.
    //
    // Use a timestamp instead of a counter since ids should still be
    // unique across page loads.
    //
    // Returns Number.
    function uniqueId() {
        return (new Date).getTime()
    }

    function cloneContents(container) {
        var cloned = container.clone()
        // Unmark script tags as already being eval'd so they can get executed again
        // when restored from cache. HAXX: Uses jQuery internal method.
        cloned.find('script').each(function () {
            if (!this.src) $._data(this, 'globalEval', false)
        })
        return cloned.contents()
    }

    // Internal: Strip internal query params from parsed URL.
    //
    // Returns sanitized url.href String.
    function stripInternalParams(url) {
        url.search = url.search.replace(/([?&])(_pjax|_)=[^&]*/g, '').replace(/^&/, '')
        return url.href.replace(/\?($|#)/, '$1')
    }

    // Internal: Parse URL components and returns a Locationish object.
    //
    // url - String URL
    //
    // Returns HTMLAnchorElement that acts like Location.
    function parseURL(url) {
        var a = document.createElement('a')
        a.href = url
        return a
    }

    // Internal: Return the `href` component of given URL object with the hash
    // portion removed.
    //
    // location - Location or HTMLAnchorElement
    //
    // Returns String
    function stripHash(location) {
        return location.href.replace(/#.*/, '')
    }

    // Internal: Build options Object for arguments.
    //
    // For convenience the first parameter can be either the container or
    // the options object.
    //
    // Examples
    //
    //   optionsFor('#container')
    //   // => {container: '#container'}
    //
    //   optionsFor('#container', {push: true})
    //   // => {container: '#container', push: true}
    //
    //   optionsFor({container: '#container', push: true})
    //   // => {container: '#container', push: true}
    //
    // Returns options Object.
    function optionsFor(container, options) {
        if (container && options) {
            options = $.extend({}, options)
            options.container = container
            return options
        } else if ($.isPlainObject(container)) {
            return container
        } else {
            return { container: container }
        }
    }

    // Internal: Filter and find all elements matching the selector.
    //
    // Where $.fn.find only matches descendants, findAll will test all the
    // top level elements in the jQuery object as well.
    //
    // elems    - jQuery object of Elements
    // selector - String selector to match
    //
    // Returns a jQuery object.
    function findAll(elems, selector) {
        return elems.filter(selector).add(elems.find(selector))
    }

    function parseHTML(html) {
        return $.parseHTML(html, document, true)
    }

    // Internal: Extracts container and metadata from response.
    //
    // 1. Extracts X-PJAX-URL header if set
    // 2. Extracts inline <title> tags
    // 3. Builds response Element and extracts fragment if set
    //
    // data    - String response data
    // xhr     - XHR response
    // options - pjax options Object
    //
    // Returns an Object with url, title, and contents keys.
    function extractContainer(data, xhr, options) {
        var obj = {}, fullDocument = /<html/i.test(data)

        // Prefer X-PJAX-URL header if it was set, otherwise fallback to
        // using the original requested url.
        var serverUrl = xhr.getResponseHeader('X-PJAX-URL')
        obj.url = serverUrl ? stripInternalParams(parseURL(serverUrl)) : options.requestUrl

        var $head, $body
        // Attempt to parse response html into elements
        if (fullDocument) {
            $body = $(parseHTML(data.match(/<body[^>]*>([\s\S.]*)<\/body>/i)[0]))
            var head = data.match(/<head[^>]*>([\s\S.]*)<\/head>/i)
            $head = head != null ? $(parseHTML(head[0])) : $body
        } else {
            $head = $body = $(parseHTML(data))
        }

        // If response data is empty, return fast
        if ($body.length === 0)
            return obj

        // If there's a <title> tag in the header, use it as
        // the page's title.
        obj.title = findAll($head, 'title').last().text()

        if (options.fragment) {
            var $fragment = $body
            // If they specified a fragment, look for it in the response
            // and pull it out.
            if (options.fragment !== 'body') {
                $fragment = findAll($fragment, options.fragment).first()
            }

            if ($fragment.length) {
                obj.contents = options.fragment === 'body' ? $fragment : $fragment.contents()

                // If there's no title, look for data-title and title attributes
                // on the fragment
                if (!obj.title)
                    obj.title = $fragment.attr('title') || $fragment.data('title')
            }

        } else if (!fullDocument) {
            obj.contents = $body
        }

        // Clean up any <title> tags
        if (obj.contents) {
            // Remove any parent title elements
            obj.contents = obj.contents.not(function () { return $(this).is('title') })

            // Then scrub any titles from their descendants
            obj.contents.find('title').remove()

            // Gather all script[src] elements
            obj.scripts = findAll(obj.contents, 'script[src]').remove()
            obj.contents = obj.contents.not(obj.scripts)
        }

        // Trim any whitespace off the title
        if (obj.title) obj.title = $.trim(obj.title)

        return obj
    }

    // Load an execute scripts using standard script request.
    //
    // Avoids jQuery's traditional $.getScript which does a XHR request and
    // globalEval.
    //
    // scripts - jQuery object of script Elements
    //
    // Returns nothing.
    function executeScriptTags(scripts) {
        if (!scripts) return

        var existingScripts = $('script[src]')

        scripts.each(function () {
            var src = this.src
            var matchedScripts = existingScripts.filter(function () {
                return this.src === src
            })
            if (matchedScripts.length) return

            var script = document.createElement('script')
            var type = $(this).attr('type')
            if (type) script.type = type
            script.src = $(this).attr('src')
            document.head.appendChild(script)
        })
    }

    // Internal: History DOM caching class.
    var cacheMapping = {}
    var cacheForwardStack = []
    var cacheBackStack = []

    // Push previous state id and container contents into the history
    // cache. Should be called in conjunction with `pushState` to save the
    // previous container contents.
    //
    // id    - State ID Number
    // value - DOM Element to cache
    //
    // Returns nothing.
    function cachePush(id, value) {
        cacheMapping[id] = value
        cacheBackStack.push(id)

        // Remove all entries in forward history stack after pushing a new page.
        trimCacheStack(cacheForwardStack, 0)

        // Trim back history stack to max cache length.
        trimCacheStack(cacheBackStack, pjax.defaults.maxCacheLength)
    }

    // Shifts cache from directional history cache. Should be
    // called on `popstate` with the previous state id and container
    // contents.
    //
    // direction - "forward" or "back" String
    // id        - State ID Number
    // value     - DOM Element to cache
    //
    // Returns nothing.
    function cachePop(direction, id, value) {
        var pushStack, popStack
        cacheMapping[id] = value

        if (direction === 'forward') {
            pushStack = cacheBackStack
            popStack = cacheForwardStack
        } else {
            pushStack = cacheForwardStack
            popStack = cacheBackStack
        }

        pushStack.push(id)
        id = popStack.pop()
        if (id) delete cacheMapping[id]

        // Trim whichever stack we just pushed to to max cache length.
        trimCacheStack(pushStack, pjax.defaults.maxCacheLength)
    }

    // Trim a cache stack (either cacheBackStack or cacheForwardStack) to be no
    // longer than the specified length, deleting cached DOM elements as necessary.
    //
    // stack  - Array of state IDs
    // length - Maximum length to trim to
    //
    // Returns nothing.
    function trimCacheStack(stack, length) {
        while (stack.length > length)
            delete cacheMapping[stack.shift()]
    }

    // Public: Find version identifier for the initial page load.
    //
    // Returns String version or undefined.
    function findVersion() {
        return $('meta').filter(function () {
            var name = $(this).attr('http-equiv')
            return name && name.toUpperCase() === 'X-PJAX-VERSION'
        }).attr('content')
    }

    // Install pjax functions on $.pjax to enable pushState behavior.
    //
    // Does nothing if already enabled.
    //
    // Examples
    //
    //     $.pjax.enable()
    //
    // Returns nothing.
    function enable() {
        $.fn.pjax = fnPjax
        $.pjax = pjax
        $.pjax.enable = $.noop
        $.pjax.disable = disable
        $.pjax.click = handleClick
        $.pjax.submit = handleSubmit
        $.pjax.reload = pjaxReload
        $.pjax.defaults = {
            timeout: 650,
            push: true,
            replace: false,
            type: 'GET',
            dataType: 'html',
            scrollTo: 0,
            scrollTarget: null,
            maxCacheLength: 20,
            version: findVersion,

            append: false
        }
        $(window).on('popstate.pjax', onPjaxPopstate)
    }

    // Disable pushState behavior.
    //
    // This is the case when a browser doesn't support pushState. It is
    // sometimes useful to disable pushState for debugging on a modern
    // browser.
    //
    // Examples
    //
    //     $.pjax.disable()
    //
    // Returns nothing.
    function disable() {
        $.fn.pjax = function () { return this }
        $.pjax = fallbackPjax
        $.pjax.enable = enable
        $.pjax.disable = $.noop
        $.pjax.click = $.noop
        $.pjax.submit = $.noop
        $.pjax.reload = function () { window.location.reload() }

        $(window).off('popstate.pjax', onPjaxPopstate)
    }


    // Add the state property to jQuery's event object so we can use it in
    // $(window).bind('popstate')
    if ($.event.props && $.inArray('state', $.event.props) < 0) {
        $.event.props.push('state')
    } else if (!('state' in $.Event.prototype)) {
        $.event.addProp('state')
    }

    // Is pjax supported by this browser?
    $.support.pjax =
        window.history && window.history.pushState && window.history.replaceState &&
        // pushState isn't reliable on iOS until 5.
        !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/)

    if ($.support.pjax) {
        enable()
    } else {
        disable()
    }

})(jQuery)
    ;
define("pjax", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.jQuery.pjax;
    };
}(this)));

define('ui/Paginator', [
    'jquery',
    'pjax',
    'managers/eventManager'
], function (
    $,
    pjax,
    eventManager
) {
    'use strict';

    var Paginator = function (options) {
        var o, internal, fn, handlers;

        // NOTE: Paginator cannot accept a passed-in $e because the
        //       $.pjax.click call needs the selector string, not a jquery set.
        o = $.extend({
            selector: '[data-pjax-pagination]',
            previousSelector: '[data-pjax-pagination-previous]',
            nextSelector: '[data-pjax-pagination-next]',
            paginationContainer: '.pagination'
        }, options);

        internal = {
            name: 'Paginator',
            $e: $(o.selector)
        };

        fn = {
            init: function () {
                internal.$e.on('click', o.previousSelector, handlers.paginationButtonClick);
                internal.$e.on('click', o.nextSelector, handlers.paginationButtonClick);
                internal.$e.on('pjax:success', handlers.pjaxSuccess);
            },
            hideClickedButton: function (event) {
                $(event.currentTarget).closest(o.paginationContainer).remove();
            }
        };

        handlers = {
            paginationButtonClick: function (event) {
                $.pjax.click(event, {
                    container: o.selector,
                    fragment: o.selector,
                    scrollTo: false,
                    append: true,
                    timeout: 6000
                });
                fn.hideClickedButton(event);
            },
            pjaxSuccess: function () {
                eventManager.emit(Paginator.eventTypes.PAGE_ADDED, {
                    $e: internal.$e
                });
            }
        };

        fn.init();
    };

    Paginator.eventTypes = {
        PAGE_ADDED: 'paginatorPageAdded'
    };

    Paginator.onPageAdded = function (handler) {
        eventManager.addListener(Paginator.eventTypes.PAGE_ADDED, handler);
    };

    return Paginator;
});

define('ui/FeedPaginator', [
    'jquery',
    'managers/eventManager'
], function (
    $,
    eventManager
) {
    'use strict';

    var FeedPaginator = function (options) {
        var o, internal, fn, handlers;

        o = $.extend({
            $e: null,
            selector: '[data-feed-pagination]',
            pksSelector: '[data-extra-pks]',
            nextSelector: '[data-feed-pagination-next]',
            paginationContainer: '.pagination'
        }, options);

        internal = {
            name: 'FeedPaginator',
            $e: o.$e || $(o.selector),
            pagedPks: [],
            editable: false
        };

        fn = {
            init: function () {
                var dataObj = internal.$e.find(o.pksSelector);

                internal.$e.on('click', o.nextSelector, handlers.moreClick);

                internal.pagedPks = dataObj.data('extraPks');
                internal.editable = dataObj.data('editable');
                internal.listStyle = dataObj.data('listStyle');
            },
            insertFeedItems: function (data) {
                internal.$e.find(o.paginationContainer).before(data);
            },
            hideClickedButton: function () {
                $(o.nextSelector).remove();
            }
        };

        handlers = {
            moreClick: function () {
                /*$.get('/feed_items/', {
                    pks: internal.pagedPks.shift(),
                    listStyle: internal.listStyle,
                    editable: !!internal.editable
                }, handlers.nextPageSuccess);*/

            },
            nextPageSuccess: function (data) {
                fn.insertFeedItems(data);

                if (internal.pagedPks.length === 0) {
                    fn.hideClickedButton();
                }

                eventManager.emit(FeedPaginator.eventTypes.PAGE_ADDED, {
                    $e: internal.$e
                });
            }
        };

        fn.init();
    };

    FeedPaginator.eventTypes = {
        PAGE_ADDED: 'feedPaginatorPageAdded'
    };

    FeedPaginator.onPageAdded = function (handler) {
        eventManager.addListener(FeedPaginator.eventTypes.PAGE_ADDED, handler);
    };

    return FeedPaginator;
});

define('forms/widgets/DropMenu', [
    'jquery',
    'utils/globalElements',
    'factories/moduleFactory',
    'utils/keycodes'
], function (
    $,
    globalElements,
    moduleFactory,
    kc
) {
    'use strict';

    var openInstance = null;

    /*
        DropMenu
        ========

        A module to handle a drop menu and it's behaviour, such as:
        - Opening the menu
        - Closing the menu
        - Traversing it's child items using up & down keys
        - Selecting an item on click, space keypress, or enter keypress
        - Highlighting items on mouse over or up/down traversing
        - Calling any supplied callbacks with the selected element

        Example:
        var dropMenu = new DropMenu({
                $e: $(el),                                  // the top level wrapper into which the DropMenu is nested
                menuControl: '.drop-menu-control',          // (Optional) A selector for this component if different from default
                menuItemsWrapper: '.drop-menu-items-wrap',  // (Optional) A selector for this component if different from default
                menuItem: '.drop-menu-item',                // (Optional) A selector for this component if different from default
                onSelect: function ($item) {}               // (Optional) A callback for when an item is selected. Will get the $item as an argument
            });

        // Interface methods
        dropMenu.toggle();                              // Toggle the open/closed state of the DropMenu
        dropMenu.open();                                // Open the DropMenu
        dropMenu.close();                               // Close the DropMenu
        dropMenu.selectItemByEl($item);                 // Set the selected state on a child item by passing $item
        dropMenu.selectItemByVal('value');              // Set the selected state on a child item by passing a value
    */
    var DropMenu = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = DropMenu.markup;

        // Options
        o = $.extend({
            menuControl: '.drop-menu-control',
            menuItemsWrapper: '.drop-menu-items-wrap',
            menuItem: '.drop-menu-item',
            onSelect: function () { },
            viewportEdgePadding: 40, //px
            selfToggle: false,
            autocomplete: false
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'DropMenu',
            $e: o.$e || $(o.selector),

            closeDelay: 100, //ms
            closeTimeout: null,
            openAnimation: null,
            maxVisibleItems: 6.5,

            heights: {
                full: 0,
                max: 0
            },

            // Dict of components used by this module.
            components: {
                menuControl: {
                    selector: o.menuControl
                },
                menuItemsWrapper: {
                    selector: o.menuItemsWrapper
                },
                menuItem: {
                    selector: o.menuItem
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'keyup': 'keyup',
                'mouseenter': 'mouseenter',
                'mouseleave': 'mouseleave',
                'mousewheel @menuItemsWrapper': 'menuItemsWrapperMousewheel',
                'DOMMouseScroll @menuItemsWrapper': 'menuItemsWrapperMousewheel',
                'mouseenter @menuItem': 'menuItemMouseenter',
                'mouseleave @menuItem': 'menuItemMouseleave',
                'click @menuItem': 'menuItemClick',
                'click @menuControl': 'menuControlClick'
            },

            // Map of keyup handlers to delegate to based on event.which key code.
            keyHandlers: {
                [kc.UP]: 'upKeyup',
                [kc.DOWN]: 'downKeyup',
                [kc.SPACE]: 'spaceKeyup',
                [kc.ENTER]: 'enterKeyup',
                [kc.ESCAPE]: 'escapeKeyup',
            }
        };

        // Elements cache
        elements = {
            allOptions: null
        };

        // Primary methods
        fn = {
            // Initialize the DropMenu instance and cache the dimensions of its components
            // then close the menu and mark it as ready.
            init: function () {
                fn.setup();
            },
            destroy: function () {
                fn.clearOpenAnimation();

                // ensure that window event handlers are unbound during teardown
                fn.closeMenu({
                    force: true
                });
            },

            setup: function () {
                fn.setHeight();
                fn.closeMenu();
                fn.cacheOptions();
                fn.setReady();
            },

            reset: function () {
                fn.clearOpenAnimation();
                fn.unsetReady();
                fn.unsetHeight();
                fn.unsetMaxHeight();
                fn.setup();
            },

            update: function () {
                fn.getComponents();
                fn.setHeight();
                fn.setScrollState();
            },

            cacheOptions: function () {
                if (elements.menuItem) {
                    elements.allOptions = elements.menuItem.clone();
                }
            },

            // Check if the menu has the open state class applied
            isOpen: function () {
                return internal.$e.hasClass(m.OPEN);
            },

            isActive: function () {
                return internal.$e.hasClass(m.ACTIVE);
            },

            setOpen: function () {
                internal.$e.addClass(m.OPEN);
            },

            unsetOpen: function () {
                internal.$e.removeClass(m.OPEN);
            },

            setOpenAnimation: function (callback) {
                internal.openAnimation = requestAnimationFrame(callback);
            },

            clearOpenAnimation: function () {
                if (internal.openAnimation) {
                    cancelAnimationFrame(internal.openAnimation);
                    internal.openAnimation = null;
                }
            },

            setInvisible: function () {
                elements.menuItemsWrapper.addClass(m.INVISIBLE);
            },

            unsetInvisible: function () {
                elements.menuItemsWrapper.removeClass(m.INVISIBLE);
            },

            setReady: function () {
                internal.$e.addClass(m.READY);
            },

            unsetReady: function () {
                internal.$e.removeClass(m.READY);
            },

            setGlobalOpen: function () {
                globalElements.body.addClass(m.GLOBAL_OPEN);

                if (elements.menuItemsWrapper.hasClass(m.ABOVE)) {
                    globalElements.body.addClass(m.ABOVE);
                }
            },

            unsetGlobalOpen: function () {
                globalElements.body.removeClass(m.GLOBAL_OPEN);
                globalElements.body.removeClass(m.ABOVE);
            },

            bindWindowScroll: function () {
                globalElements.win.on('scroll.DropMenu', function () {
                    fn.determineWrapperPosition();
                });
            },

            unbindWindowScroll: function () {
                globalElements.win.off('scroll.DropMenu');
            },

            bindWindowClick: function () {
                globalElements.win.on('click.DropMenu', function () {
                    fn.closeMenu();
                });
            },

            unbindWindowClick: function () {
                globalElements.win.off('click.DropMenu');
            },

            setOpenInstance: function () {
                if (openInstance) {
                    openInstance.close();
                }
                openInstance = self;
            },

            unsetOpenInstance: function () {
                if (openInstance === self) {
                    openInstance = null;
                }
            },

            setCloseDelay: function (options, closeCallback) {
                var delay;
                options = options || {};
                delay = options.delay ? internal.closeDelay : 0;
                internal.closeTimeout = setTimeout(
                    closeCallback,
                    delay
                );
            },

            clearCloseDelay: function () {
                if (internal.closeTimeout) {
                    clearTimeout(internal.closeTimeout);
                    internal.closeTimeout = null;
                }
            },

            setHeight: function () {
                var wrapperBounds;
                if (fn.isOpen()) {
                    fn.getComponentDimensions();
                    wrapperBounds = internal.components.menuItemsWrapper.bounds;
                    elements.menuItemsWrapper.height(wrapperBounds.height);
                    internal.heights.full = wrapperBounds.height;
                    fn.setMaxHeight();
                } else {
                    fn.unsetMaxHeight();
                    elements.menuItemsWrapper.css('height', 0);
                }
            },

            setMaxHeight: function () {
                var itemBounds, maxHeight;
                itemBounds = internal.components.menuItem.bounds;
                maxHeight = elements.menuItem && elements.menuItem.length > 7 ?
                    internal.maxVisibleItems * itemBounds.height :
                    null;

                internal.heights.max = maxHeight;
                elements.menuItemsWrapper.css({
                    'max-height': maxHeight
                });
            },

            unsetHeight: function () {
                elements.menuItemsWrapper.css('height', 'auto');
            },

            unsetMaxHeight: function () {
                elements.menuItemsWrapper.css({
                    'max-height': ''
                });
            },

            setScrollState: function () {
                internal.$e.toggleClass(m.SCROLLMENU, !!internal.heights.max && internal.heights.full > internal.heights.max);
            },

            unsetScrollState: function () {
                internal.$e.removeClass(m.SCROLLMENU);
            },

            // Cache the component bounds to be used when opening the menu
            getComponentDimensions: function () {
                fn.setInvisible();
                fn.unsetHeight();
                fn.unsetMaxHeight();

                $.each(internal.components, function (key, component) {
                    var archetypeEl, visibleElements;

                    visibleElements = elements[key];
                    visibleElements = visibleElements && visibleElements.filter ? visibleElements.filter(':visible') : [];

                    if (!visibleElements.length) {
                        return;
                    }

                    archetypeEl = visibleElements.length > 1 && !$(visibleElements[1]).hasClass('drop-menu-items-wrap') ? visibleElements[1] : visibleElements[0];
                    component.bounds = archetypeEl.getBoundingClientRect();

                });

                fn.unsetInvisible();
            },

            // Open the menu by setting its height to its cached open height
            openMenu: function () {
                if (fn.isOpen()) {
                    return;
                }
                fn.clearOpenAnimation();

                fn.setOpenInstance();
                fn.clearCloseDelay();
                fn.getComponentDimensions();
                fn.determineWrapperPosition();
                fn.setGlobalOpen();
                fn.bindWindowScroll();
                fn.bindWindowClick();
                fn.unsetScrollState();

                fn.setOpenAnimation(function () {
                    fn.setOpen();
                    fn.setHeight();
                    fn.setScrollState();
                });
            },

            // Close the menu by settings its height to 0
            closeMenu: function (options) {
                options = options || {};
                if (!fn.isActive() || options.force) {
                    fn.clearCloseDelay();
                    fn.setCloseDelay(options, function () {
                        fn.unbindWindowScroll();
                        fn.unbindWindowClick();
                        fn.unsetGlobalOpen();
                        fn.unsetOpenInstance();
                        fn.unsetOpen();
                        fn.setHeight();
                        fn.resetItemHighlightStates();
                        fn.resetItemSelectedStates();
                        fn.unsetScrollState();
                    });
                }
            },

            // Toggle between the open/close methods based on whether the menu is
            // already open or not.
            toggleMenu: function (options) {
                options = options || {};
                if (fn.isOpen()) {
                    fn.closeMenu(options);
                } else {
                    fn.openMenu(options);
                }
            },

            // When opening the menu first check to see if there is enough space
            // underneath its control. If not, open the drawer above the control.
            determineWrapperPosition: function () {
                var cachedWrapperBounds,
                    currentControlBounds, availableHeightAbove,
                    availableHeightBelow, isAbove, maxHeight;

                // NB: Leaving, but skipping, this block in incase we want to
                // position the dropMenu above or below the input field depending
                // on available space - Fred
                var skip = true;
                if (skip) {
                    return;
                }

                cachedWrapperBounds = internal.components.menuItemsWrapper.bounds;
                currentControlBounds = elements.menuControl[0].getBoundingClientRect();
                availableHeightAbove = currentControlBounds.top - o.viewportEdgePadding;
                availableHeightBelow = window.innerHeight - (currentControlBounds.top + currentControlBounds.height) - o.viewportEdgePadding;
                isAbove = false;

                elements.menuItemsWrapper.css({
                    'max-height': ''
                }).hide().show(0);
                internal.$e.removeClass(m.SCROLLMENU);

                if (
                    cachedWrapperBounds.height > availableHeightAbove &&
                    cachedWrapperBounds.height > availableHeightBelow
                ) {
                    if (availableHeightAbove > availableHeightBelow) {
                        isAbove = true;
                        maxHeight = availableHeightAbove;
                    } else {
                        maxHeight = availableHeightBelow;
                    }

                    elements.menuItemsWrapper.css({
                        'max-height': maxHeight + 'px'
                    }).hide().show(0);
                    internal.$e.addClass(m.SCROLLMENU);
                } else {
                    isAbove = cachedWrapperBounds.height > availableHeightBelow;
                }

                if (!internal.$e.hasClass(m.DOWN_ONLY)) {
                    elements.menuItemsWrapper.toggleClass(m.ABOVE, isAbove);
                }
            },

            // Find the currently highlighted item.
            getHighlightItem: function () {
                return elements.menuItem ? elements.menuItem.filter(function (i, item) {
                    return $(item).hasClass(m.HIGHLIGHT);
                }) : [];
            },

            // Set the highlight state on the provided $item and clear the
            // highlight state from its siblings.
            setHighlightItem: function ($item) {
                if ($item.hasClass(m.NOOP)) {
                    return;
                }
                fn.resetItemHighlightStates();
                $item.addClass(m.HIGHLIGHT);
            },

            // Remove the highlight state from the supplied $item;
            unsetHighlightItem: function ($item) {
                if ($item.hasClass(m.NOOP)) {
                    return;
                }
                $item.removeClass(m.HIGHLIGHT);
            },

            // Get the previous item, or start at the bottom if at the top of the
            // list, and apply the highlight state to it.
            setHighlightPrevItem: function () {
                var $item, $prevItem;

                $item = fn.getHighlightItem();

                if (!$item.length) {
                    $prevItem = internal.$e.find(internal.components.menuItem.selector).last();
                } else {
                    $prevItem = $item.prev(internal.components.menuItem.selector);
                    if (!$prevItem.length) {
                        $prevItem = internal.$e.find(internal.components.menuItem.selector).last();
                    }
                }

                fn.setHighlightItem($prevItem);

                // If the menu isn't open, open it.
                if (!fn.isOpen()) {
                    fn.openMenu();
                }
            },

            // Get the next item, or start at the top if at the bottom of the list,
            // and set the highlight state on it.
            setHighlightNextItem: function () {
                var $item, $nextItem;

                $item = fn.getHighlightItem();

                if (!$item.length) {
                    $nextItem = internal.$e.find(internal.components.menuItem.selector).first();
                } else {
                    $nextItem = $item.next(internal.components.menuItem.selector);
                    if (!$nextItem.length) {
                        $nextItem = internal.$e.find(internal.components.menuItem.selector).first();
                    }
                }

                fn.setHighlightItem($nextItem);

                // If the menu isn't open, open it.
                if (!fn.isOpen()) {
                    fn.openMenu();
                }
            },

            // Find the $item that currently has the selected state applied.
            getSelectedItem: function () {
                return elements.menuItem.filter(function (i, item) {
                    return $(item).hasClass(m.SELECTED);
                });
            },

            // Apply the selected state to the provided $item.
            selectItemByEl: function ($item) {
                if (!$item.length || $item.hasClass(m.NOOP)) {
                    return;
                }

                fn.resetItemSelectedStates();
                $item.addClass(m.SELECTED);
                fn.closeMenu({ force: true });
            },

            // Find the $item with its data-value attribute set to the passed in
            // value and then set the highlight state to it.
            selectItemByVal: function (value) {
                var $item = elements.menuItem.filter('[data-value="' + value + '"]');

                if ($item.hasClass(m.NOOP)) {
                    return;
                }

                fn.selectItemByEl($item);
            },

            // Reduce the menuItems to a subset using a filter function, by
            // iterating over the collection.
            filter: function (filterFn) {
                elements.menuItem.each(filterFn);
                fn.reset();
                fn.getComponents();
            },

            // Replace the menuItemsWrapper content with the cached menuItems.
            unfilter: function () {
                elements.menuItemsWrapper.html(elements.allOptions);
                fn.getComponents();
            },

            // Remove the highlight state from all $items
            resetItemHighlightStates: function () {
                if (elements.menuItem) {
                    elements.menuItem.removeClass(m.HIGHLIGHT);
                }
            },

            // Remove the highlight state from all $items
            resetItemSelectedStates: function () {
                if (elements.menuItem) {
                    elements.menuItem.removeClass(m.SELECTED);
                }
            }
        };

        // Event handlers
        handlers = {
            // Delegate any caught keyup events to their appropriate handlers
            keyup: function (evnt) {
                let handler = handlers[internal.keyHandlers[evnt.which]];
                if (typeof handler === "function") {
                    handler.call(this, evnt);
                }
            },

            // Set the active state on the root $el
            mouseenter: function () {
                internal.$e.addClass(m.ACTIVE);
            },

            // Remove active state from the root $el
            mouseleave: function () {
                internal.$e.removeClass(m.ACTIVE);
            },

            menuControlClick: function (evnt) {
                var origEvnt = evnt.originalEvent || evnt;

                if (o.selfToggle) {
                    origEvnt.dropMenuClick = true;
                    fn.toggleMenu({ force: fn.isOpen() });
                }
            },

            // Ensure that the window doesn't pick up the scroll when hitting
            // a scroll edge in the menuItemsWrapper
            menuItemsWrapperMousewheel: function (evnt) {
                // Stops the window from closing when the items wrapper has scrolled
                // to it's edges.
                var d = evnt.originalEvent.wheelDelta || -evnt.originalEvent.detail,
                    dir = d > 0 ? 'up' : 'down',
                    stop = (dir === 'up' && this.scrollTop === 0) ||
                        (dir === 'down' && this.scrollTop === this.scrollHeight - this.offsetHeight);
                if (stop) {
                    evnt.preventDefault();
                }
            },

            // Set the highlight state when the mouse is over the $item
            menuItemMouseenter: function () {
                fn.setHighlightItem($(this));
            },

            // Remove the highlight state when the mouse is no longer over the $item.
            menuItemMouseleave: function () {
                fn.unsetHighlightItem($(this));
            },

            // Set the selected state on the $item when clicked. And then call
            // the callback.
            menuItemClick: function (evnt) {
                var $item = $(this);
                var origEvnt = evnt.originalEvent || evnt;

                origEvnt.dropMenuClick = true;

                if ($item.hasClass(m.NOOP)) {
                    return;
                }

                fn.selectItemByEl($item);
                o.onSelect($item);
            },

            // Find the previous $item and highlight it on UP keyup.
            upKeyup: function (evnt) {
                evnt.preventDefault();
                fn.setHighlightPrevItem();
            },

            // Find the next $item and highlight it on DOWN keyup.
            downKeyup: function (evnt) {
                evnt.preventDefault();
                fn.setHighlightNextItem();
            },

            // Set the selected state on the currently highlighted $item on
            // SPACE keyup. And then call the callback.
            spaceKeyup: function () {
                var $item = fn.getHighlightItem();

                if (!$item.length || $item.hasClass(m.NOOP)) {
                    return;
                }

                fn.selectItemByEl($item);
                o.onSelect($item);
            },

            // Set the selected state on the currently highlighted $item on
            // ENTER keyup. And then call the callback.
            enterKeyup: function (evnt) {
                var $item = fn.getHighlightItem();

                evnt.originalEvent.intercepted = true;

                fn.selectItemByEl($item);
                o.onSelect($item);
            },

            // Close the menu on ESCAPE keyup.
            escapeKeyup: function () {
                fn.closeMenu({ force: true });
            }
        };

        // Interface methods to be exposed
        api = {
            toggle: fn.toggleMenu,
            open: fn.openMenu,
            close: fn.closeMenu,
            selectItemByEl: fn.selectItemByEl,
            selectItemByVal: fn.selectItemByVal,
            reset: fn.reset,
            filter: fn.filter,
            unfilter: fn.unfilter,
            isOpen: fn.isOpen,
            isActive: fn.isActive,
            update: fn.update
        };

        // Send the DropMenu module through the factory for processing.
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    // Module markup
    DropMenu.markup = {
        // States
        ABOVE: 'state-above',
        SCROLLMENU: 'state-scroll-menu',
        GLOBAL_OPEN: 'state-dropmenu-open',

        NOOP: 'noop',
        DOWN_ONLY: 'variant-down-only'
    };

    return DropMenu;
});

define('ui/Slideshow', [
    'jquery',
    'factories/moduleFactory',
    'utils/keycodes'
], function (
    $,
    moduleFactory,
    kc
) {
    'use strict';

    var Slideshow = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = Slideshow.markup;

        o = $.extend({
            $e: null,
            selector: '.slideshow',
            data: null,
            modal: null
        }, options);

        internal = {
            name: 'Slideshow',
            $e: o.$e || $(o.selector),

            data: o.data,
            currentIndex: 0,
            modal: o.modal,

            templates: {
                slideshow: {
                    selector: '!.slideshow-template'
                }
            },

            components: {
                prevImage: {
                    selector: '.prev-image'
                },

                nextImage: {
                    selector: '.next-image'
                },

                imageWrapper: {
                    selector: '.image-wrapper'
                },

                currentIndex: {
                    selector: '.current-index'
                },

                totalCount: {
                    selector: '.total-count'
                },

                imageCaption: {
                    selector: '.slideshow-image-caption'
                },

                imageTitleBody: {
                    selector: '.slideshow-meta-body .slideshow-image-title'
                },

                imageTitleFooter: {
                    selector: '.slideshow-meta-footer .slideshow-image-title'
                }
            },

            events: {
                'click @prevImage': 'prevImageClick',
                'click @nextImage': 'nextImageClick'
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                if (internal.data) {
                    fn.render();
                }
            },

            render: function () {
                fn.unbindWindowKeyEvents();
                internal.$e.html(
                    templates.slideshow(internal.data)
                );
                fn.getComponents();
                fn.updateView();

                if (internal.modal) {
                    internal.modal.modal.addClass(m.FULL_SCREEN);
                    internal.modal.modal.addClass(m.SLIDESHOW_MODAL);
                }

                fn.bindToWindowKeyEvents();
            },

            bindToWindowKeyEvents: function () {
                $(window).on('keydown.slideshow', function (evnt) {
                    handlers.windowKeydown(evnt);
                });
            },

            unbindWindowKeyEvents: function () {
                $(window).off('keydown.slideshow');
            },

            update: function (data) {
                internal.data = data;
                fn.render();
            },

            setPositionState: function (i, el) {
                var $el = $(el);

                if (i === internal.currentIndex) {
                    $el.removeClass(m.OUT_LEFT);
                    $el.removeClass(m.OUT_RIGHT);
                } else if (i < internal.currentIndex) {
                    $el.addClass(m.OUT_LEFT);
                } else if (i > internal.currentIndex) {
                    $el.addClass(m.OUT_RIGHT);
                }
            },

            updateView: function () {
                if (!elements.imageWrapper) {
                    return;
                }

                elements.imageWrapper.each(fn.setPositionState);
                elements.imageCaption.each(fn.setPositionState);
                elements.imageTitleBody.each(fn.setPositionState);
                elements.imageTitleFooter.each(fn.setPositionState);

                elements.currentIndex.html(internal.currentIndex + 1);
                elements.totalCount.html(elements.imageWrapper.length);

                elements.prevImage.removeClass(m.DISABLED);
                elements.nextImage.removeClass(m.DISABLED);

                if (internal.currentIndex === 0) {
                    elements.prevImage.addClass(m.DISABLED);
                } else if (internal.currentIndex === elements.imageWrapper.length - 1) {
                    elements.nextImage.addClass(m.DISABLED);
                }
            },

            showPrevImage: function () {
                internal.currentIndex = Math.max(0, internal.currentIndex - 1);
                fn.updateView();
            },

            showNextImage: function () {
                internal.currentIndex = Math.min(elements.imageWrapper.length - 1, internal.currentIndex + 1);
                fn.updateView();
            },

            beforeDestroy: function () {
                fn.unbindWindowKeyEvents();
            }
        };

        handlers = {
            prevImageClick: function () {
                fn.showPrevImage();
            },

            nextImageClick: function () {
                fn.showNextImage();
            },

            windowKeydown: function (evnt) {
                if (evnt.which === kc.LEFT) {
                    fn.showPrevImage();
                } else if (evnt.which === kc.RIGHT) {
                    fn.showNextImage();
                }
            }
        };

        api = {
            update: fn.update
        };

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            m: m,
            api: api
        }).create();
    };

    Slideshow.markup = {
        // Variants
        SHALLOW_PADDING: 'variant-shallow-padding',
        SLIDESHOW_MODAL: 'variant-slideshow-modal',

        // States
        OUT_LEFT: 'state-out-left',
        OUT_RIGHT: 'state-out-right'
    };

    return Slideshow;
});

define('ui/ItemContainer', [
    'jquery',
    'factories/moduleFactory',
    'ui/Paginator',
    'ui/FeedPaginator',
    'forms/widgets/DropMenu',
    'ui/Slideshow'
], function (
    $,
    moduleFactory,
    Paginator,
    FeedPaginator,
    DropMenu,
    Slideshow
) {
    'use strict';

    var ItemContainer = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = ItemContainer.markup;

        o = $.extend({
            $e: null,
            selector: '.' + m.CONTAINER,
            itemSelector: '.' + m.ITEM,
            layout: null,
            onPageAdded: $.noop
        }, options);

        internal = {
            name: 'ItemContainer',
            $e: o.$e || $(o.selector),

            components: {
                item: {
                    selector: o.itemSelector
                },

                launchSlideshow: {
                    selector: '.launch-slideshow'
                },

                itemAnchor: {
                    selector: o.itemSelector + ' a'
                },

                editDrop: {
                    selector: '.module .edit-drop, .listing-layout-item .edit-drop',
                    constructor: DropMenu,
                    moduleOptions: {
                        selfToggle: true
                    }
                },

                feedFieldset: {
                    selector: 'fieldset[name="feed"]'
                },

                removeModule: {
                    selector: '.remove-module'
                },

                moduleDisplaySize: {
                    selector: '.module .display-size'
                }
            },

            events: {
                'mouseenter @item': 'itemMouseenter',
                'mouseleave @item': 'itemMouseleave',
                'click @item': 'itemClick',
                'click @itemAnchor': 'itemAnchorClick',
                'prependitem': 'prependItem',
                'appenditem': 'appendItem',
                'change @moduleDisplaySize': 'moduleDisplaySizeChange',
                'click @removeModule': 'removeModuleClick',
                'removetier': 'removeTier',
                'click @launchSlideshow': 'launchSlideshow'
            }
        };

        elements = {};

        fn = {
            init: function () {
                Paginator.onPageAdded(handlers.paginatorPageAdded);
                FeedPaginator.onPageAdded(handlers.feedPaginatorPageAdded);
            },

            isEditable: function () {
                return internal.$e.hasClass(m.EDITABLE);
            },

            prependItem: function ($item) {
                o.layout.prependItems($item);
                fn.getComponents();

                if (fn.isEditable()) {
                    $item.trigger('new:fieldset');
                }
            },

            appendItem: function ($item) {
                o.layout.appendItems($item);
                fn.getComponents();

                if (fn.isEditable()) {
                    $item.trigger('new:fieldset');
                }
            },

            removeModule: function (removeControlEl) {
                var $removeControlEl, $fieldset, fieldsetInstance, itemData;

                $removeControlEl = $(removeControlEl);
                $fieldset = $removeControlEl.closest('fieldset.' + m.ITEM);
                fieldsetInstance = $fieldset.data('fieldsetInstance');
                itemData = fieldsetInstance.getData();

                internal.$e.trigger('removeitem', itemData);
                fn.trackDeletedItemPk(itemData.items[0].pk);

                fieldsetInstance.removeEl();
            },

            trackDeletedItemPk: function (itemPk) {
                var deletedPks, feedFieldset;

                if (!elements.feedFieldset) {
                    return;
                }

                feedFieldset = elements.feedFieldset.data('fieldsetInstance');
                deletedPks = feedFieldset.getVal('deleted_pks');

                if (!deletedPks) {
                    return;
                }

                deletedPks.push(itemPk);

                feedFieldset.setVals({
                    deleted_pks: deletedPks
                });
            },

            updateModuleDisplaySize: function (displaySizeEl) {
                var $displaySize, $module, displaySizeRadio, displaySize;

                $displaySize = $(displaySizeEl);
                $module = $displaySize.closest('.' + m.MODULE);
                displaySizeRadio = $displaySize.data('customRadioInstance');
                displaySize = displaySizeRadio.getVal();

                $module.toggleClass(m.LARGE_MODULE, displaySize === 'LARGE');
                $module.trigger('sizechange');
            },

            launchSlideshow: function (launchEl) {
                var $launchEl, $wrapperEl, modal,
                    galleryImages, galleryTitle, galleryTags;

                $launchEl = $(launchEl);
                $wrapperEl = $('<div class="slideshow-wrapper" />');

                galleryImages = $launchEl.data('images');
                galleryTitle = $launchEl.data('galleryTitle');
                galleryTags = $launchEl.data('galleryTags');

                modal = o.modalsManager.launchModal({
                    content: $wrapperEl
                });

                new Slideshow({
                    $e: $wrapperEl,
                    data: {
                        readView: true,
                        gallery_title: galleryTitle,
                        images: galleryImages,
                        tags: galleryTags
                    },
                    modal: modal
                });
            }
        };

        handlers = {
            itemMouseenter: function () {
                var $item = $(this);
                $item.addClass(m.HOVER);
            },

            itemMouseleave: function () {
                var $item = $(this);
                $item.removeClass(m.HOVER);
            },

            itemClick: function (evnt) {
                var href = $(this).data('href');
                if (href && !evnt.interceptedByAnchor && !evnt.originalEvent.dropMenuClick) {
                    evnt.preventDefault();
                    if (evnt.metaKey) {
                        window.open(href, '_blank');
                    } else {
                        window.location.assign(href);
                    }
                }
            },

            itemAnchorClick: function (evnt) {
                evnt.interceptedByAnchor = true;
            },

            prependItem: function (evnt, itemHtml) {
                var $item = $(itemHtml);
                fn.prependItem($item);
            },

            appendItem: function (evnt, itemHtml) {
                var $item = $(itemHtml);
                fn.appendItem($item);
            },

            feedPaginatorPageAdded: function (page) {
                handlers.paginatorPageAdded(page);
            },

            paginatorPageAdded: function (page) {
                var $page, $newItems;

                $page = page.$e;

                if (!$.contains($page[0], internal.$e[0])) {
                    return;
                }

                $newItems = $();

                $page.find('.' + m.CONTAINER + ':not(.' + m.SETUP + ')').each(function () {
                    var $container = $(this);
                    $newItems = $newItems.add($container.find(o.itemSelector).detach());
                    $container.remove();
                });

                if ($newItems.length) {
                    o.layout.appendItems($newItems);
                }
            },

            removeModuleClick: function (evnt) {
                evnt.stopPropagation();
                fn.removeModule(this);
            },

            moduleDisplaySizeChange: function () {
                fn.updateModuleDisplaySize(this);
            },

            launchSlideshow: function (evnt) {
                evnt.stopPropagation();
                fn.launchSlideshow(evnt.currentTarget);
            },

            removeTier: function (evnt, tierData) {
                fn.trackDeletedItemPk(tierData.items[0].pk);
            }
        };

        api = {
            isEditable: fn.isEditable,
            appendItem: fn.appendItem,
            prependItem: fn.prependItem
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    ItemContainer.markup = {
        //DOM Selector
        CONTAINER: 'item-container',
        ITEM: 'container-item',
        MODULE: 'module',
        ITEM_FIELDSET: 'fieldset[name="items[]"]',

        // States & variants
        EDITABLE: 'state-editable',
        LARGE_MODULE: 'variant-x2'
    };

    return ItemContainer;
});

define('ui/ShelfPacker', [
    'jquery',
    'factories/moduleFactory',
    'services/layout'
], function (
    $,
    moduleFactory,
    layout
) {
    'use strict';


    var ShelfPacker = function (options) {
        var self, m, o, internal, elements, fn, handlers, api;

        self = this;

        m = ShelfPacker.markup;

        o = $.extend({
            $e: null,
            selector: '.' + m.ITEM_SHELF,
            itemsPerShelf: layout.getFullWidth() / layout.getInfo().columnWidth,
            shelfWidth: layout.getFullWidth(),
            stamps: [],
            itemSelector: '.' + m.SHELF_ITEM,
            isSortable: false
        }, options);

        internal = {
            name: 'ShelfPacker',
            $e: o.$e || $(o.selector),

            slotCount: 0,
            lastEmptySlotIndex: 0,

            slots: [],
            stamps: [],
            sortedItems: [],
            shelfItems: [],
            lastSwap: [],
            shelfTopOffsets: [0],
            lastShelfBottomOffset: 0,

            slotSize: {
                height: o.shelfWidth / o.itemsPerShelf,
                width: o.shelfWidth / o.itemsPerShelf
            },

            components: {
                item: {
                    selector: o.itemSelector
                }
            },

            events: {
                'dragstart @item': 'itemDragstart',
                'drag @item': 'itemDrag',
                'dragend @item': 'itemDragend',
                'dragenter @item': 'itemDragenter',
                'dragleave @item': 'itemDragleave'
            }
        };

        elements = {
            draggingItem: null
        };

        fn = {
            init: function () {
                fn.setupContainer();
                fn.prepStamps();
                fn.packStamps();
                fn.sortItems();
                fn.prepItems();
                fn.packItems();
                fn.autoHeightLastRow();
                fn.updateContainerHeight();
                internal.$e.addClass(m.STATE_PACKED);
            },

            repack: function () {
                fn.resetPositions();
                fn.packStamps();
                fn.packItems();
                fn.autoHeightLastRow();
                fn.updateContainerHeight();
            },

            setupContainer: function () {
                internal.$e.css({
                    'width': o.shelfWidth,
                    'left': 0,
                    'top': 0,
                    'position': 'relative'
                });
            },

            prepStamps: function () {
                var containerBounds, stampBounds, stampObj, xDiff, yDiff;

                containerBounds = internal.$e[0].getBoundingClientRect();
                o.stamps.forEach(function (stamp) {
                    if (stamp) {
                        stampBounds = stamp[0].getBoundingClientRect();

                        if (
                            stampBounds.top < containerBounds.bottom &&
                            stampBounds.bottom > containerBounds.top &&
                            stampBounds.left < containerBounds.right &&
                            stampBounds.right > containerBounds.left
                        ) {
                            xDiff = containerBounds.left - stampBounds.left;
                            yDiff = containerBounds.top - stampBounds.top;

                            stampObj = {
                                stamp: true,
                                xSlots: Math.round((stampBounds.width - xDiff) / internal.slotSize.width),
                                ySlots: Math.ceil((stampBounds.height - yDiff) / internal.slotSize.height)
                            };

                            internal.slotCount += stampObj.xSlots * stampObj.ySlots;
                            internal.stamps.push(stampObj);
                        }
                    }
                });

                if (
                    !internal.stamps.length &&
                    o.itemsPerShelf > 2 &&
                    elements.item &&
                    elements.item.length < o.itemsPerShelf
                ) {
                    internal.stamps.push({
                        stamp: true,
                        xSlots: 1,
                        ySlots: 1
                    });
                    internal.slotCount += 1;
                }
            },

            sortItems: function () {
                var preSortedItems, sortedShelfItems, indexOffset, j,
                    sortedItemIndex, preSortedItem;

                internal.sortedItems = [];
                preSortedItems = [];
                sortedShelfItems = [];
                indexOffset = 0;

                if (elements.item) {
                    elements.item.each(function (i, itemEl) {
                        var $item, itemIndex, dataIndex;

                        $item = $(itemEl);
                        dataIndex = $item.data('index');

                        itemIndex = dataIndex === undefined ? i : dataIndex;

                        while (sortedShelfItems[itemIndex]) {
                            itemIndex += 1;
                        }

                        preSortedItems[itemIndex] = {
                            el: itemEl,
                            data: $item.data('item')
                        };
                    });
                }

                for (j = 0; j < preSortedItems.length; j++) {
                    preSortedItem = preSortedItems[j];

                    if (preSortedItem) {
                        sortedItemIndex = indexOffset + j;
                        internal.sortedItems[sortedItemIndex] = preSortedItem.el;
                        sortedShelfItems[sortedItemIndex] = preSortedItem.data;
                    } else {
                        indexOffset -= 1;
                    }
                }

                internal.shelfItems = sortedShelfItems;
            },

            prepItems: function () {
                internal.sortedItems.forEach(function (itemEl, i) {
                    var $item, item;

                    $item = $(itemEl);

                    if ($item.hasClass(m.PROMO_TIER) || $item.hasClass(m.VARIANT_FULL)) {
                        item = fn.prepPromoTier($item, i);
                    } else {
                        item = {
                            $e: $item,
                            xSlots: Math.round($item.width() / internal.slotSize.width),
                            ySlots: Math.ceil($item.height() / internal.slotSize.height),
                            slotIndex: null,
                            index: $item.data('index') || i
                        };

                        if (o.itemsPerShelf === 1) {
                            item.useItemHeight = true;
                            item.height = $item.height();
                            item.ySlots = 1;
                        }
                    }

                    internal.shelfItems[i] = item;
                    internal.slotCount += item.xSlots + item.ySlots;

                    if (o.isSortable) {
                        $item.attr('draggable', true);
                        // See https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations
                        $item.attr('ondragstart', "event.dataTransfer.setData('text/plain', '');");
                    }
                    $item.data('index', i);
                    $item.data('item', item);
                });
            },

            prepPromoTier: function ($item, i) {
                return {
                    $e: $item,
                    xSlots: o.itemsPerShelf,
                    ySlots: 1,
                    minXSlots: Math.min(o.itemsPerShelf, 3),
                    slotIndex: null,
                    index: $item.data('index') || i,
                    useItemHeight: true,
                    height: $item.height(),
                    useMinXSlots: false,
                    fullRow: true
                };
            },

            prepackSlots: function () {
                internal.slots = new Array(internal.slotCount);
            },

            packStamps: function () {
                internal.stamps.forEach(function (stamp) {
                    fn.packSlots(stamp, internal.lastEmptySlotIndex, true);
                    fn.fillSlots(stamp);
                });
            },

            packItems: function () {
                internal.shelfItems.forEach(function (item) {
                    fn.packSlots(item, internal.lastEmptySlotIndex, true);
                    fn.fillSlots(item);
                });
                fn.calculateShelfTopOffsets();

                internal.shelfItems.forEach(function (item) {
                    fn.positionItem(item);
                });
            },

            packSlots: function (item, slotIndex, firstAttempt) {
                var itemWillFit;
                firstAttempt = firstAttempt || false;
                itemWillFit = fn.itemWillFit(item, slotIndex);

                if (itemWillFit) {
                    item.slotIndex = slotIndex;

                    if (firstAttempt) {
                        internal.lastEmptySlotIndex = fn.getNextEmptySlot();
                    }
                } else {
                    fn.packSlots(item, slotIndex + 1);
                }
            },

            itemWillFit: function (item, slotIndex) {
                var willFit, xi, yi, minXSlots, willFitX, willFitY,
                    possibleX, availableX, rowStartOffset;

                minXSlots = item.minXSlots || item.xSlots;
                willFit = false;
                willFitX = false;
                willFitY = false;

                if (o.itemsPerShelf === 1) {
                    return internal.slots[slotIndex] === undefined;
                }

                if (
                    internal.slots[slotIndex] !== undefined ||
                    (slotIndex % o.itemsPerShelf) + minXSlots > o.itemsPerShelf
                ) {
                    willFit = false;
                } else if (item.xSlots === 1 && item.ySlots === 1) {
                    willFit = true;
                } else {
                    willFitX = true;
                    willFitY = true;
                    possibleX = o.itemsPerShelf - (slotIndex % o.itemsPerShelf);
                    availableX = 0;

                    for (xi = 0; xi < possibleX; xi++) {
                        if (internal.slots[slotIndex + xi] !== undefined) {
                            break;
                        } else {
                            availableX += 1;
                        }
                    }

                    willFitX = minXSlots <= availableX;

                    if (item.fullRow) {
                        rowStartOffset = slotIndex % o.itemsPerShelf;
                        if (
                            !(
                                rowStartOffset === 0 ||
                                rowStartOffset === 1 && (
                                    internal.slots[slotIndex - 1] &&
                                    internal.slots[slotIndex - 1].stamp
                                )
                            )
                        ) {
                            willFitX = false;
                        }
                    }

                    if (willFitX && item.ySlots > 1) {
                        for (xi = 0; xi < item.xSlots; xi++) {
                            for (yi = 1; yi < item.ySlots; yi++) {
                                willFitY = willFitY ? internal.slots[slotIndex + xi + (o.itemsPerShelf * yi)] === undefined : false;
                            }
                        }
                    }

                    willFit = willFitX && willFitY;

                    if (willFit && item.minXSlots) {
                        item.useMinXSlots = availableX !== o.itemsPerShelf && availableX === item.minXSlots;
                        item.$e.toggleClass(m.VARIANT_MIN_FULL, item.useMinXSlots);
                    }
                }

                return willFit;
            },

            fillSlots: function (item) {
                var xi, yi, xSlots;

                xSlots = item.useMinXSlots ? item.minXSlots : item.xSlots;

                for (xi = 0; xi < xSlots; xi++) {
                    internal.slots[item.slotIndex + xi] = item;

                    if (item.ySlots > 1) {
                        for (yi = 1; yi < item.ySlots; yi++) {
                            internal.slots[item.slotIndex + xi + (o.itemsPerShelf * yi)] = item;
                        }
                    }
                }
            },

            getNextEmptySlot: function () {
                var slotIndex, lastSlotIndex;

                lastSlotIndex = 0;

                for (slotIndex = internal.lastEmptySlotIndex; slotIndex < internal.slots.length; slotIndex++) {
                    if (internal.slots[slotIndex] === undefined && lastSlotIndex === 0) {
                        lastSlotIndex = slotIndex;
                        break;
                    }
                }

                return lastSlotIndex;
            },

            calculateShelfTopOffsets: function () {
                var sortedShelfItems;

                sortedShelfItems = internal.shelfItems.slice(0);
                internal.shelfTopOffsets = [0];

                sortedShelfItems.sort(function (itemA, itemB) {
                    var shelfAIndex, shelfBIndex, slotsPerShelf;

                    slotsPerShelf = o.itemsPerShelf;
                    shelfAIndex = Math.floor(itemA.slotIndex / slotsPerShelf);
                    shelfBIndex = Math.floor(itemB.slotIndex / slotsPerShelf);

                    return shelfAIndex - shelfBIndex;
                });

                sortedShelfItems.forEach(function (item) {
                    var shelfIndex, slotsPerShelf, shelfTopOffset, heightDiff,
                        lastOffsetIndex, undefinedShelfOffsets;

                    slotsPerShelf = o.itemsPerShelf;
                    shelfIndex = Math.floor(item.slotIndex / slotsPerShelf);
                    shelfTopOffset = internal.shelfTopOffsets[shelfIndex];
                    lastOffsetIndex = shelfIndex;
                    undefinedShelfOffsets = [];

                    while (shelfTopOffset === undefined) {
                        undefinedShelfOffsets.push(lastOffsetIndex);
                        lastOffsetIndex = lastOffsetIndex - 1;
                        shelfTopOffset = internal.shelfTopOffsets[lastOffsetIndex];
                    }

                    undefinedShelfOffsets.forEach(function (undefinedShelfIndex) {
                        internal.shelfTopOffsets[undefinedShelfIndex] = shelfTopOffset;
                    });

                    internal.shelfTopOffsets[shelfIndex] = shelfTopOffset;

                    if (item.useItemHeight) {
                        heightDiff = item.$e.height() - internal.slotSize.height;
                        internal.shelfTopOffsets[shelfIndex + 1] = shelfTopOffset + heightDiff;
                    } else {
                        internal.shelfTopOffsets[shelfIndex + 1] = shelfTopOffset;
                    }
                });
            },

            positionItem: function (item) {
                var shelfIndex, shelfSlotOffset, top, left,
                    slotsPerShelf, slotHeight, slotWidth,
                    shelfTopOffset;

                slotsPerShelf = o.itemsPerShelf;
                slotHeight = internal.slotSize.height;
                slotWidth = internal.slotSize.width;

                shelfIndex = Math.floor(item.slotIndex / slotsPerShelf);
                shelfSlotOffset = shelfIndex * slotsPerShelf;
                shelfTopOffset = internal.shelfTopOffsets[shelfIndex];

                top = ((shelfIndex * slotHeight) + shelfTopOffset) + 'px';
                left = ((item.slotIndex - shelfSlotOffset) * slotWidth) + 'px';

                item.$e.css({
                    transform: 'translate3d(' + left + ', ' + top + ', 0)'
                });
            },

            autoHeightLastRow: function () {
                var i, itemsPerShelf, lastRowItems,
                    lastItemIndex, firstItemIndex, shelfCount,
                    shelfItem, lastRowItem, lastShelfBottomOffset,
                    lastRowItemHeight, lastRowItemAutoHeight,
                    lastRowItemHeightOffset;

                itemsPerShelf = o.itemsPerShelf;
                shelfCount = fn.getUsedShelfCount();
                lastItemIndex = shelfCount * itemsPerShelf;
                firstItemIndex = lastItemIndex - itemsPerShelf;
                lastShelfBottomOffset = -internal.slotSize.height;

                lastRowItems = [];
                for (i = firstItemIndex; i <= lastItemIndex; i++) {
                    shelfItem = internal.slots[i];
                    if (shelfItem && !shelfItem.stamp) {
                        lastRowItems.push(shelfItem);
                    }
                }

                for (i = 0; i < lastRowItems.length; i++) {
                    lastRowItem = lastRowItems[i];
                    lastRowItem.$e.removeClass(m.VARIANT_AUTO_HEIGHT);
                    lastRowItemHeight = lastRowItem.$e.height();
                    lastRowItem.$e.addClass(m.VARIANT_AUTO_HEIGHT);
                    lastRowItemAutoHeight = lastRowItem.$e.height();

                    lastRowItemHeightOffset = lastRowItemAutoHeight - lastRowItemHeight;

                    if (lastRowItemHeightOffset > lastShelfBottomOffset) {
                        lastShelfBottomOffset = lastRowItemHeightOffset;
                    }
                }

                internal.lastShelfBottomOffset = lastShelfBottomOffset;
            },

            updateContainerHeight: function () {
                var shelfCount, containerHeight, lastShelfTopOffsetIndex,
                    lastShelfTopOffset, lastShelfBottomOffset;

                shelfCount = fn.getUsedShelfCount();
                lastShelfTopOffsetIndex = shelfCount;
                lastShelfTopOffset = internal.shelfTopOffsets[lastShelfTopOffsetIndex];
                lastShelfBottomOffset = internal.lastShelfBottomOffset;

                while (lastShelfTopOffset === undefined) {
                    lastShelfTopOffsetIndex -= 1;
                    lastShelfTopOffset = internal.shelfTopOffsets[lastShelfTopOffsetIndex];
                }

                containerHeight = (shelfCount * internal.slotSize.height) + lastShelfTopOffset + lastShelfBottomOffset;

                internal.$e.css({
                    height: containerHeight + 'px'
                });

                internal.$e
                    .closest(m.STREAM_BLOCK)
                    .toggleClass(m.VARIANT_AUTO_HEIGHT, lastShelfBottomOffset !== 0);
            },

            getUsedShelfCount: function () {
                var shelfCount, usedShelfCount, i, j, startSlotIndex,
                    hasRealItems, shelfItem;

                shelfCount = internal.slots.length / o.itemsPerShelf;
                shelfCount = Math.ceil(shelfCount);

                usedShelfCount = 0;

                for (i = 0; i < shelfCount; i++) {
                    startSlotIndex = i * o.itemsPerShelf;
                    hasRealItems = false;

                    for (j = 0; j < o.itemsPerShelf; j++) {
                        shelfItem = internal.slots[startSlotIndex + j];
                        hasRealItems = hasRealItems || shelfItem && !shelfItem.stamp;
                    }

                    if (hasRealItems) {
                        usedShelfCount += 1;
                    }
                }

                return usedShelfCount;
            },

            swapItems: function ($dragItem, $otherItem) {
                var dragItemIndex, otherItemIndex, dragItem, otherItem,
                    requiresRepack, dragItemStyles, otherItemStyles,
                    dragItemSlotIndex, otherItemSlotIndex;

                requiresRepack = true;

                if (!$dragItem || !$otherItem) {
                    return;
                }

                dragItemIndex = $dragItem.data('index');
                otherItemIndex = $otherItem.data('index');

                if (
                    dragItemIndex === otherItemIndex ||
                    (
                        dragItemIndex === internal.lastSwap[1] &&
                        otherItemIndex === internal.lastSwap[0]
                    )
                ) {
                    return false;
                }

                dragItem = internal.shelfItems[dragItemIndex];
                otherItem = internal.shelfItems[otherItemIndex];

                internal.shelfItems[otherItemIndex] = dragItem;
                internal.shelfItems[dragItemIndex] = otherItem;

                $dragItem.data('index', otherItemIndex);
                $otherItem.data('index', dragItemIndex);

                if (
                    dragItem.xSlots === otherItem.xSlots &&
                    dragItem.ySlots === otherItem.ySlots
                ) {
                    requiresRepack = false;

                    dragItemStyles = $dragItem.attr('style');
                    otherItemStyles = $otherItem.attr('style');

                    dragItemSlotIndex = dragItem.slotIndex;
                    otherItemSlotIndex = otherItem.slotIndex;

                    $dragItem.attr('style', otherItemStyles);
                    $otherItem.attr('style', dragItemStyles);

                    dragItem.slotIndex = otherItemSlotIndex;
                    otherItem.slotIndex = dragItemSlotIndex;
                }

                if (
                    dragItem.useItemHeight ||
                    otherItem.useItemHeight
                ) {
                    requiresRepack = true;
                }

                clearTimeout(internal.lastSwapTimeout);
                internal.lastSwap = [dragItemIndex, otherItemIndex];
                internal.lastSwapTimeout = setTimeout(function () {
                    internal.lastSwap = [];
                }, 100);

                fn.sortItems();

                return {
                    requiresRepack: requiresRepack
                };
            },

            resetPositions: function () {
                internal.slots = [];
                internal.lastEmptySlotIndex = 0;
            },

            reset: function () {
                var itemIndexOffset, lastItemIndex;

                o.shelfWidth = layout.getFullWidth();
                o.itemsPerShelf = o.shelfWidth / layout.getInfo().columnWidth;

                internal.shelfItems = [];
                internal.stamps = [];
                internal.slots = [];

                internal.slotCount = 0;
                internal.slotSize = {
                    height: o.shelfWidth / o.itemsPerShelf,
                    width: o.shelfWidth / o.itemsPerShelf
                };

                internal.shelfTopOffsets = [0];

                if (elements.item) {
                    itemIndexOffset = 0;
                    lastItemIndex = -1;
                    elements.item.each(function (i, itemEl) {
                        var $item, itemIndex;

                        $item = $(itemEl);
                        itemIndex = $item.data('index');

                        if (itemIndex !== undefined) {
                            $item.data('index', itemIndex + itemIndexOffset);
                            lastItemIndex = itemIndex + itemIndexOffset;
                        } else {
                            $item.data('index', lastItemIndex + 1);
                            lastItemIndex = lastItemIndex + 1;
                            itemIndexOffset = itemIndexOffset + 1;
                        }
                    });
                }

                fn.resetPositions();
                fn.init();
            },

            getElements: function () {
                return internal.sortedItems;
            },

            remove: function (itemEl) {
                elements.item = elements.item.not(itemEl);
                fn.reset();
            },

            hardReset: function () {
                fn.getComponents();
                fn.reset();
            }
        };

        handlers = {
            itemDragstart: function () {
                var $this;

                $this = $(this);
                elements.draggingItem = $this;
                $this.addClass(m.DRAGGING);
            },

            itemDrag: function () {
            },

            itemDragend: function () {
                var $this;

                $this = $(this);
                $this.removeClass(m.DRAGGING);
            },

            itemDragenter: function () {
                var swapped;

                swapped = fn.swapItems(elements.draggingItem, $(this));

                if (swapped && swapped.requiresRepack) {
                    fn.repack();
                }
            },

            itemDragleave: function () {
            },

            handleResize: function () {
                fn.reset();
            }
        };

        api = {
            handleResize: handlers.handleResize,
            getElements: fn.getElements,
            remove: fn.remove,
            hardReset: fn.hardReset
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    ShelfPacker.markup = {
        // DOM Selectors
        ITEM_SHELF: 'item-shelf',
        SHELF_ITEM: 'shelf-item',
        PROMO_TIER: 'promo-tier',
        MODULE_HEAD: 'module-head',
        STREAM_BLOCK: 'stream-block',

        // States
        VARIANT_WITH_IMG: 'variant-with-img',
        VARIANT_X2: 'variant-x2',
        VARIANT_FULL: 'variant-full',
        VARIANT_MIN_FULL: 'variant-min-full',
        VARIANT_AUTO_HEIGHT: 'variant-auto-height',
        STATE_PACKED: 'state-packed',
        DRAGGING: 'state-dragging',
        STATE_Y2: 'state-y2',
        EDITABLE: 'state-editable'
    };

    return ShelfPacker;
});

define('ui/ModuleLayout', [
    'jquery',
    'factories/moduleFactory',
    'jss',
    'services/layout',
    'utils/stringUtil',
    'utils/arrayUtil',
    'ui/ItemContainer',
    'ui/ShelfPacker'
], function (
    $,
    moduleFactory,
    jss,
    layout,
    stringUtil,
    arrayUtil,
    ItemContainer,
    ShelfPacker
) {
    'use strict';

    var ModuleLayout = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = ModuleLayout.markup;

        o = $.extend({
            $e: null,
            selector: '.' + m.CONTAINER,

            moduleComponents: ['head', 'body'],
            cyclicBackgroundIndexes: [1, 2, 3, 4, 5, 6],

            baseUnit: layout.dimensions.BASE_UNIT,
            columnWidth: function () {
                return layout.getInfo().columnWidth;
            },
            maxHeightY2: function () {
                return (o.columnWidth() * 1.75) - (o.baseUnit * 3);
            },
            jssRules: function () {
                var breakpoints = layout.breakpoints,
                    viewportInfo = layout.getInfo(),
                    breakpoint = viewportInfo.breakpoint,
                    columnWidth = viewportInfo.columnWidth,
                    columnUnit = viewportInfo.columnUnit,
                    columnCount = breakpoint.columnCount,
                    fullWidth = columnWidth * breakpoint.columnCount;

                return {
                    '.rail': {
                        'margin-top': (function () {
                            if (breakpoint === breakpoints.FULL || breakpoint === breakpoints.MEDIUM) {
                                return 0 - columnUnit;
                            }
                            return 0;
                        }()) + 'px'
                    },
                    '.module-layout': {
                        width: fullWidth + 'px'
                    },
                    '.module': {
                        position: 'absolute',
                        left: 0 + 'px',
                        top: 0 + 'px'
                    },
                    '.module, .rail': {
                        width: columnWidth + 'px'
                    },
                    '.module.variant-x2': {
                        width: (function () {
                            if (breakpoint === breakpoints.FULL || breakpoint === breakpoints.MEDIUM) {
                                return 2 * columnWidth;
                            }
                            return columnWidth;
                        }()) + 'px'
                    },
                    '.module.variant-x3': {
                        width: (function () {
                            if (breakpoint === breakpoints.FULL || breakpoint === breakpoints.MEDIUM) {
                                return 3 * columnWidth;
                            }
                            return columnWidth;
                        }()) + 'px'
                    },
                    '.module.variant-full': {
                        width: fullWidth + 'px'
                    },
                    '.module .module-head': {
                        height: columnWidth + 'px'
                    },
                    '.module .module-body': {
                        height: (function () {
                            if (columnCount > 1) {
                                return (columnWidth + 'px');
                            }
                            return 'auto';
                        }())
                    },
                    '.module.variant-x2 .module-head': {
                        height: (function () {
                            if (breakpoint === breakpoints.FULL || breakpoint === breakpoints.MEDIUM) {
                                return 2 * columnWidth;
                            }
                            return columnWidth;
                        }()) + 'px'
                    },
                    '.module.state-y2 .module-body': {
                        height: (function () {
                            if (columnCount > 1) {
                                return (2 * columnWidth + 'px');
                            }
                            return 'auto';
                        }())
                    }
                };
            }
        }, options);

        internal = {
            name: 'ModuleLayout',
            $e: o.$e || $(o.selector),

            shelfPacker: null,
            modules: [],
            domChangeTimeout: null,

            components: {
                module: {
                    selector: '.' + m.MODULE
                },

                rail: {
                    selector: '!.' + m.RAIL
                },

                globalPage: {
                    selector: '!.' + m.GLOBAL_PAGE
                },

                itemsFieldset: {
                    selector: '.' + m.ITEMS_FIELDSET
                },

                itemContainer: {
                    selector: '.' + m.ITEM_CONTAINER
                },

                promoTier: {
                    selector: '.' + m.PROMO_TIER
                }
            },

            events: {
                'modremove @module': 'moduleRemove',
                'dragend @module': 'moduleDragEnd',
                'sizechange @module': 'moduleSizeChange',
                'domchange !globalPage': 'relatedDomChange',
                'change !globalPage': 'relatedDomChange'
            },

            itemContainer: null
        };

        elements = {};

        fn = {
            init: function () {
                fn.initPacker();

                if (!fn.isZeroState()) {
                    arrayUtil.shuffle(o.cyclicBackgroundIndexes);

                    // Init sequence
                    fn.updateModuleStyles();
                    fn.cacheModuleOrder();
                    fn.processModules();
                    fn.applyCyclicBackgrounds();

                    // Cross Module bindings
                    layout.onResize(handlers.resize);

                    if (fn.isSortable()) {
                        fn.setOrderedFieldsetsMethod();
                    }
                }

                internal.itemContainer = new ItemContainer($.extend({
                    $e: internal.$e,
                    layout: self,
                    itemSelector: '.' + m.MODULE,
                    modalsManager: ModuleLayout._core.getInstance('modalsManager')
                }, options));
            },

            isEditable: function () {
                return internal.itemContainer.isEditable();
            },

            isSortable: function () {
                return internal.$e.hasClass(m.SORTABLE);
            },

            isZeroState: function () {
                return internal.$e.find('.' + m.ZERO_BLOCK).length ? true : false;
            },

            getContainer: function () {
                return elements.itemsFieldset || internal.$e;
            },

            initPacker: function () {
                internal.shelfPacker = new ShelfPacker({
                    $e: internal.$e,
                    itemSelector: '.' + m.MODULE,
                    isSortable: fn.isSortable(),
                    stamps: [
                        elements.rail
                    ]
                });
            },

            setOrderedFieldsetsMethod: function () {
                var $itemsFieldset;

                $itemsFieldset = fn.getItemsFieldset();

                if ($itemsFieldset) {
                    $itemsFieldset.data('orderedFieldsets', function () {
                        return $(internal.shelfPacker.getElements());
                    });
                }
            },

            getItemsFieldset: function () {
                return elements.itemsFieldset || $();
            },

            reflow: function (full) {
                if (full) {
                    fn.updateModuleStyles();
                    fn.processModules();
                }
                fn.cacheModuleOrder();
                fn.applyCyclicBackgrounds();
            },

            // Dynamically calculate and apply module styles
            updateModuleStyles: function () {
                var jssRules = o.jssRules();

                $.each(jssRules, function (selector, rules) {
                    jss.remove(selector);
                    jss.set(selector, rules);
                });
            },

            cacheModuleOrder: function () {
                var orderedModules = [];

                internal.shelfPacker.getElements().forEach(function (moduleEl, i) {
                    internal.modules.forEach(function ($module) {
                        if ($module[0] === moduleEl) {
                            orderedModules[i] = $module;
                        }
                    });
                });

                internal.modules = orderedModules;
            },

            // Find, process, and cache modules
            processModules: function () {
                var breakpoint = layout.getInfo().breakpoint;

                internal.modules = [];
                internal.shelfPacker.getElements().forEach(function (moduleEl) {
                    var $module = $(moduleEl);

                    $.extend($module, {
                        components: {},
                        hasVariant: {},
                        contentGuards: {},
                        heights: {
                            contentGuards: {}
                        }
                    });

                    fn.getModuleComponents($module);
                    fn.getModuleVariants($module);
                    fn.getModuleContentGuards($module);

                    fn.resetHeight($module);
                    fn.getModuleHeights($module);

                    fn.handleContentHeights($module, breakpoint);
                    fn.applyContentGuards($module);
                    // fn.handlePromoTier($module, breakpoint);

                    if ($module.hasVariant.list && breakpoint.columnCount > 1) {
                        fn.heightToNextCol($module);
                    }

                    internal.modules.push($module);
                });

                internal.shelfPacker.hardReset();
            },

            // Get the base components for the modules, listed in
            // o.moduleComponents above.
            getModuleComponents: function ($module) {
                o.moduleComponents.forEach(function (componentKey) {
                    var $component = $module.find('.' + m.MODULE_COMPONENTS[componentKey]);

                    if ($component.length) {
                        $module.components[componentKey] = $component;
                    }
                });
            },

            // Regex match against the module classes for variants and cache
            // them to hasVariant. Allows for a more readable conditional
            // if ($module.hasVariant.y2) {...}
            getModuleVariants: function ($module) {
                var moduleClasses = $module[0].className,
                    moduleVariants = moduleClasses.match(/variant-([^\s]+)/g);

                if (moduleVariants) {
                    moduleVariants.forEach(function (variant) {
                        variant = variant.replace(/variant-/, '');
                        variant = stringUtil.camelCaseify(variant);
                        $module.hasVariant[variant] = true;
                    });
                }
            },

            // Get the content guards in each base component and cache it
            getModuleContentGuards: function ($module) {
                $.each($module.components, function (componentKey, $component) {
                    var $componentContentGuard = $component.find('.' + m.MODULE_CONTENT_GUARD);

                    if ($componentContentGuard.length) {
                        $module.contentGuards[componentKey] = $componentContentGuard;
                    }
                });
            },

            // Get the available height and scrollHeight of each base component
            // and any nested content guards
            getModuleHeights: function ($module) {
                $.each($module.components, function (componentKey, $component) {
                    var $contentGuard;

                    $module.heights[componentKey] = {
                        height: $component.height(),
                        scrollHeight: $component[0].scrollHeight
                    };

                    if ($module.contentGuards[componentKey]) {
                        $contentGuard = $module.contentGuards[componentKey];
                        $module.heights.contentGuards[componentKey] = {
                            height: $contentGuard.height(),
                            scrollHeight: $contentGuard[0].scrollHeight
                        };
                    }
                });
            },

            // Check if the body scrollHeight is larger than 1 base column's width
            // and apply the y2 state if necessary.
            handleContentHeights: function ($module, breakpoint) {
                if ($module.components.body && breakpoint.columnCount > 1) {
                    if (
                        $module.heights.body.scrollHeight > o.columnWidth() &&
                        !$module.hasVariant.list
                    ) {
                        $module.addClass(m.STATE_Y2);
                        fn.getModuleHeights($module);
                    }

                }
            },

            // If the content is wrapped in a guard and is higher than the available
            // height (less its siblings heights and margin) then apply the guard
            // state to ensure that the content is clipped and faded
            applyContentGuards: function ($module) {
                $.each($module.contentGuards, function (componentKey, $contentGuard) {
                    var contentGuardScrollHeight = $module.heights.contentGuards[componentKey].scrollHeight,
                        componentHeight = $module.heights[componentKey].height,
                        contentTooDamnHigh, maxHeight;

                    maxHeight = fn.calcGuardedMaxHeight(componentHeight, $contentGuard);
                    contentTooDamnHigh = contentGuardScrollHeight > maxHeight;

                    $contentGuard.toggleClass(m.GUARDED, contentTooDamnHigh);
                    $contentGuard.css('max-height', maxHeight);
                });
            },

            // Iterate cyclicly through the cyclicBackgroundIndexes and apply
            // background states to modules that have a head but no image
            // or gradient
            applyCyclicBackgrounds: function () {
                var currentCyclicIndex = 0,
                    backgroundIndex,
                    currentCyclicBg;

                internal.modules.forEach(function ($module) {
                    if (
                        $module.components.head &&
                        !$module.hasVariant.withImg &&
                        !$module.hasVariant.withGradient &&
                        !$module.hasVariant.person &&
                        !$module.hasVariant.group
                    ) {
                        backgroundIndex = o.cyclicBackgroundIndexes[currentCyclicIndex];
                        currentCyclicBg = $module.attr('class').match(/state-bg-./g);

                        if (currentCyclicBg) {
                            $module.removeClass(currentCyclicBg[0]);
                        }

                        $module.addClass(m.CYCLIC_BG + backgroundIndex);

                        currentCyclicIndex += 1;
                        if (currentCyclicIndex === o.cyclicBackgroundIndexes.length) {
                            currentCyclicIndex = 0;
                        }
                    }
                });
            },

            // Calculate the max available height for content guard minus
            // the heights and margins of its siblings
            calcGuardedMaxHeight: function (totalAvailableHeight, $contentGuard) {
                var totalSiblingsHeight = 0,
                    contentMarginTop = parseInt($contentGuard.css('margin-top'), 10),
                    contentMarginBottom = parseInt($contentGuard.css('margin-bottom'), 10),
                    maxHeight;

                $contentGuard.siblings().each(function (i, sibling) {
                    var $sibling = $(sibling),
                        siblingOuterHeight = $sibling.outerHeight(true);

                    totalSiblingsHeight += siblingOuterHeight;
                });

                maxHeight = totalAvailableHeight;
                maxHeight -= contentMarginTop;
                maxHeight -= contentMarginBottom;
                maxHeight -= totalSiblingsHeight;

                return maxHeight;
            },


            // Reset any script based height declarations to ensure that any processing
            // is done on a more 'natural' DOM state
            resetHeight: function ($elem) {
                $elem.removeClass(m.STATE_Y2);
                $elem.removeClass(m.HEIGHT_ADJUSTED);
                $elem.removeClass(m.HEIGHT_ADJUSTED_TO_TIER);

                $elem.css('height', '');

                if ($elem.contentGuards) {
                    $.each($elem.contentGuards, function (componentKey, $contentGuard) {
                        $contentGuard.css('max-height', '');
                    });
                }
            },

            // Calculate and set the height of an element to the next multiple of
            // the full column base width
            heightToNextCol: function ($elem) {
                var elemHeight = $elem.outerHeight(),
                    elemMarginTop = parseInt($elem.css('margin-top'), 10),
                    columnWidth = o.columnWidth(),
                    elemHeightToCol = (elemHeight - elemMarginTop) / columnWidth;

                $elem.css({
                    'height': (Math.ceil(elemHeightToCol) * columnWidth) - elemMarginTop
                });
                $elem.addClass(m.HEIGHT_ADJUSTED);
            },

            appendModules: function ($modules) {
                fn.getContainer().append($modules);
                fn.onDomChange($modules);
            },

            prependModules: function ($modules) {
                fn.getContainer().prepend($modules);
                fn.onDomChange($modules);
            },

            onDomChange: function ($modules) {
                clearTimeout(internal.domChangeTimeout);
                internal.domChangeTimeout = setTimeout(function () {
                    fn.reflow(true);
                }, 0);

                internal.shelfPacker.hardReset();

                if (fn.isEditable() && $modules) {
                    $modules.each(function (i, module) {
                        $(module).first().trigger('new:fieldset');
                    });
                }
            }
        };

        handlers = {
            // Reflow the modules on screen resize
            resize: function () {
                internal.shelfPacker.handleResize();
                fn.processModules();
                fn.reflow(true);
            },

            moduleRemove: function () {
                if (!this.moduleRemoving) {
                    this.moduleRemoving = true;
                    internal.shelfPacker.remove(this);
                    fn.reflow();
                }
            },

            moduleDragEnd: function () {
                fn.getItemsFieldset().trigger('orderfieldsets');
                fn.reflow();
            },

            moduleSizeChange: function () {
                fn.reflow(true);
                internal.shelfPacker.handleResize();
            },

            relatedDomChange: function () {
                clearTimeout(internal.domChangeTimeout);
                internal.domChangeTimeout = setTimeout(function () {
                    internal.shelfPacker.hardReset();
                    fn.reflow();
                }, 50);
            }
        };

        api = {
            getContainer: fn.getContainer,
            appendItems: fn.appendModules,
            prependItems: fn.prependModules
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    ModuleLayout.markup = {
        // DOM Selectors
        CONTAINER: 'module-layout',
        GLOBAL_PAGE: 'global-page',
        RAIL: 'rail',
        MODULE: 'module',
        MODULE_CONTENT_GUARD: 'module-content-guard',
        MODULE_COMPONENTS: {
            head: 'module-head',
            body: 'module-body'
        },
        ITEMS_FIELDSET: 'items-fieldset',
        ITEM_CONTAINER: 'item-container',
        PROMO_TIER: 'promo-tier',
        ZERO_BLOCK: 'zero-block',

        // States
        GUARDED: 'state-guarded',
        STATE_Y2: 'state-y2',
        HEIGHT_ADJUSTED: 'state-height-adjusted',
        CYCLIC_BG: 'state-bg-',
        DRAGGING: 'state-dragging',
        SORTABLE: 'state-sortable',
        EDITABLE: ItemContainer.markup.EDITABLE,
        HEIGHT_ADJUSTED_TO_TIER: 'state-height-adjusted-to-tier'
    };

    return ModuleLayout;
});

define('ui/ListingLayout', [
    'jquery',
    'factories/moduleFactory',
    'ui/ItemContainer'
], function (
    $,
    moduleFactory,
    ItemContainer
) {
    'use strict';

    var ListingLayout = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = ListingLayout.markup;

        o = $.extend({
            $e: null,
            selector: '.' + m.CONTAINER,
            itemSelector: '.' + m.LISTING_ITEM
        }, options);

        internal = {
            name: 'ListingLayout',
            $e: o.$e || $(o.selector),

            components: {
            },

            events: {},

            itemContainer: null
        };

        elements = {};

        fn = {
            init: function () {
                internal.itemContainer = new ItemContainer($.extend({
                    $e: internal.$e,
                    layout: self,
                    itemSelector: o.itemSelector
                }, options));
            },

            getContainer: function () {
                return internal.$e;
            },
            appendItems: function ($newItems) {
                var $container, $lastItem;
                $container = fn.getContainer();
                $lastItem = $container.find(o.itemSelector).last();

                if ($lastItem.length) {
                    $lastItem.after($newItems);
                } else {
                    $container.append($newItems);
                }

                if (internal.itemContainer.isEditable()) {
                    $newItems.each(function (i, item) {
                        $(item).first().trigger('new:fieldset');
                    });
                }
            },

            prependItems: function ($newItems) {
                var $container, $firstItem;
                $container = fn.getContainer();
                $firstItem = $container.find(o.itemSelector).first();

                if ($firstItem.length) {
                    $firstItem.before($newItems);
                } else {
                    $container.prepend($newItems);
                }

                if (internal.itemContainer.isEditable()) {
                    $newItems.each(function (i, item) {
                        $(item).first().trigger('new:fieldset');
                    });
                }
            }
        };

        handlers = {};

        api = {
            getContainer: fn.getContainer,
            appendItems: fn.appendItems,
            prependItems: fn.prependItems
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    ListingLayout.markup = {
        //DOM Selector
        CONTAINER: 'listing-layout',
        LISTING_ITEM: 'listing-layout-item'
    };

    return ListingLayout;
});

define('services/ExternalLinkObserver', [
    'jquery'
], function (
    $
) {
    'use strict';
    /*
        ExternalLinkObserver
        ====================

        A module responsible for detecting external links and ensuring that they
        open in a new tab (or modal on the GI screens) when clicked.
    */
    var ExternalLinkObserver = function (options, coreInstances) {
        var o, internal, fn, handlers;

        o = $.extend({
            $e: null,
            selector: 'body'
        }, options);

        internal = {
            name: 'ExternalLinkObserver',
            $e: o.$e || $(o.selector),
            linksInModal: o.linksInModal || false,
            coreInstances: coreInstances,

            nonHTMLURLRegex: new RegExp(/\.(pdf|doc|docx|ppt|pptx|xls|xlsx)$/),
            localLinkRegex: new RegExp('/' + window.location.host + '/'),
            qualifiedURLRegex: new RegExp('^[A-Za-z]{3,7}://')
        };

        fn = {
            init: function () {
                var selector = internal.linksInModal ? 'a' : 'a[target!="_blank"]';
                internal.$e.on('click', selector, handlers.linkClick);
            },

            // Check if the DOM element link has an href pointing to an external URL,
            // And, if so, set the link's target attribute to _blank.
            checkAndHandleExternalLink: function (link) {
                var $link = $(link),
                    url = link.href,
                    modalInstance = null,
                    windowURL = null,
                    linkURL = null;

                if (
                    url &&
                    internal.qualifiedURLRegex.test(url) &&
                    !internal.localLinkRegex.test(url)
                ) {
                    if (internal.linksInModal || $link.data('showInModal')) {
                        // upgrade link url to https if we're on an https page
                        windowURL = new URL(location);

                        if (windowURL.protocol === 'https:') {
                            linkURL = new URL(url);
                            linkURL.protocol = 'https:';
                            url = linkURL.toString();
                        }

                        // only try to iframe stuff that looks like html
                        if (!internal.nonHTMLURLRegex.test(url)) {
                            modalInstance = internal.coreInstances.modalsManager.launchModal({
                                content: '<iframe src="' + url + '" height="100%" width="100%"></iframe>'
                            });
                            modalInstance.modal.addClass('variant-external-link-modal');
                        }
                        return false;
                    } else {
                        $link.attr('target', '_blank');
                    }
                }
                return true;
            }
        };

        handlers = {
            linkClick: function () {
                return fn.checkAndHandleExternalLink(this);
            }
        };

        fn.init();
    };

    return ExternalLinkObserver;
});

define('utils/transitionUtil', [], function () {
    'use strict';
    /*
        TransitionUtil
        ==============

        A set of utilities to help out with:
        - Binding to one transtion end event
    */
    var transitionUtil = {},
        // Map of transition events in the various browser flavours
        transitionEvents = {
            end: 'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd'
        };

    transitionUtil = {
        // Bind a one time listener/handler to the transition end event.
        oneEnd: function ($el, handler) {
            $el.one(transitionEvents.end, handler);
        },

        // Bind a listener/handler to the transition end event.
        onEnd: function ($el, handler) {
            $el.on(transitionEvents.end, handler);
        }
    };

    return transitionUtil;
});

!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("jquery")) : "function" == typeof define && define.amd ? define('parsley', ["jquery"], e) : (t = t || self).parsley = e(t.jQuery) }(this, function (h) { "use strict"; function n(t) { return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function l() { return (l = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]) } return t }).apply(this, arguments) } function o(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { if (!(Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))) return; var i = [], r = !0, n = !1, s = void 0; try { for (var a, o = t[Symbol.iterator](); !(r = (a = o.next()).done) && (i.push(a.value), !e || i.length !== e); r = !0); } catch (t) { n = !0, s = t } finally { try { r || null == o.return || o.return() } finally { if (n) throw s } } return i }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() } function u(t) { return function (t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++)i[e] = t[e]; return i } }(t) || function (t) { if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t) }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance") }() } var t = 1, e = {}, d = { attr: function (t, e, i) { var r, n, s, a = new RegExp("^" + e, "i"); if (void 0 === i) i = {}; else for (r in i) i.hasOwnProperty(r) && delete i[r]; if (!t) return i; for (r = (s = t.attributes).length; r--;)(n = s[r]) && n.specified && a.test(n.name) && (i[this.camelize(n.name.slice(e.length))] = this.deserializeValue(n.value)); return i }, checkAttr: function (t, e, i) { return t.hasAttribute(e + i) }, setAttr: function (t, e, i, r) { t.setAttribute(this.dasherize(e + i), String(r)) }, getType: function (t) { return t.getAttribute("type") || "text" }, generateID: function () { return "" + t++ }, deserializeValue: function (e) { var t; try { return e ? "true" == e || "false" != e && ("null" == e ? null : isNaN(t = Number(e)) ? /^[\[\{]/.test(e) ? JSON.parse(e) : e : t) : e } catch (t) { return e } }, camelize: function (t) { return t.replace(/-+(.)?/g, function (t, e) { return e ? e.toUpperCase() : "" }) }, dasherize: function (t) { return t.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase() }, warn: function () { var t; window.console && "function" == typeof window.console.warn && (t = window.console).warn.apply(t, arguments) }, warnOnce: function (t) { e[t] || (e[t] = !0, this.warn.apply(this, arguments)) }, _resetWarnings: function () { e = {} }, trimString: function (t) { return t.replace(/^\s+|\s+$/g, "") }, parse: { date: function (t) { var e = t.match(/^(\d{4,})-(\d\d)-(\d\d)$/); if (!e) return null; var i = o(e.map(function (t) { return parseInt(t, 10) }), 4), r = (i[0], i[1]), n = i[2], s = i[3], a = new Date(r, n - 1, s); return a.getFullYear() !== r || a.getMonth() + 1 !== n || a.getDate() !== s ? null : a }, string: function (t) { return t }, integer: function (t) { return isNaN(t) ? null : parseInt(t, 10) }, number: function (t) { if (isNaN(t)) throw null; return parseFloat(t) }, boolean: function (t) { return !/^\s*false\s*$/i.test(t) }, object: function (t) { return d.deserializeValue(t) }, regexp: function (t) { var e = ""; return t = /^\/.*\/(?:[gimy]*)$/.test(t) ? (e = t.replace(/.*\/([gimy]*)$/, "$1"), t.replace(new RegExp("^/(.*?)/" + e + "$"), "$1")) : "^" + t + "$", new RegExp(t, e) } }, parseRequirement: function (t, e) { var i = this.parse[t || "string"]; if (!i) throw 'Unknown requirement specification: "' + t + '"'; var r = i(e); if (null === r) throw "Requirement is not a ".concat(t, ': "').concat(e, '"'); return r }, namespaceEvents: function (t, e) { return (t = this.trimString(t || "").split(/\s+/))[0] ? h.map(t, function (t) { return "".concat(t, ".").concat(e) }).join(" ") : "" }, difference: function (t, i) { var r = []; return h.each(t, function (t, e) { -1 == i.indexOf(e) && r.push(e) }), r }, all: function (t) { return h.when.apply(h, u(t).concat([42, 42])) }, objectCreate: Object.create || function (t) { if (1 < arguments.length) throw Error("Second argument not supported"); if ("object" != n(t)) throw TypeError("Argument must be an object"); i.prototype = t; var e = new i; return i.prototype = null, e }, _SubmitSelector: 'input[type="submit"], button:submit' }; function i() { } function r() { this.__id__ = d.generateID() } var s = { namespace: "data-parsley-", inputs: "input, textarea, select", excluded: "input[type=button], input[type=submit], input[type=reset], input[type=hidden]", priorityEnabled: !0, multiple: null, group: null, uiEnabled: !0, validationThreshold: 3, focus: "first", trigger: !1, triggerAfterFailure: "input", errorClass: "parsley-error", successClass: "parsley-success", classHandler: function () { }, errorsContainer: function () { }, errorsWrapper: '<ul class="parsley-errors-list"></ul>', errorTemplate: "<li></li>" }; r.prototype = { asyncSupport: !0, _pipeAccordingToValidationResult: function () { function t() { var t = h.Deferred(); return !0 !== e.validationResult && t.reject(), t.resolve().promise() } var e = this; return [t, t] }, actualizeOptions: function () { return d.attr(this.element, this.options.namespace, this.domOptions), this.parent && this.parent.actualizeOptions && this.parent.actualizeOptions(), this }, _resetOptions: function (t) { for (var e in this.domOptions = d.objectCreate(this.parent.options), this.options = d.objectCreate(this.domOptions), t) t.hasOwnProperty(e) && (this.options[e] = t[e]); this.actualizeOptions() }, _listeners: null, on: function (t, e) { return this._listeners = this._listeners || {}, (this._listeners[t] = this._listeners[t] || []).push(e), this }, subscribe: function (t, e) { h.listenTo(this, t.toLowerCase(), e) }, off: function (t, e) { var i = this._listeners && this._listeners[t]; if (i) if (e) for (var r = i.length; r--;)i[r] === e && i.splice(r, 1); else delete this._listeners[t]; return this }, unsubscribe: function (t) { h.unsubscribeTo(this, t.toLowerCase()) }, trigger: function (t, e, i) { e = e || this; var r, n = this._listeners && this._listeners[t]; if (n) for (var s = n.length; s--;)if (!1 === (r = n[s].call(e, e, i))) return r; return !this.parent || this.parent.trigger(t, e, i) }, asyncIsValid: function (t, e) { return d.warnOnce("asyncIsValid is deprecated; please use whenValid instead"), this.whenValid({ group: t, force: e }) }, _findRelated: function () { return this.options.multiple ? h(this.parent.element.querySelectorAll("[".concat(this.options.namespace, 'multiple="').concat(this.options.multiple, '"]'))) : this.$element } }; function c(t) { h.extend(!0, this, t) } c.prototype = { validate: function (t, e) { if (this.fn) return 3 < arguments.length && (e = [].slice.call(arguments, 1, -1)), this.fn(t, e); if (Array.isArray(t)) { if (!this.validateMultiple) throw "Validator `" + this.name + "` does not handle multiple values"; return this.validateMultiple.apply(this, arguments) } var i = arguments[arguments.length - 1]; if (this.validateDate && i._isDateInput()) return arguments[0] = d.parse.date(arguments[0]), null !== arguments[0] && this.validateDate.apply(this, arguments); if (this.validateNumber) return !t || !isNaN(t) && (arguments[0] = parseFloat(arguments[0]), this.validateNumber.apply(this, arguments)); if (this.validateString) return this.validateString.apply(this, arguments); throw "Validator `" + this.name + "` only handles multiple values" }, parseRequirements: function (t, e) { if ("string" != typeof t) return Array.isArray(t) ? t : [t]; var i = this.requirementType; if (Array.isArray(i)) { for (var r = function (t, e) { var i = t.match(/^\s*\[(.*)\]\s*$/); if (!i) throw 'Requirement is not an array: "' + t + '"'; var r = i[1].split(",").map(d.trimString); if (r.length !== e) throw "Requirement has " + r.length + " values when " + e + " are needed"; return r }(t, i.length), n = 0; n < r.length; n++)r[n] = d.parseRequirement(i[n], r[n]); return r } return h.isPlainObject(i) ? function (t, e, i) { var r = null, n = {}; for (var s in t) if (s) { var a = i(s); "string" == typeof a && (a = d.parseRequirement(t[s], a)), n[s] = a } else r = d.parseRequirement(t[s], e); return [r, n] }(i, t, e) : [d.parseRequirement(i, t)] }, requirementType: "string", priority: 2 }; function a(t, e) { this.__class__ = "ValidatorRegistry", this.locale = "en", this.init(t || {}, e || {}) } var p = { email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))$/, number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i, integer: /^-?\d+$/, digits: /^\d+$/, alphanum: /^\w+$/i, date: { test: function (t) { return null !== d.parse.date(t) } }, url: new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$") }; p.range = p.number; function f(t) { var e = ("" + t).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/); return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0 } function m(s, a) { return function (t) { for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), r = 1; r < e; r++)i[r - 1] = arguments[r]; return i.pop(), a.apply(void 0, [t].concat(u((n = s, i.map(d.parse[n]))))); var n } } function g(t) { return { validateDate: m("date", t), validateNumber: m("number", t), requirementType: t.length <= 2 ? "string" : ["string", "string"], priority: 30 } } a.prototype = { init: function (t, e) { for (var i in this.catalog = e, this.validators = l({}, this.validators), t) this.addValidator(i, t[i].fn, t[i].priority); window.Parsley.trigger("parsley:validator:init") }, setLocale: function (t) { if (void 0 === this.catalog[t]) throw new Error(t + " is not available in the catalog"); return this.locale = t, this }, addCatalog: function (t, e, i) { return "object" === n(e) && (this.catalog[t] = e), !0 === i ? this.setLocale(t) : this }, addMessage: function (t, e, i) { return void 0 === this.catalog[t] && (this.catalog[t] = {}), this.catalog[t][e] = i, this }, addMessages: function (t, e) { for (var i in e) this.addMessage(t, i, e[i]); return this }, addValidator: function (t, e, i) { if (this.validators[t]) d.warn('Validator "' + t + '" is already defined.'); else if (s.hasOwnProperty(t)) return void d.warn('"' + t + '" is a restricted keyword and is not a valid validator name.'); return this._setValidator.apply(this, arguments) }, hasValidator: function (t) { return !!this.validators[t] }, updateValidator: function (t, e, i) { return this.validators[t] ? this._setValidator.apply(this, arguments) : (d.warn('Validator "' + t + '" is not already defined.'), this.addValidator.apply(this, arguments)) }, removeValidator: function (t) { return this.validators[t] || d.warn('Validator "' + t + '" is not defined.'), delete this.validators[t], this }, _setValidator: function (t, e, i) { for (var r in "object" !== n(e) && (e = { fn: e, priority: i }), e.validate || (e = new c(e)), (this.validators[t] = e).messages || {}) this.addMessage(r, t, e.messages[r]); return this }, getErrorMessage: function (t) { var e; "type" === t.name ? e = (this.catalog[this.locale][t.name] || {})[t.requirements] : e = this.formatMessage(this.catalog[this.locale][t.name], t.requirements); return e || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage }, formatMessage: function (t, e) { if ("object" !== n(e)) return "string" == typeof t ? t.replace(/%s/i, e) : ""; for (var i in e) t = this.formatMessage(t, e[i]); return t }, validators: { notblank: { validateString: function (t) { return /\S/.test(t) }, priority: 2 }, required: { validateMultiple: function (t) { return 0 < t.length }, validateString: function (t) { return /\S/.test(t) }, priority: 512 }, type: { validateString: function (t, e, i) { var r = 2 < arguments.length && void 0 !== i ? i : {}, n = r.step, s = void 0 === n ? "any" : n, a = r.base, o = void 0 === a ? 0 : a, l = p[e]; if (!l) throw new Error("validator type `" + e + "` is not supported"); if (!t) return !0; if (!l.test(t)) return !1; if ("number" === e && !/^any$/i.test(s || "")) { var u = Number(t), d = Math.max(f(s), f(o)); if (f(u) > d) return !1; var h = function (t) { return Math.round(t * Math.pow(10, d)) }; if ((h(u) - h(o)) % h(s) != 0) return !1 } return !0 }, requirementType: { "": "string", step: "string", base: "number" }, priority: 256 }, pattern: { validateString: function (t, e) { return !t || e.test(t) }, requirementType: "regexp", priority: 64 }, minlength: { validateString: function (t, e) { return !t || t.length >= e }, requirementType: "integer", priority: 30 }, maxlength: { validateString: function (t, e) { return t.length <= e }, requirementType: "integer", priority: 30 }, length: { validateString: function (t, e, i) { return !t || t.length >= e && t.length <= i }, requirementType: ["integer", "integer"], priority: 30 }, mincheck: { validateMultiple: function (t, e) { return t.length >= e }, requirementType: "integer", priority: 30 }, maxcheck: { validateMultiple: function (t, e) { return t.length <= e }, requirementType: "integer", priority: 30 }, check: { validateMultiple: function (t, e, i) { return t.length >= e && t.length <= i }, requirementType: ["integer", "integer"], priority: 30 }, min: g(function (t, e) { return e <= t }), max: g(function (t, e) { return t <= e }), range: g(function (t, e, i) { return e <= t && t <= i }), equalto: { validateString: function (t, e) { if (!t) return !0; var i = h(e); return i.length ? t === i.val() : t === e }, priority: 256 }, euvatin: { validateString: function (t) { if (!t) return !0; return /^[A-Z][A-Z][A-Za-z0-9 -]{2,}$/.test(t) }, priority: 30 } } }; var v = {}; v.Form = { _actualizeTriggers: function () { var e = this; this.$element.on("submit.Parsley", function (t) { e.onSubmitValidate(t) }), this.$element.on("click.Parsley", d._SubmitSelector, function (t) { e.onSubmitButton(t) }), !1 !== this.options.uiEnabled && this.element.setAttribute("novalidate", "") }, focus: function () { if (!(this._focusedField = null) === this.validationResult || "none" === this.options.focus) return null; for (var t = 0; t < this.fields.length; t++) { var e = this.fields[t]; if (!0 !== e.validationResult && 0 < e.validationResult.length && void 0 === e.options.noFocus && (this._focusedField = e.$element, "first" === this.options.focus)) break } return null === this._focusedField ? null : this._focusedField.focus() }, _destroyUI: function () { this.$element.off(".Parsley") } }, v.Field = { _reflowUI: function () { if (this._buildUI(), this._ui) { var t = function t(e, i, r) { for (var n = [], s = [], a = 0; a < e.length; a++) { for (var o = !1, l = 0; l < i.length; l++)if (e[a].assert.name === i[l].assert.name) { o = !0; break } o ? s.push(e[a]) : n.push(e[a]) } return { kept: s, added: n, removed: r ? [] : t(i, e, !0).added } }(this.validationResult, this._ui.lastValidationResult); this._ui.lastValidationResult = this.validationResult, this._manageStatusClass(), this._manageErrorsMessages(t), this._actualizeTriggers(), !t.kept.length && !t.added.length || this._failedOnce || (this._failedOnce = !0, this._actualizeTriggers()) } }, getErrorsMessages: function () { if (!0 === this.validationResult) return []; for (var t = [], e = 0; e < this.validationResult.length; e++)t.push(this.validationResult[e].errorMessage || this._getErrorMessage(this.validationResult[e].assert)); return t }, addError: function (t, e) { var i = 1 < arguments.length && void 0 !== e ? e : {}, r = i.message, n = i.assert, s = i.updateClass, a = void 0 === s || s; this._buildUI(), this._addError(t, { message: r, assert: n }), a && this._errorClass() }, updateError: function (t, e) { var i = 1 < arguments.length && void 0 !== e ? e : {}, r = i.message, n = i.assert, s = i.updateClass, a = void 0 === s || s; this._buildUI(), this._updateError(t, { message: r, assert: n }), a && this._errorClass() }, removeError: function (t, e) { var i = (1 < arguments.length && void 0 !== e ? e : {}).updateClass, r = void 0 === i || i; this._buildUI(), this._removeError(t), r && this._manageStatusClass() }, _manageStatusClass: function () { this.hasConstraints() && this.needsValidation() && !0 === this.validationResult ? this._successClass() : 0 < this.validationResult.length ? this._errorClass() : this._resetClass() }, _manageErrorsMessages: function (t) { if (void 0 === this.options.errorsMessagesDisabled) { if (void 0 !== this.options.errorMessage) return t.added.length || t.kept.length ? (this._insertErrorWrapper(), 0 === this._ui.$errorsWrapper.find(".parsley-custom-error-message").length && this._ui.$errorsWrapper.append(h(this.options.errorTemplate).addClass("parsley-custom-error-message")), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").find(".parsley-custom-error-message").html(this.options.errorMessage)) : (this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-custom-error-message").remove()); for (var e = 0; e < t.removed.length; e++)this._removeError(t.removed[e].assert.name); for (e = 0; e < t.added.length; e++)this._addError(t.added[e].assert.name, { message: t.added[e].errorMessage, assert: t.added[e].assert }); for (e = 0; e < t.kept.length; e++)this._updateError(t.kept[e].assert.name, { message: t.kept[e].errorMessage, assert: t.kept[e].assert }) } }, _addError: function (t, e) { var i = e.message, r = e.assert; this._insertErrorWrapper(), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").append(h(this.options.errorTemplate).addClass("parsley-" + t).html(i || this._getErrorMessage(r))) }, _updateError: function (t, e) { var i = e.message, r = e.assert; this._ui.$errorsWrapper.addClass("filled").find(".parsley-" + t).html(i || this._getErrorMessage(r)) }, _removeError: function (t) { this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-" + t).remove() }, _getErrorMessage: function (t) { var e = t.name + "Message"; return void 0 !== this.options[e] ? window.Parsley.formatMessage(this.options[e], t.requirements) : window.Parsley.getErrorMessage(t) }, _buildUI: function () { if (!this._ui && !1 !== this.options.uiEnabled) { var t = {}; this.element.setAttribute(this.options.namespace + "id", this.__id__), t.$errorClassHandler = this._manageClassHandler(), t.errorsWrapperId = "parsley-id-" + (this.options.multiple ? "multiple-" + this.options.multiple : this.__id__), t.$errorsWrapper = h(this.options.errorsWrapper).attr("id", t.errorsWrapperId), t.lastValidationResult = [], t.validationInformationVisible = !1, this._ui = t } }, _manageClassHandler: function () { if ("string" == typeof this.options.classHandler && h(this.options.classHandler).length) return h(this.options.classHandler); var t = this.options.classHandler; if ("string" == typeof this.options.classHandler && "function" == typeof window[this.options.classHandler] && (t = window[this.options.classHandler]), "function" == typeof t) { var e = t.call(this, this); if (void 0 !== e && e.length) return e } else { if ("object" === n(t) && t instanceof jQuery && t.length) return t; t && d.warn("The class handler `" + t + "` does not exist in DOM nor as a global JS function") } return this._inputHolder() }, _inputHolder: function () { return this.options.multiple && "SELECT" !== this.element.nodeName ? this.$element.parent() : this.$element }, _insertErrorWrapper: function () { var t = this.options.errorsContainer; if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent(); if ("string" == typeof t) { if (h(t).length) return h(t).append(this._ui.$errorsWrapper); "function" == typeof window[t] ? t = window[t] : d.warn("The errors container `" + t + "` does not exist in DOM nor as a global JS function") } return "function" == typeof t && (t = t.call(this, this)), "object" === n(t) && t.length ? t.append(this._ui.$errorsWrapper) : this._inputHolder().after(this._ui.$errorsWrapper) }, _actualizeTriggers: function () { var t, e = this, i = this._findRelated(); i.off(".Parsley"), this._failedOnce ? i.on(d.namespaceEvents(this.options.triggerAfterFailure, "Parsley"), function () { e._validateIfNeeded() }) : (t = d.namespaceEvents(this.options.trigger, "Parsley")) && i.on(t, function (t) { e._validateIfNeeded(t) }) }, _validateIfNeeded: function (t) { var e = this; t && /key|input/.test(t.type) && (!this._ui || !this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold || (this.options.debounce ? (window.clearTimeout(this._debounced), this._debounced = window.setTimeout(function () { return e.validate() }, this.options.debounce)) : this.validate()) }, _resetUI: function () { this._failedOnce = !1, this._actualizeTriggers(), void 0 !== this._ui && (this._ui.$errorsWrapper.removeClass("filled").children().remove(), this._resetClass(), this._ui.lastValidationResult = [], this._ui.validationInformationVisible = !1) }, _destroyUI: function () { this._resetUI(), void 0 !== this._ui && this._ui.$errorsWrapper.remove(), delete this._ui }, _successClass: function () { this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass) }, _errorClass: function () { this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass) }, _resetClass: function () { this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass) } }; function y(t, e, i) { this.__class__ = "Form", this.element = t, this.$element = h(t), this.domOptions = e, this.options = i, this.parent = window.Parsley, this.fields = [], this.validationResult = null } var _ = { pending: null, resolved: !0, rejected: !1 }; y.prototype = { onSubmitValidate: function (t) { var e = this; if (!0 !== t.parsley) { var i = this._submitSource || this.$element.find(d._SubmitSelector)[0]; if (this._submitSource = null, this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !0), !i || null === i.getAttribute("formnovalidate")) { window.Parsley._remoteCache = {}; var r = this.whenValidate({ event: t }); "resolved" === r.state() && !1 !== this._trigger("submit") || (t.stopImmediatePropagation(), t.preventDefault(), "pending" === r.state() && r.done(function () { e._submit(i) })) } } }, onSubmitButton: function (t) { this._submitSource = t.currentTarget }, _submit: function (t) { if (!1 !== this._trigger("submit")) { if (t) { var e = this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !1); 0 === e.length && (e = h('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element)), e.attr({ name: t.getAttribute("name"), value: t.getAttribute("value") }) } this.$element.trigger(l(h.Event("submit"), { parsley: !0 })) } }, validate: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { group: e[0], force: e[1], event: e[2] } } return _[this.whenValidate(t).state()] }, whenValidate: function (t) { var e, i = this, r = 0 < arguments.length && void 0 !== t ? t : {}, n = r.group, s = r.force, a = r.event; (this.submitEvent = a) && (this.submitEvent = l({}, a, { preventDefault: function () { d.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`"), i.validationResult = !1 } })), this.validationResult = !0, this._trigger("validate"), this._refreshFields(); var o = this._withoutReactualizingFormOptions(function () { return h.map(i.fields, function (t) { return t.whenValidate({ force: s, group: n }) }) }); return (e = d.all(o).done(function () { i._trigger("success") }).fail(function () { i.validationResult = !1, i.focus(), i._trigger("error") }).always(function () { i._trigger("validated") })).pipe.apply(e, u(this._pipeAccordingToValidationResult())) }, isValid: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { group: e[0], force: e[1] } } return _[this.whenValid(t).state()] }, whenValid: function (t) { var e = this, i = 0 < arguments.length && void 0 !== t ? t : {}, r = i.group, n = i.force; this._refreshFields(); var s = this._withoutReactualizingFormOptions(function () { return h.map(e.fields, function (t) { return t.whenValid({ group: r, force: n }) }) }); return d.all(s) }, refresh: function () { return this._refreshFields(), this }, reset: function () { for (var t = 0; t < this.fields.length; t++)this.fields[t].reset(); this._trigger("reset") }, destroy: function () { this._destroyUI(); for (var t = 0; t < this.fields.length; t++)this.fields[t].destroy(); this.$element.removeData("Parsley"), this._trigger("destroy") }, _refreshFields: function () { return this.actualizeOptions()._bindFields() }, _bindFields: function () { var n = this, t = this.fields; return this.fields = [], this.fieldsMappedById = {}, this._withoutReactualizingFormOptions(function () { n.$element.find(n.options.inputs).not(n.options.excluded).not("[".concat(n.options.namespace, "excluded=true]")).each(function (t, e) { var i = new window.Parsley.Factory(e, {}, n); if ("Field" === i.__class__ || "FieldMultiple" === i.__class__) { var r = i.__class__ + "-" + i.__id__; void 0 === n.fieldsMappedById[r] && (n.fieldsMappedById[r] = i, n.fields.push(i)) } }), h.each(d.difference(t, n.fields), function (t, e) { e.reset() }) }), this }, _withoutReactualizingFormOptions: function (t) { var e = this.actualizeOptions; this.actualizeOptions = function () { return this }; var i = t(); return this.actualizeOptions = e, i }, _trigger: function (t) { return this.trigger("form:" + t) } }; function b(t, e, i, r, n) { var s = window.Parsley._validatorRegistry.validators[e], a = new c(s); l(this, { validator: a, name: e, requirements: i, priority: r = r || t.options[e + "Priority"] || a.priority, isDomConstraint: n = !0 === n }), this._parseRequirements(t.options) } function w(t, e, i, r) { this.__class__ = "Field", this.element = t, this.$element = h(t), void 0 !== r && (this.parent = r), this.options = i, this.domOptions = e, this.constraints = [], this.constraintsByName = {}, this.validationResult = !0, this._bindConstraints() } var F = { pending: null, resolved: !0, rejected: !(b.prototype = { validate: function (t, e) { var i; return (i = this.validator).validate.apply(i, [t].concat(u(this.requirementList), [e])) }, _parseRequirements: function (i) { var r = this; this.requirementList = this.validator.parseRequirements(this.requirements, function (t) { return i[r.name + ((e = t)[0].toUpperCase() + e.slice(1))]; var e }) } }) }; w.prototype = { validate: function (t) { 1 <= arguments.length && !h.isPlainObject(t) && (d.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated."), t = { options: t }); var e = this.whenValidate(t); if (!e) return !0; switch (e.state()) { case "pending": return null; case "resolved": return !0; case "rejected": return this.validationResult } }, whenValidate: function (t) { var e, i = this, r = 0 < arguments.length && void 0 !== t ? t : {}, n = r.force, s = r.group; if (this.refresh(), !s || this._isInGroup(s)) return this.value = this.getValue(), this._trigger("validate"), (e = this.whenValid({ force: n, value: this.value, _refreshed: !0 }).always(function () { i._reflowUI() }).done(function () { i._trigger("success") }).fail(function () { i._trigger("error") }).always(function () { i._trigger("validated") })).pipe.apply(e, u(this._pipeAccordingToValidationResult())) }, hasConstraints: function () { return 0 !== this.constraints.length }, needsValidation: function (t) { return void 0 === t && (t = this.getValue()), !(!t.length && !this._isRequired() && void 0 === this.options.validateIfEmpty) }, _isInGroup: function (t) { return Array.isArray(this.options.group) ? -1 !== h.inArray(t, this.options.group) : this.options.group === t }, isValid: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { force: e[0], value: e[1] } } var i = this.whenValid(t); return !i || F[i.state()] }, whenValid: function (t) { var r = this, e = 0 < arguments.length && void 0 !== t ? t : {}, i = e.force, n = void 0 !== i && i, s = e.value, a = e.group; if (e._refreshed || this.refresh(), !a || this._isInGroup(a)) { if (this.validationResult = !0, !this.hasConstraints()) return h.when(); if (null == s && (s = this.getValue()), !this.needsValidation(s) && !0 !== n) return h.when(); var o = this._getGroupedConstraints(), l = []; return h.each(o, function (t, e) { var i = d.all(h.map(e, function (t) { return r._validateConstraint(s, t) })); if (l.push(i), "rejected" === i.state()) return !1 }), d.all(l) } }, _validateConstraint: function (t, e) { var i = this, r = e.validate(t, this); return !1 === r && (r = h.Deferred().reject()), d.all([r]).fail(function (t) { i.validationResult instanceof Array || (i.validationResult = []), i.validationResult.push({ assert: e, errorMessage: "string" == typeof t && t }) }) }, getValue: function () { var t; return null == (t = "function" == typeof this.options.value ? this.options.value(this) : void 0 !== this.options.value ? this.options.value : this.$element.val()) ? "" : this._handleWhitespace(t) }, reset: function () { return this._resetUI(), this._trigger("reset") }, destroy: function () { this._destroyUI(), this.$element.removeData("Parsley"), this.$element.removeData("FieldMultiple"), this._trigger("destroy") }, refresh: function () { return this._refreshConstraints(), this }, _refreshConstraints: function () { return this.actualizeOptions()._bindConstraints() }, refreshConstraints: function () { return d.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh"), this.refresh() }, addConstraint: function (t, e, i, r) { if (window.Parsley._validatorRegistry.validators[t]) { var n = new b(this, t, e, i, r); "undefined" !== this.constraintsByName[n.name] && this.removeConstraint(n.name), this.constraints.push(n), this.constraintsByName[n.name] = n } return this }, removeConstraint: function (t) { for (var e = 0; e < this.constraints.length; e++)if (t === this.constraints[e].name) { this.constraints.splice(e, 1); break } return delete this.constraintsByName[t], this }, updateConstraint: function (t, e, i) { return this.removeConstraint(t).addConstraint(t, e, i) }, _bindConstraints: function () { for (var t = [], e = {}, i = 0; i < this.constraints.length; i++)!1 === this.constraints[i].isDomConstraint && (t.push(this.constraints[i]), e[this.constraints[i].name] = this.constraints[i]); for (var r in this.constraints = t, this.constraintsByName = e, this.options) this.addConstraint(r, this.options[r], void 0, !0); return this._bindHtml5Constraints() }, _bindHtml5Constraints: function () { null !== this.element.getAttribute("required") && this.addConstraint("required", !0, void 0, !0), null !== this.element.getAttribute("pattern") && this.addConstraint("pattern", this.element.getAttribute("pattern"), void 0, !0); var t = this.element.getAttribute("min"), e = this.element.getAttribute("max"); null !== t && null !== e ? this.addConstraint("range", [t, e], void 0, !0) : null !== t ? this.addConstraint("min", t, void 0, !0) : null !== e && this.addConstraint("max", e, void 0, !0), null !== this.element.getAttribute("minlength") && null !== this.element.getAttribute("maxlength") ? this.addConstraint("length", [this.element.getAttribute("minlength"), this.element.getAttribute("maxlength")], void 0, !0) : null !== this.element.getAttribute("minlength") ? this.addConstraint("minlength", this.element.getAttribute("minlength"), void 0, !0) : null !== this.element.getAttribute("maxlength") && this.addConstraint("maxlength", this.element.getAttribute("maxlength"), void 0, !0); var i = d.getType(this.element); return "number" === i ? this.addConstraint("type", ["number", { step: this.element.getAttribute("step") || "1", base: t || this.element.getAttribute("value") }], void 0, !0) : /^(email|url|range|date)$/i.test(i) ? this.addConstraint("type", i, void 0, !0) : this }, _isRequired: function () { return void 0 !== this.constraintsByName.required && !1 !== this.constraintsByName.required.requirements }, _trigger: function (t) { return this.trigger("field:" + t) }, _handleWhitespace: function (t) { return !0 === this.options.trimValue && d.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"'), "squish" === this.options.whitespace && (t = t.replace(/\s{2,}/g, " ")), "trim" !== this.options.whitespace && "squish" !== this.options.whitespace && !0 !== this.options.trimValue || (t = d.trimString(t)), t }, _isDateInput: function () { var t = this.constraintsByName.type; return t && "date" === t.requirements }, _getGroupedConstraints: function () { if (!1 === this.options.priorityEnabled) return [this.constraints]; for (var t = [], e = {}, i = 0; i < this.constraints.length; i++) { var r = this.constraints[i].priority; e[r] || t.push(e[r] = []), e[r].push(this.constraints[i]) } return t.sort(function (t, e) { return e[0].priority - t[0].priority }), t } }; function C() { this.__class__ = "FieldMultiple" } C.prototype = { addElement: function (t) { return this.$elements.push(t), this }, _refreshConstraints: function () { var t; if (this.constraints = [], "SELECT" === this.element.nodeName) return this.actualizeOptions()._bindConstraints(), this; for (var e = 0; e < this.$elements.length; e++)if (h("html").has(this.$elements[e]).length) { t = this.$elements[e].data("FieldMultiple")._refreshConstraints().constraints; for (var i = 0; i < t.length; i++)this.addConstraint(t[i].name, t[i].requirements, t[i].priority, t[i].isDomConstraint) } else this.$elements.splice(e, 1); return this }, getValue: function () { if ("function" == typeof this.options.value) return this.options.value(this); if (void 0 !== this.options.value) return this.options.value; if ("INPUT" === this.element.nodeName) { var t = d.getType(this.element); if ("radio" === t) return this._findRelated().filter(":checked").val() || ""; if ("checkbox" === t) { var e = []; return this._findRelated().filter(":checked").each(function () { e.push(h(this).val()) }), e } } return "SELECT" === this.element.nodeName && null === this.$element.val() ? [] : this.$element.val() }, _init: function () { return this.$elements = [this.$element], this } }; function A(t, e, i) { this.element = t, this.$element = h(t); var r = this.$element.data("Parsley"); if (r) return void 0 !== i && r.parent === window.Parsley && (r.parent = i, r._resetOptions(r.options)), "object" === n(e) && l(r.options, e), r; if (!this.$element.length) throw new Error("You must bind Parsley on an existing element."); if (void 0 !== i && "Form" !== i.__class__) throw new Error("Parent instance must be a Form instance"); return this.parent = i || window.Parsley, this.init(e) } A.prototype = { init: function (t) { return this.__class__ = "Parsley", this.__version__ = "2.9.2", this.__id__ = d.generateID(), this._resetOptions(t), "FORM" === this.element.nodeName || d.checkAttr(this.element, this.options.namespace, "validate") && !this.$element.is(this.options.inputs) ? this.bind("parsleyForm") : this.isMultiple() ? this.handleMultiple() : this.bind("parsleyField") }, isMultiple: function () { var t = d.getType(this.element); return "radio" === t || "checkbox" === t || "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple") }, handleMultiple: function () { var t, e, r = this; if (this.options.multiple = this.options.multiple || (t = this.element.getAttribute("name")) || this.element.getAttribute("id"), "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")) return this.options.multiple = this.options.multiple || this.__id__, this.bind("parsleyFieldMultiple"); if (!this.options.multiple) return d.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.", this.$element), this; this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ""), t && h('input[name="' + t + '"]').each(function (t, e) { var i = d.getType(e); "radio" !== i && "checkbox" !== i || e.setAttribute(r.options.namespace + "multiple", r.options.multiple) }); for (var i = this._findRelated(), n = 0; n < i.length; n++)if (void 0 !== (e = h(i.get(n)).data("Parsley"))) { this.$element.data("FieldMultiple") || e.addElement(this.$element); break } return this.bind("parsleyField", !0), e || this.bind("parsleyFieldMultiple") }, bind: function (t, e) { var i; switch (t) { case "parsleyForm": i = h.extend(new y(this.element, this.domOptions, this.options), new r, window.ParsleyExtend)._bindFields(); break; case "parsleyField": i = h.extend(new w(this.element, this.domOptions, this.options, this.parent), new r, window.ParsleyExtend); break; case "parsleyFieldMultiple": i = h.extend(new w(this.element, this.domOptions, this.options, this.parent), new C, new r, window.ParsleyExtend)._init(); break; default: throw new Error(t + "is not a supported Parsley type") }return this.options.multiple && d.setAttr(this.element, this.options.namespace, "multiple", this.options.multiple), void 0 !== e ? this.$element.data("FieldMultiple", i) : (this.$element.data("Parsley", i), i._actualizeTriggers(), i._trigger("init")), i } }; var E = h.fn.jquery.split("."); if (parseInt(E[0]) <= 1 && parseInt(E[1]) < 8) throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better."; E.forEach || d.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim"); var x = l(new r, { element: document, $element: h(document), actualizeOptions: null, _resetOptions: null, Factory: A, version: "2.9.2" }); l(w.prototype, v.Field, r.prototype), l(y.prototype, v.Form, r.prototype), l(A.prototype, r.prototype), h.fn.parsley = h.fn.psly = function (t) { if (1 < this.length) { var e = []; return this.each(function () { e.push(h(this).parsley(t)) }), e } if (0 != this.length) return new A(this[0], t) }, void 0 === window.ParsleyExtend && (window.ParsleyExtend = {}), x.options = l(d.objectCreate(s), window.ParsleyConfig), window.ParsleyConfig = x.options, window.Parsley = window.psly = x, x.Utils = d, window.ParsleyUtils = {}, h.each(d, function (t, e) { "function" == typeof e && (window.ParsleyUtils[t] = function () { return d.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead."), d[t].apply(d, arguments) }) }); var $ = window.Parsley._validatorRegistry = new a(window.ParsleyConfig.validators, window.ParsleyConfig.i18n); window.ParsleyValidator = {}, h.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator".split(" "), function (t, e) { window.Parsley[e] = function () { return $[e].apply($, arguments) }, window.ParsleyValidator[e] = function () { var t; return d.warnOnce("Accessing the method '".concat(e, "' through Validator is deprecated. Simply call 'window.Parsley.").concat(e, "(...)'")), (t = window.Parsley)[e].apply(t, arguments) } }), window.Parsley.UI = v, window.ParsleyUI = { removeError: function (t, e, i) { var r = !0 !== i; return d.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method."), t.removeError(e, { updateClass: r }) }, getErrorsMessages: function (t) { return d.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly."), t.getErrorsMessages() } }, h.each("addError updateError".split(" "), function (t, a) { window.ParsleyUI[a] = function (t, e, i, r, n) { var s = !0 !== n; return d.warnOnce("Accessing UI is deprecated. Call '".concat(a, "' on the instance directly. Please comment in issue 1073 as to your need to call this method.")), t[a](e, { message: i, assert: r, updateClass: s }) } }), !1 !== window.ParsleyConfig.autoBind && h(function () { h("[data-parsley-validate]").length && h("[data-parsley-validate]").parsley() }); function V() { d.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley") } var P = h({}); function O(e, i) { return e.parsleyAdaptedCallback || (e.parsleyAdaptedCallback = function () { var t = Array.prototype.slice.call(arguments, 0); t.unshift(this), e.apply(i || P, t) }), e.parsleyAdaptedCallback } var T = "parsley:"; function M(t) { return 0 === t.lastIndexOf(T, 0) ? t.substr(T.length) : t } return h.listen = function (t, e) { var i; if (V(), "object" === n(arguments[1]) && "function" == typeof arguments[2] && (i = arguments[1], e = arguments[2]), "function" != typeof e) throw new Error("Wrong parameters"); window.Parsley.on(M(t), O(e, i)) }, h.listenTo = function (t, e, i) { if (V(), !(t instanceof w || t instanceof y)) throw new Error("Must give Parsley instance"); if ("string" != typeof e || "function" != typeof i) throw new Error("Wrong parameters"); t.on(M(e), O(i)) }, h.unsubscribe = function (t, e) { if (V(), "string" != typeof t || "function" != typeof e) throw new Error("Wrong arguments"); window.Parsley.off(M(t), e.parsleyAdaptedCallback) }, h.unsubscribeTo = function (t, e) { if (V(), !(t instanceof w || t instanceof y)) throw new Error("Must give Parsley instance"); t.off(M(e)) }, h.unsubscribeAll = function (e) { V(), window.Parsley.off(M(e)), h("form,input,textarea,select").each(function () { var t = h(this).data("Parsley"); t && t.off(M(e)) }) }, h.emit = function (t, e) { V(); var i = e instanceof w || e instanceof y, r = Array.prototype.slice.call(arguments, i ? 2 : 1); r.unshift(M(t)), i || (e = window.Parsley), e.trigger.apply(e, u(r)) }, h.extend(!0, x, { asyncValidators: { default: { fn: function (t) { return 200 <= t.status && t.status < 300 }, url: !1 }, reverse: { fn: function (t) { return t.status < 200 || 300 <= t.status }, url: !1 } }, addAsyncValidator: function (t, e, i, r) { return x.asyncValidators[t] = { fn: e, url: i || !1, options: r || {} }, this } }), x.addValidator("remote", { requirementType: { "": "string", validator: "string", reverse: "boolean", options: "object" }, validateString: function (t, e, i, r) { var n, s, a = {}, o = i.validator || (!0 === i.reverse ? "reverse" : "default"); if (void 0 === x.asyncValidators[o]) throw new Error("Calling an undefined async validator: `" + o + "`"); -1 < (e = x.asyncValidators[o].url || e).indexOf("{value}") ? e = e.replace("{value}", encodeURIComponent(t)) : a[r.element.getAttribute("name") || r.element.getAttribute("id")] = t; var l = h.extend(!0, i.options || {}, x.asyncValidators[o].options); n = h.extend(!0, {}, { url: e, data: a, type: "GET" }, l), r.trigger("field:ajaxoptions", r, n), s = h.param(n), void 0 === x._remoteCache && (x._remoteCache = {}); function u() { var t = x.asyncValidators[o].fn.call(r, d, e, i); return t = t || h.Deferred().reject(), h.when(t) } var d = x._remoteCache[s] = x._remoteCache[s] || h.ajax(n); return d.then(u, u) }, priority: -1 }), x.on("form:submit", function () { x._remoteCache = {} }), r.prototype.addAsyncValidator = function () { return d.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`"), x.addAsyncValidator.apply(x, arguments) }, x.addMessages("en", { defaultMessage: "This value seems to be invalid.", type: { email: "This value should be a valid email.", url: "This value should be a valid url.", number: "This value should be a valid number.", integer: "This value should be a valid integer.", digits: "This value should be digits.", alphanum: "This value should be alphanumeric." }, notblank: "This value should not be blank.", required: "This value is required.", pattern: "This value seems to be invalid.", min: "This value should be greater than or equal to %s.", max: "This value should be lower than or equal to %s.", range: "This value should be between %s and %s.", minlength: "This value is too short. It should have %s characters or more.", maxlength: "This value is too long. It should have %s characters or fewer.", length: "This value length is invalid. It should be between %s and %s characters long.", mincheck: "You must select at least %s choices.", maxcheck: "You must select %s choices or fewer.", check: "You must select between %s and %s choices.", equalto: "This value should be the same.", euvatin: "It's not a valid VAT Identification Number." }), x.setLocale("en"), (new function () { var r = this, n = window || global; l(this, { isNativeEvent: function (t) { return t.originalEvent && !1 !== t.originalEvent.isTrusted }, fakeInputEvent: function (t) { r.isNativeEvent(t) && h(t.target).trigger("input") }, misbehaves: function (t) { r.isNativeEvent(t) && (r.behavesOk(t), h(document).on("change.inputevent", t.data.selector, r.fakeInputEvent), r.fakeInputEvent(t)) }, behavesOk: function (t) { r.isNativeEvent(t) && h(document).off("input.inputevent", t.data.selector, r.behavesOk).off("change.inputevent", t.data.selector, r.misbehaves) }, install: function () { if (!n.inputEventPatched) { n.inputEventPatched = "0.0.3"; for (var t = 0, e = ["select", 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]']; t < e.length; t++) { var i = e[t]; h(document).on("input.inputevent", i, { selector: i }, r.behavesOk).on("change.inputevent", i, { selector: i }, r.misbehaves) } } }, uninstall: function () { delete n.inputEventPatched, h(document).off(".inputevent") } }) }).install(), x });
//# sourceMappingURL=parsley.min.js.map
;
define('validators/validHtml', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // A regex to find HTML tags in a string
    var htmlTagRegex = /<\/?[\w\s="/.':;#-/]+>/gi;

    // Validator to ensure sting has HTML tags & isn't malformed
    Parsley.addValidator('validHtml', {
        requirementType: 'string',
        validateString: function (html) {
            var $tmpDiv, validHtml, charCodes;

            $tmpDiv = $('<div />');

            // Decode all character codes.
            charCodes = html.match(/&.*?;/g) || [];
            $.each(charCodes, function (i, charCode) {
                html = html.replace(new RegExp(charCode, 'g'), $tmpDiv.html(charCode).html());
            });

            html = html.replace(/=""/g, '').toLowerCase();

            $tmpDiv.html(html);
            validHtml = $tmpDiv.html().toLowerCase();

            if (validHtml.length) {
                validHtml = validHtml.replace(/=""/g, '');
            }

            return !!html.match(htmlTagRegex) &&
                (html === validHtml);
        },
        messages: {
            en: 'This is not valid HTML'
        }
    });
});

define('validators/validTime', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // A regex to find HTML tags in a string
    var timeRegex = /^([0-9]|1[0-2]):[0-5][0-9](am|pm)$/;

    // Validator to ensure sting has HTML tags & isn't malformed
    Parsley.addValidator('validTime', {
        requirementType: 'string',
        validateString: function (time) {
            return timeRegex.test(time);
        },
        messages: {
            en: 'This is not a valid time'
        }
    });
});

define('validators/validSvg', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // A regex to find HTML tags in a string
    var svgTagRegex = /^<svg(.+)<\/svg>$/;

    // Validator to ensure string is valid HTML and is an SVG image
    Parsley.addValidator('validSvg', {
        requirementType: 'string',
        validateString: function (html) {
            var $tmpDiv;

            html = $.trim(html).replace(/\n/g, '');

            $tmpDiv = $('<div />');
            $tmpDiv.html(html);

            return svgTagRegex.test(html) &&
                $tmpDiv.children().length === 1 &&
                $tmpDiv.find(':first-child')[0].tagName.toLowerCase() === 'svg';
        },
        messages: {
            en: 'This is not valid SVG'
        }
    });
});

define('validators/validUrl', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // A regex to find HTML tags in a string
    var urlRegex = /^https?:\/\//i;

    // Validator to ensure string is valid HTML and is an SVG image
    Parsley.addValidator('validUrl', {
        requirementType: 'string',
        validateString: function (url) {
            return urlRegex.test(url);
        },
        messages: {
            en: 'This is not valid URL. Missing http:// or https://'
        }
    });
});

define('validators/validEmbed', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // A regex to find HTML tags in a string
    var iframeTagRegex = /^<iframe\s(.*?)<\/iframe>$/i;

    // Validator to ensure sting has HTML tags & isn't malformed
    Parsley.addValidator('validEmbed', {
        requirementType: 'string',
        validateString: function (html) {
            return iframeTagRegex.test($.trim(html));
        },
        messages: {
            en: 'Please make sure your embed code contains an &lt;iframe&gt; with a closing tag &lt;/iframe&gt;'
        }
    });
});

define('validators/validComparison', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    var parseRequirement = function (requirement) {
        if (isNaN(+requirement)) {
            return parseFloat($(requirement).val());
        } else {
            return +requirement;
        }
    };

    Parsley.addValidator('gte', {
        validateString: function (value, requirement) {
            return parseFloat(value) >= parseRequirement(requirement);
        },
        priority: 32
    });

    Parsley.addValidator('lte', {
        validateString: function (value, requirement) {
            return parseFloat(value) <= parseRequirement(requirement);
        },
        priority: 32
    });
});

define('validators/validDate', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // matches date of the form mm/dd/yyyy
    var dateRegex = /^(1[0-2]|[0]{0,1}[1-9])\/([0-2]{0,1}[0-9]|3[0-1])\/(\d{4})$/;

    // Validator to ensure string is a valid date
    Parsley.addValidator('validDate', {
        requirementType: 'string',
        validateString: function (url) {
            return dateRegex.test(url);
        },
        messages: {
            en: 'This is not a valid date'
        }
    });
});

define('validators/validPhonenumber', [
    'jquery',
    'parsley'
], function (
    $,
    Parsley
) {
    'use strict';

    // matches all conceivable international and domestic phone numbers
    // courtesy of https://github.com/googlei18n/libphonenumber
    // eslint-disable-next-line no-useless-escape
    var phoneRegex = /^[0-9---]{2}$|^[+]*(?:[-x-- ().\[\]/~*]*[0-9---]){3,}[-x-- ().\[\]/~*0-9---]*(?:;ext=([0-9---]{1,7})|[  \t,]*(?:e?xt(?:ensi(?:?|))?n?|??|[;,x#~]|int|anexo|)[:\.]?[  \t,-]*([0-9---]{1,7})#?|[- ]+([0-9---]{1,5})#)?$/i;

    // Validator to ensure string is a valid phone number
    Parsley.addValidator('validPhonenumber', {
        requirementType: 'string',
        validateString: function (phoneNumber) {
            return phoneRegex.test(phoneNumber);
        },
        messages: {
            en: 'Not a valid phone number'
        }
    });
});

define('factories/validatorFactory', [
    'jquery',

    // Non module returning includes
    'parsley',
    'validators/validHtml',
    'validators/validTime',
    'validators/validSvg',
    'validators/validUrl',
    'validators/validEmbed',
    'validators/validComparison',
    'validators/validDate',
    'validators/validPhonenumber'
], function (
    $
) {
    'use strict';
    /*
        Validator Factory
        ================
    */

    var validatorFactory = function (fieldOrForm) {
        var m, o, fn, api, factoryInterface;

        m = validatorFactory.markup;

        // Extendable options
        o = $.extend(true, {
            validatorOptions: {
                namespace: 'data-validator-',
                errorClass: fieldOrForm.m.INVALID,
                successClass: fieldOrForm.m.VALID,
                classHandler: function () {
                    return fieldOrForm.internal.$e;
                },
                errorsContainer: function () {
                    fieldOrForm.elements = fieldOrForm.elements || {};
                    return fieldOrForm.elements.validationMessage;
                },
                errorsWrapper: '<div class="validation-messages"></div>',
                errorTemplate: '<p class="validation-message"></p>',
                excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden], [disabled], :hidden, .built-form.variant-mock input, .built-form.variant-mock textarea, .built-form.variant-mock select',
                inputs: 'input, textarea, select, [contenteditable], .editable-content'
            }
        }, fieldOrForm.o.validatorOptions);

        // Primary methods
        fn = {
            // Init parsley on the field or form and then bind to the error and
            // success methods emmited by the parsley instances
            init: function () {
                fn.initParsley();
                fn.bindEvents();
            },

            // Init parsely on the field or form and cache the instance returned
            // on the field or form's internal map.
            initParsley: function () {
                var $e = fieldOrForm.$e.first();
                fieldOrForm.internal.validator = $e.parsley(o.validatorOptions);
            },

            // Bind to the success and error event emitted by the parsely instances
            // to toggle the state-valid and state-invalid classes on the field
            // or form
            bindEvents: function () {
                var validator = fieldOrForm.internal.validator;

                validator.on('field:success', fn.setValid);
                validator.on('form:success', fn.setValid);
                validator.on('field:error', fn.setInvalid);
                validator.on('form:error', fn.setInvalid);
            },

            // Add the state-valid class and remove the state-invalid class
            setValid: function () {
                var $field = fieldOrForm.internal.$e.closest('.' + m.FIELD);

                $field.addClass(fieldOrForm.m.VALID);
                $field.removeClass(fieldOrForm.m.INVALID);
            },

            // Remove the state-valid class and add the state-invalid class
            setInvalid: function (options) {
                var $field = fieldOrForm.internal.$e.closest('.' + m.FIELD);

                options = options || {};

                $field.removeClass(fieldOrForm.m.VALID);
                $field.addClass(fieldOrForm.m.INVALID);

                if (!options.silent) {
                    if (fieldOrForm.internal.$e[0].tagName === 'FORM') {
                        fieldOrForm.internal.$e.trigger('form:error');
                    } else if ($.isFunction(fieldOrForm.internal.validator.getErrorsMessages)) {
                        fieldOrForm.internal.$e.trigger('field:error', {
                            label: fieldOrForm.fn.getLabel(),
                            errorMessages: fieldOrForm.internal.validator.getErrorsMessages()
                        });
                    }
                }
            },

            // Run the validate() method exposed by the parsley instance
            validate: function () {
                fieldOrForm.internal.validator.validate();
            },

            // Run the isValid() method exposed by the parsley instance
            isValid: function () {
                return fieldOrForm.fn.isValid ? fieldOrForm.fn.isValid() : fieldOrForm.internal.validator.isValid();
            },

            showError: function (errorMsg, errorName) {
                var validator, hasCustomError, validatorErrorMessages;

                errorName = errorName || 'serverError';
                validator = fieldOrForm.internal.validator;
                hasCustomError = validator._ui ? validator._ui.$errorsWrapper.find('.parsley-' + errorName).length > 0 : false;
                validatorErrorMessages = fieldOrForm.internal.validator.getErrorsMessages();

                if (hasCustomError) {
                    validator.updateError(errorName, {
                        message: errorMsg
                    });
                } else {
                    validator.addError(errorName, {
                        message: errorMsg
                    });
                }

                validatorErrorMessages.push(errorMsg);
                fieldOrForm.internal.$e.trigger('field:error', {
                    label: fieldOrForm.fn.getLabel(),
                    errorMessages: validatorErrorMessages
                });
                fn.setInvalid({ silent: true });
            },

            removeError: function (errorName) {
                var validator;

                errorName = errorName || 'serverError';
                validator = fieldOrForm.internal.validator;

                validator.removeError(errorName);
            },

            reset: function () {
                fieldOrForm.internal.validator.reset();
            },

            onValidationEvent: function (event, callback) {
                fieldOrForm.internal.validator.on(event, callback);
            },

            offValidationEvent: function (event, callback) {
                fieldOrForm.internal.validator.off(event, callback);
            }
        };

        // A map of methods to be bolted onto the fields collection.
        api = {
            validate: fn.validate,
            isValid: fn.isValid,
            setValid: fn.setValid,
            setInvalid: fn.setInvalid,
            showError: fn.showError,
            removeError: fn.removeError,
            resetValidation: fn.reset,
            onValidationEvent: fn.onValidationEvent,
            offValidationEvent: fn.offValidationEvent
        };
        $.extend(fieldOrForm.self, api);

        factoryInterface = {
            create: fn.init
        };

        return factoryInterface;
    };

    validatorFactory.markup = {
        FIELD: 'field'
    };

    return validatorFactory;
});

!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define('uuidv4', e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).uuidv4 = e() }(this, (function () { "use strict"; var t, e = new Uint8Array(16); function o() { if (!t && !(t = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return t(e) } var n = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i; function r(t) { return "string" == typeof t && n.test(t) } for (var i = [], u = 0; u < 256; ++u)i.push((u + 256).toString(16).substr(1)); return function (t, e, n) { var u = (t = t || {}).random || (t.rng || o)(); if (u[6] = 15 & u[6] | 64, u[8] = 63 & u[8] | 128, e) { n = n || 0; for (var f = 0; f < 16; ++f)e[n + f] = u[f]; return e } return function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, o = (i[t[e + 0]] + i[t[e + 1]] + i[t[e + 2]] + i[t[e + 3]] + "-" + i[t[e + 4]] + i[t[e + 5]] + "-" + i[t[e + 6]] + i[t[e + 7]] + "-" + i[t[e + 8]] + i[t[e + 9]] + "-" + i[t[e + 10]] + i[t[e + 11]] + i[t[e + 12]] + i[t[e + 13]] + i[t[e + 14]] + i[t[e + 15]]).toLowerCase(); if (!r(o)) throw TypeError("Stringified UUID is invalid"); return o }(u) } }));
define('forms/widgets/MaxLengthLimiter', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var MaxLengthLimiter = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = MaxLengthLimiter.markup;

        o = $.extend({
            $e: null,
            selector: '[maxlength]'
        }, options);

        internal = {
            name: 'MaxLengthLimiter',
            $e: o.$e || $(o.selector),

            field: o.field || null,
            maxLength: null,

            components: {
                maxLengthInput: {
                    selector: '[maxlength]'
                },
                charCount: {
                    selector: '.char-count'
                }
            },

            events: {
                'change @maxLengthInput': 'maxLengthInputChange',
                'keyup @maxLengthInput': 'maxLengthInputChange'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.field = internal.field || internal.$e.data('fieldInstance');
                internal.maxLength = elements.maxLengthInput.prop('maxlength');

                fn.updateCharCount();
            },

            handleChange: function () {
                fn.updateCharCount();
            },

            updateCharCount: function () {
                var currentLength;

                if (!elements.charCount) {
                    return;
                }

                currentLength = internal.field.getVal().length;
                elements.charCount.html(currentLength + '/' + internal.maxLength);

                if (currentLength > internal.maxLength) {
                    fn.capValue();
                }
            },

            capValue: function () {
                var value, cappedValue;

                value = internal.field.getVal();
                cappedValue = value.substr(0, internal.maxLength);
                internal.field.setVal(cappedValue);
            }
        };

        handlers = {
            maxLengthInputChange: function () {
                fn.handleChange();
            }
        };

        api = {};

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    MaxLengthLimiter.markup = {};

    return MaxLengthLimiter;
});

define('forms/widgets/AutoHeight', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var AutoHeight = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = AutoHeight.markup = {};

        o = $.extend({
            $e: null,
            selector: '[autoheight]'
        }, options);

        internal = {
            name: 'AutoHeight',
            $e: o.$e || $(o.selector),

            inputLineHeight: null,

            components: {
                autoHeightInput: {
                    selector: '[autoheight]'
                }
            },

            events: {
                'change @autoHeightInput': 'autoHeightInputChange',
                'keyup @autoHeightInput': 'autoHeightInputChange'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.inputLineHeight = parseInt(elements.autoHeightInput.css('line-height'), 10);
                fn.updateInputHeight();
            },

            handleChange: function () {
                fn.updateInputHeight();
            },

            updateInputHeight: function () {
                elements.autoHeightInput.css({
                    height: internal.inputLineHeight + 'px'
                });

                elements.autoHeightInput.css({
                    height: elements.autoHeightInput[0].scrollHeight + 'px'
                });
            }
        };

        handlers = {
            autoHeightInputChange: function () {
                fn.handleChange();
            }
        };

        api = {};

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    AutoHeight.markup = {};

    return AutoHeight;
});

define('forms/widgets/AutoSlug', [
    'jquery',
    'factories/moduleFactory',
    'utils/stringUtil'
], function (
    $,
    moduleFactory,
    stringUtil
) {
    'use strict';

    var AutoSlug = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = AutoSlug.markup = {};

        o = $.extend({
            $e: null,
            selector: '[autoslug]'
        }, options);

        internal = {
            name: 'AutoSlug',
            $e: o.$e || $(o.selector),

            field: o.field,
            targetField: null,
            enabled: false,
            formInstance: null,

            components: {
                form: {
                    selector: '^form'
                },

                slugPrefix: {
                    selector: '.slug-prefix'
                }
            },

            events: {
                'formReady !form': 'formReady'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.formInstance = elements.form.data('formInstance');

                if (internal.formInstance.isReady()) {
                    fn.getTargetField();
                    fn.getPrefixTargetField();
                }
            },

            getTargetField: function () {
                var targetFieldName;

                targetFieldName = internal.$e.data('autoslugTarget');
                internal.targetField = internal.formInstance.getField(targetFieldName);
                elements.targetFieldInput = internal.targetField.getFieldInput();

                elements.targetFieldInput.on('focus.autoslug', function () {
                    internal.enabled = internal.field.isBlank();
                });

                elements.targetFieldInput.on('keyup.autoslug blur.autoslug', function () {
                    fn.updateSlug();
                });
            },

            getPrefixTargetField: function () {
                var prefixTargetFieldName;
                prefixTargetFieldName = internal.$e.data('autoslugPrefixTarget');

                if (!prefixTargetFieldName) {
                    return;
                }

                elements.form.on('change', function () {
                    fn.updatePrefix(prefixTargetFieldName);
                });
            },

            updateSlug: function () {
                var targetFieldVal, slug;

                if (internal.enabled) {
                    targetFieldVal = internal.targetField.getVal();
                    slug = stringUtil.slugify(targetFieldVal);
                    internal.field.setVal(slug);
                }
            },

            updatePrefix: function (prefixTargetFieldName) {
                var $inputElem, prefixHost, prefixPath, jsonFieldData, $selectedOption;

                $inputElem = elements.form.find('[name="' + prefixTargetFieldName + '"]');
                prefixHost = internal.$e.data('prefixHost');

                if (!$inputElem.length) {
                    return;
                }

                if ($inputElem.hasClass('json-field')) {
                    jsonFieldData = $inputElem.data('fieldInstance').getFullVal();
                    prefixPath = jsonFieldData.read_url.replace('overview/', '');
                } else if ($inputElem[0].tagName === 'SELECT') {
                    $selectedOption = $inputElem.find(':selected');
                    prefixPath = $selectedOption.data('readUrl').replace('overview/', '');
                }

                elements.slugPrefix.html(prefixHost + prefixPath);
                internal.$e.data('prefixPath', prefixPath);
            },

            beforeDestroy: function () {
                elements.targetFieldInput.off('focus.autoslug');
                elements.targetFieldInput.off('keyup.autoslug');
                elements.targetFieldInput.off('blur.autoslug');
            }
        };

        handlers = {
            formReady: function () {
                fn.getTargetField();
                fn.getPrefixTargetField();
            }
        };

        api = {};

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    AutoSlug.markup = {};

    return AutoSlug;
});

/*! js-cookie v3.0.1 | mit */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define('js.cookie', t) : (e = e || self, function () { var n = e.Cookies, o = e.Cookies = t(); o.noConflict = function () { return e.Cookies = n, o } }()) }(this, (function () { "use strict"; function e(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var o in n) e[o] = n[o] } return e } return function t(n, o) { function r(t, r, i) { if ("undefined" != typeof document) { "number" == typeof (i = e({}, o, i)).expires && (i.expires = new Date(Date.now() + 864e5 * i.expires)), i.expires && (i.expires = i.expires.toUTCString()), t = encodeURIComponent(t).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape); var c = ""; for (var u in i) i[u] && (c += "; " + u, !0 !== i[u] && (c += "=" + i[u].split(";")[0])); return document.cookie = t + "=" + n.write(r, t) + c } } return Object.create({ set: r, get: function (e) { if ("undefined" != typeof document && (!arguments.length || e)) { for (var t = document.cookie ? document.cookie.split("; ") : [], o = {}, r = 0; r < t.length; r++) { var i = t[r].split("="), c = i.slice(1).join("="); try { var u = decodeURIComponent(i[0]); if (o[u] = n.read(c, u), e === u) break } catch (e) { } } return e ? o[e] : o } }, remove: function (t, n) { r(t, "", e({}, n, { expires: -1 })) }, withAttributes: function (n) { return t(this.converter, e({}, this.attributes, n)) }, withConverter: function (n) { return t(e({}, this.converter, n), this.attributes) } }, { attributes: { value: Object.freeze(o) }, converter: { value: Object.freeze(n) } }) }({ read: function (e) { return '"' === e[0] && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent) }, write: function (e) { return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent) } }, { path: "/" }) }));

define('services/Xhr', [
    'jquery',
    'js.cookie'
], function (
    $,
    Cookies
) {
    'use strict';
    /*
        Xhr
        ===

        A service to allow modules to communicate via Ajax. Exposes the following
        methods:
        - get
        - post
        - put
        - delete

        Example:
        var xhr = new Xhr({
            endpoints: {
                get: '/get/endpoint/api/',
                post: '/post/endpoint/api/',
                put: '/put/endpoint/api/',
                delete: '/delete/endpoint/api/'
            }
        });
    */
    var Xhr = function (options) {
        var self, o, internal, fn, api, core;

        self = this;
        core = require('core');

        // Options
        o = $.extend(true, {
            // Default xhrSettings. Can be overriden
            xhrSettings: {
                url: window.location.href,
                contentType: "application/json; charest=utf-8",
                crossDomain: false,
                dataType: 'json',
                headers: {},
                method: {},

                beforeSend: function (xhr) {
                    //xhr.setRequestHeader('X-CSRFToken', Cookies.get('csrftoken'));
                },
                error: function () { },
                success: function () { },
                complete: function () { }
            },
            endpoints: {}
        }, options);

        internal = {
            serverErrorRegex: /^5[0-9]{2}$/,
            modalsManager: core.getInstance('modalsManager'),
            jqXHR: null
        };

        // Primary methods
        fn = {
            // GET via specified get endpoint
            get: function (data, options) {
                var requestSettings = {
                    url: o.endpoints.get || o.xhrSettings.url,
                    method: 'GET',
                    data: data
                };
                options = options || {};

                return fn.send($.extend(true, requestSettings, options));
            },

            getHtml: function (url, options) {
                var requestSettings = {
                    url: url,
                    method: 'GET',
                    contentType: 'text/plain; charest=utf-8',
                    dataType: 'html'
                };
                options = options || {};

                return fn.send($.extend(true, requestSettings, options));
            },

            // POST supplied data via specified post endpoint
            post: function (data, options) {
                var requestSettings = {
                    url: o.endpoints.post || o.xhrSettings.url,
                    method: 'POST',
                    data: data
                };
                options = options || {};

                return fn.send($.extend(true, requestSettings, options));
            },

            // PUT supplied data via specified put endpoint
            put: function (data, options) {
                var requestSettings = {
                    url: o.endpoints.put || o.xhrSettings.url,
                    method: 'PUT',
                    data: data
                };
                options = options || {};

                return fn.send($.extend(true, requestSettings, options));
            },

            // PATCH via url
            patch: function (url, data, options) {
                var requestSettings = {
                    url: url,
                    method: 'PATCH',
                    data: data
                };
                options = options || {};

                return fn.send($.extend(true, requestSettings, options));
            },

            // DELETE via specified delete endpoint
            delete: function (data, options) {
                var requestSettings = {
                    url: o.endpoints.delete || o.xhrSettings.url,
                    method: 'DELETE',
                    data: data
                };
                options = options || {};

                return fn.send($.extend(true, requestSettings, options));
            },

            // Parse the requestSettingsData and hand off to jquery ajax
            send: function (requestSettings) {
                var requestSettingsData = {},
                    jqXHR,
                    cachedErrorMethod;

                if (internal.jqXHR) {
                    internal.jqXHR.abort();
                    internal.jqXHR = null;
                }

                // pass sendJSON: false in requestSettings to override
                requestSettingsData.sendJSON = true;
                requestSettingsData = $.extend(true, requestSettingsData, o.xhrSettings, requestSettings);

                if (requestSettingsData.sendJSON && !(requestSettingsData.data instanceof FormData)) {
                    requestSettingsData.data = JSON.stringify(requestSettingsData.data);
                }

                cachedErrorMethod = requestSettingsData.error || function () { };
                requestSettingsData.error = function (xhr, statusStr, errorStr) {
                    if (internal.serverErrorRegex.test(xhr.status)) {
                        internal.modalsManager.launchUnexpectedErrorModal({
                            errorStr: xhr.status + ' ' + xhr.statusText
                        }, {
                            size: 'medium'
                        });
                    }

                    cachedErrorMethod(xhr, statusStr, errorStr);
                };

                jqXHR = $.ajax(requestSettingsData);
                internal.jqXHR = jqXHR;

                return jqXHR;
            }
        };

        // Interface methods to be exposed
        api = {
            get: fn.get,
            post: fn.post,
            put: fn.put,
            patch: fn.patch,
            delete: fn.delete,
            getHtml: fn.getHtml
        };
        $.extend(self, api);
    };

    return Xhr;
});

define('forms/widgets/SlugCheck', [
    'jquery',
    'factories/moduleFactory',
    'services/Xhr',
    'utils/functionUtil'
], function (
    $,
    moduleFactory,
    Xhr,
    functionUtil
) {
    'use strict';

    var SlugCheck = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = SlugCheck.markup = {};

        o = $.extend({
            $e: null,
            selector: '[slugcheck]',
            field: null,
            searchDelay: 250
        }, options);

        internal = {
            name: 'SlugCheck',
            $e: o.$e || $(o.selector),

            xhr: new Xhr(),
            xhrRequest: null,

            invalidMsg: '{{invalidSlug}} is already taken. Save with the generated slug above, or edit manually.',
            serverSlug: '',
            initialSlug: null,

            components: {
                input: {
                    selector: 'input'
                }
            },

            events: {
                'change': 'handleChange'
            }
        };

        elements = {};

        fn = {
            init: function () {
                fn.cacheCheckEndpoint();
                fn.cacheSlug();
            },

            cacheCheckEndpoint: function () {
                internal.checkEndpoint = internal.$e.data('slugCheckUri');
            },

            getField: function () {
                return o.field || internal.$e.data('fieldInstance');
            },

            cacheSlug: function () {
                internal.initialSlug = fn.getField().getVal();
            },

            checkSlug: functionUtil.debounce(function () {
                var field, slugVal, checkEndpoint;

                field = fn.getField();
                slugVal = field.getVal();

                if (!slugVal.length || slugVal === internal.initialSlug) {
                    return;
                }

                if (internal.xhrRequest) {
                    internal.xhrRequest.abort();
                }

                internal.$e.addClass(m.PROCESSING);
                checkEndpoint = fn.getCheckEndpoint(slugVal);
                if (checkEndpoint) {
                    internal.xhrRequest = internal.xhr.getHtml(checkEndpoint, {
                        success: function (response) {
                            internal.serverSlug = response;
                            fn.validateSlug(response);
                            internal.$e.removeClass(m.PROCESSING);
                        }
                    });
                }
            }, o.searchDelay),

            getCheckEndpoint: function (slugVal) {
                var prefixPath;

                if (internal.$e.data('pathCheck')) {
                    prefixPath = internal.$e.data('prefixPath');
                    if (prefixPath) {
                        return '/path-check/?path=' + prefixPath + '&slug=' + slugVal;
                    } else {
                        return null;
                    }
                } else {
                    return internal.checkEndpoint + slugVal + '/';
                }
            },

            validateSlug: function (serverSlug) {
                var field, currentSlug, invalidMsg;

                serverSlug = serverSlug || internal.serverSlug;
                field = fn.getField();
                currentSlug = field.getVal();

                if (currentSlug.length && serverSlug.length && currentSlug !== serverSlug) {
                    invalidMsg = internal.invalidMsg.replace('{{invalidSlug}}', currentSlug);
                    field.showError(invalidMsg, 'invalidSlug');
                    field.setVal(serverSlug, { silent: true });
                } else {
                    field.removeError('invalidSlug');
                }
            }
        };

        handlers = {
            handleChange: function () {
                fn.checkSlug();
            }
        };

        api = {};

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    SlugCheck.markup = {};

    return SlugCheck;
});

define('factories/fieldFactory', [
    'jquery',
    'factories/moduleFactory',
    'factories/validatorFactory',
    'utils/statesUtil',
    'utils/stringUtil',
    'forms/widgets/MaxLengthLimiter',
    'forms/widgets/AutoHeight',
    'forms/widgets/AutoSlug',
    'forms/widgets/SlugCheck'
], function (
    $,
    moduleFactory,
    validatorFactory,
    statesUtil,
    stringUtil,
    MaxLengthLimiter,
    AutoHeight,
    AutoSlug,
    SlugCheck
) {
    'use strict';
    /*
        fieldFactory
        ============

        A factory with the responsibility of creating form fields, by:
        - Applying common event handlers.
        - Extending the field module with common methods.

        Example:
        fieldFactory({
            self: self,
            o: o,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers
        }).create();
    */
    var fieldFactory = function (field) {
        var internal, m, fn, handlers, api, factoryInterface;

        // Internal extensions. The common/base events required for a field.
        internal = {
            widgets: {
                '[maxlength]': MaxLengthLimiter,
                '[autoheight]': AutoHeight,
                '[autoslug]': AutoSlug,
                '[slugcheck]': SlugCheck
            },

            components: {
                parentForm: {
                    selector: '^form'
                }
            },

            events: {
                'click.fieldFactory @customControl': 'fieldFactoryCustomControlClick',
                'focus.fieldFactory @nativeInput': 'fieldFactoryNativeInputFocus',
                'change.fieldFactory @nativeInput': 'fieldFactoryNativeInputChange',
                'blur.fieldFactory @nativeInput': 'fieldFactoryNativeInputBlur'
            }
        };

        // Markup
        m = fieldFactory.markup;

        // Primary methods
        fn = {
            // Initialize the field, by first handing it to the moduleFactory
            // to be constructed, and then ensuring the tabIndex for the field
            init: function () {
                moduleFactory(field).extend({
                    internal: field.internal.withoutNativeInput ? {} : internal,
                    handlers: field.internal.withoutNativeInput ? {} : handlers,
                    fn: api
                }).create();

                fn.ensureTabIndex();
                fn.initValidator();
                fn.setValueState();
                fn.applyWidgets();

                field.internal.cachedVal = field.fn.getVal();

                field.internal.$e.data('fieldInstance', field.self);
            },

            // Return a DOM element for the field, whether it's a native input or the root el
            getFieldInput: function () {
                return field.internal.withoutNativeInput ? field.internal.$e : field.elements.nativeInput;
            },

            // If the field doesn't have a tabindex, then give it one.
            ensureTabIndex: function () {
                var fieldInput = fn.getFieldInput();
                if (
                    !fieldInput.attr('tabindex') &&
                    !field.internal.noTabIndex
                ) {
                    fieldInput.attr('tabindex', 0);
                }
            },

            // Send the field off to the validatorFactory to get a validator appended
            // to the field module
            initValidator: function () {
                validatorFactory({
                    $e: fn.getFieldInput(),
                    self: field.self,
                    o: field.o,
                    internal: field.internal,
                    elements: field.elements,
                    fn: field.fn,
                    m: field.m
                }).create();
            },

            // Toggle the has-value state clase
            setValueState: function () {
                field.internal.$e.toggleClass(m.HAS_VALUE, !field.fn.isBlank());
            },

            applyWidgets: function () {
                $.each(internal.widgets, function (selector, Widget) {
                    if (fn.getFieldInput().is(selector)) {
                        new Widget({
                            $e: field.internal.$e,
                            field: field.self
                        });
                    }
                });
            },

            // Set the value of the field. Can be done silently.
            setVal: function (val, options) {
                var fieldInput = fn.getFieldInput(),
                    valMethod = field.internal.valMethod || 'val';

                options = options || {};

                fieldInput[valMethod](val);

                if (!options.silent) {
                    fieldInput.trigger('change', val);
                    if (field.internal.withoutNativeInput) {
                        field.self.validate();
                    }
                }

                if (options.isDefault) {
                    fieldInput.trigger('change:default', val);
                }
            },

            setDefaultVal: function (val, options) {
                options = options || {};
                options.isDefault = true;
                field.fn.setVal(val, options);
            },

            // Get the value of the field.
            getVal: function () {
                var fieldInput = fn.getFieldInput(),
                    valMethod = field.internal.valMethod || 'val',
                    val = fieldInput[valMethod]();

                if (typeof val === 'string') {
                    val = $.trim(val);
                }

                if (val === 'null') {
                    val = null;
                }

                if (fieldInput.attr('type') === 'file') {
                    val = fieldInput[0].files[0];
                }

                return val;
            },

            // Enable the field, and remove the disabled state class
            enable: function () {
                var fieldInput = fn.getFieldInput();
                fieldInput.prop('disabled', false);
                field.internal.$e.removeClass(m.DISABLED);
            },

            // Disabled the field, and add the disabled state class
            disable: function () {
                var fieldInput = fn.getFieldInput();
                fieldInput.prop('disabled', true);
                field.internal.$e.addClass(m.DISABLED);
            },

            // Clear out the field.
            reset: function (options) {
                field.fn.setVal('', options);
            },

            // Set focus on the field.
            focus: function () {
                var fieldInput = fn.getFieldInput();
                fieldInput.focus();
                fn.setFocusState();
            },

            // Blur the field.
            blur: function () {
                var fieldInput = fn.getFieldInput();
                fieldInput.blur();
                fn.unsetFocusState();
            },

            // Apply the focus state class
            setFocusState: function () {
                field.internal.$e.addClass(m.FOCUS);
            },

            // Remove focus state class
            unsetFocusState: function () {
                field.internal.$e.removeClass(m.FOCUS);
            },

            // Check if the field has focus and is the active document element
            hasFocus: function () {
                var fieldInput = fn.getFieldInput();
                return (
                    field.internal.$e.hasClass(m.FOCUS) &&
                    fieldInput[0] === document.activeElement
                );
            },

            // Check if the field is currently blank.
            isBlank: function () {
                return $.trim(field.fn.getVal()).length === 0;
            },

            // Get the name of the native field
            getName: function () {
                var fieldInput = fn.getFieldInput();
                return fieldInput.attr('name');
            },

            nullIfBlank: function () {
                return !!field.internal.$e.data('nullIfBlank');
            },

            ignore: function () {
                return !!field.internal.$e.data('ignore');
            },

            isReady: function () {
                return field.internal.$e.data('fieldReady');
            },

            getLabel: function () {
                var $label, labelText;

                $label = field.internal.$e.siblings('label');

                if ($label.length) {
                    labelText = $label.map(function () {
                        return $.trim(this.textContent.replace(/\*/gi, ''));
                    }).get();
                } else {
                    labelText = $.map(fn.getName().split('_'), function (namePart) {
                        return stringUtil.capitalize(namePart);
                    });
                }

                if (field.elements.parentForm && field.elements.parentForm.hasClass(fieldFactory.markup.SETTINGS_FORM)) {
                    labelText.unshift('Settings /');
                }

                return labelText.join(' ');
            }
        };

        // Event handlers.
        handlers = {
            // Give the field focus when it's custom control is clicked.
            fieldFactoryCustomControlClick: function () {
                field.fn.focus();
            },

            // When the field gets focus apply the focus state class.
            fieldFactoryNativeInputFocus: function () {
                fn.setFocusState();
                fn.setValueState();
            },

            fieldFactoryNativeInputChange: function () {
                fn.setValueState();
                field.self.validate();
            },

            // When the field loses focus remove the focus state class.
            fieldFactoryNativeInputBlur: function () {
                fn.unsetFocusState();
                fn.setValueState();
            }
        };


        // A map of methods to be bolted onto the fields fn map.
        api = {
            setVal: fn.setVal,
            setDefaultVal: fn.setDefaultVal,
            getVal: fn.getVal,
            enable: fn.enable,
            disable: fn.disable,
            reset: fn.reset,
            focus: fn.focus,
            blur: fn.blur,
            hasFocus: fn.hasFocus,
            isBlank: fn.isBlank,
            getName: fn.getName,
            getFieldInput: fn.getFieldInput,
            nullIfBlank: fn.nullIfBlank,
            ignore: fn.ignore,
            isReady: fn.isReady,
            getLabel: fn.getLabel
        };

        // A thin interface to allow for creating and extending the field
        factoryInterface = {
            create: fn.init,
            extend: fn.extend
        };
        $.extend(field.self, api);

        return factoryInterface;
    };

    // Common field markup
    fieldFactory.markup = {
        SETTINGS_FORM: 'variant-settings-form'
    };
    statesUtil.extend(fieldFactory.markup);

    return fieldFactory;
});

define('forms/fields/CustomInput', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';
    /*
        Custom Input
        =================

        A very thin wrapper for the custom input implementation to allow the
        form to be able to cache an instance of this and then be able to validate
        and get the value of the field.

        Example:
        <div class='field custom-input'>
            <input type='text' placeholder='Field hint'>
        </div>

        var customInput = new CustomInput({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
    */
    var CustomInput = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = CustomInput.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.custom-input'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'CustomTextInput',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            // Dict of components used by this module.
            components: {
                nativeInput: {
                    selector: [
                        'input[type=text]',
                        'input[type=password]',
                        'input[type=email]',
                        'input[type=url]',
                        'input[type=tel]',
                        'input[type=search]',
                        'input[type=number]',
                        'input[type=date]',
                        'input[type=hidden]',
                        'input[type=file]'
                    ].join(', ')
                }
            },

            events: {}
        };

        // Elements cache
        elements = {};

        // Primary methods
        fn = {
            init: function () { }
        };

        // Event handlers
        handlers = {};

        // A map of methods to be exposed on the instance of this module
        api = {};

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    CustomInput.markup = {};

    return CustomInput;
});

define('forms/fields/CustomTextarea', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';
    /*
        Custom Textarea
        =================

        A very thin wrapper for the custom textarea implementation to allow the
        form to be able to cache an instance of this and then be able to validate
        and get the value of the field.

        Example:
        <div class='field custom-textarea'>
            <textarea></textarea>
        </div>

        var CustomTextarea = new CustomTextarea({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
    */
    var CustomTextarea = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = CustomTextarea.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.custom-textarea'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'CustomTextarea',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            // Dict of components used by this module.
            components: {
                nativeInput: {
                    selector: 'textarea'
                }
            }
        };

        // Elements cache
        elements = {};

        // Primary methods
        fn = {
            init: function () { }
        };

        // Event handlers
        handlers = {};

        // A map of methods to be exposed on the instance of this module
        api = {};

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    CustomTextarea.markup = {};

    return CustomTextarea;
});

define('forms/fields/CustomRadio', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';
    /*
        Custom Radio
        ===============

        A very thin wrapper for the custom radio implementation to allow the
        form to be able to cache an instance of this and then be able to validate
        and get the value of the field.

        Example:
        <label class='field custom-radio'>
            <input type='radio' name='radio_name'>
            <span class='radio'></span>
            <span class='custom-radio-label'>Radio label</span>
            <!-- Optional -->
            <span class='custom-radio-subtitle'>Radio subtitle</span>
        </label>

        var customRadio = new CustomRadio({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
    */
    var CustomRadio = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = CustomRadio.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.custom-radio'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'CustomRadio',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            // Dict of components used by this module.
            components: {
                nativeInput: {
                    selector: 'input[type="radio"]'
                }
            }
        };

        // Elements cache
        elements = {};

        // Primary methods
        fn = {
            init: function () {
                fn.setDefaultValue();
                o.fieldset.getEl().on('initCustomFieldsComplete', function () {
                    fn.ensureUniqueName();
                });
            },

            setDefaultValue: function () {
                var defaultValue;

                defaultValue = internal.$e.data('defaultValue');
                if (!defaultValue && typeof defaultValue !== 'boolean') {
                    return;
                }

                fn.setVal(defaultValue, { isDefault: true });
            },

            ensureUniqueName: function () {
                var formSiblings, fieldsetSiblings, fieldsetId;

                formSiblings = o.form.getFields(fn.getName());
                fieldsetSiblings = o.fieldset.getFields(fn.getName());
                fieldsetId = o.fieldset.getFieldsetId();

                if (formSiblings.length > fieldsetSiblings.length) {
                    if (!elements.nativeInput.data('name')) {
                        elements.nativeInput.data('name', fn.getName());
                    }
                    elements.nativeInput.attr('name', fn.getName() + '-' + fieldsetId);
                }
            },

            getEls: function () {
                var $radios = $();

                $.each(o.fieldset.getFields(fn.getName()), function (i, siblingRadio) {
                    $radios = $radios.add(siblingRadio.getEl());
                });

                return $radios;
            },

            getName: function () {
                return elements.nativeInput.data('name') || elements.nativeInput.attr('name');
            },

            // Check if the checkbox is :checked before returning its value
            getVal: function (options) {
                var returnVal = "",
                    siblings;

                options = options || {};

                if (elements.nativeInput.is(':checked')) {
                    returnVal = elements.nativeInput.val();
                } else if (!options.ignoreSiblings) {
                    siblings = o.fieldset.getFields(fn.getName());
                    $.each(siblings, function (i, siblingRadio) {
                        if (!(returnVal + '').length) {
                            returnVal = siblingRadio.getVal({ ignoreSiblings: true });
                        }
                    });
                }

                if (/^(true|false)$/i.test(returnVal)) {
                    returnVal = /^true$/i.test(returnVal);
                }

                return returnVal;
            },

            // Check if the checkbox value matches the value passed in and
            // toggle the checked property based on the match
            setVal: function (value, options) {
                var isSelfValue = elements.nativeInput.val() + '' === value + '',
                    siblings;

                options = options || {};
                elements.nativeInput.prop('checked', isSelfValue);

                if (!isSelfValue) {
                    siblings = o.form.getFields(fn.getName());
                    $.each(siblings, function (i, siblingRadio) {
                        if (
                            value + '' === siblingRadio.getFieldInput().val() + '' &&
                            siblingRadio.getFieldInput().attr('name') === elements.nativeInput.attr('name')
                        ) {
                            siblingRadio.setVal(value, options);
                        }
                    });
                } else {
                    if (options.isDefault) {
                        elements.nativeInput.trigger('change:default', value);
                    }
                }

                if (!options.silent && !options.isDefault) {
                    elements.nativeInput.trigger('change');
                }
            },

            reset: function () {
                var allRadioFields;

                allRadioFields = o.form.getFields(fn.getName());
                $.each(allRadioFields, function (i, radioField) {
                    radioField.getFieldInput().prop('checked', false);
                });
            }
        };

        // Event handlers
        handlers = {};

        // A map of methods to be exposed on the instance of this module
        api = {
            getEls: fn.getEls,
            getVal: fn.getVal,
            setVal: fn.setVal,
            reset: fn.reset,
            getName: fn.getName
        };

        // Initialize the CustomRadio by building it in the fieldFactory
        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    // Module markup
    CustomRadio.markup = {};

    return CustomRadio;
});

define('forms/fields/CustomCheckbox', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';
    /*
        Custom Checkbox
        ===============

        A very thin wrapper for the custom checkbox implementation to allow the
        form to be able to cache an instance of this and then be able to validate
        and get the value of the field.

        Example:
        <label class='field custom-checkbox'>
            <input type='checkbox' name='checkbox_name'>
            <span class='checkbox'>
                {% include 'svg/forms/_check.html' %}
            </span>
            <span class='custom-checkbox-label'>Checkbox label</span>
            <!-- Optional -->
            <span class='custom-checkbox-subtitle'>Checkbox subtitle</span>
        </label>

        var customCheckbox = new CustomCheckbox({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
    */
    var CustomCheckbox = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = CustomCheckbox.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.custom-checkbox'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'CustomCheckbox',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            // Dict of components used by this module.
            components: {
                nativeInput: {
                    selector: 'input[type="checkbox"]'
                }
            }
        };

        // Elements cache
        elements = {};

        // Primary methods
        fn = {
            init: function () {
            },

            // Check if the checkbox is :checked before returning its value
            getVal: function () {
                var returnVal = "", checkedVal;

                checkedVal = elements.nativeInput.val();

                if (elements.nativeInput.is(':checked')) {
                    returnVal = checkedVal;
                }

                if (checkedVal === 'true') {
                    if (!returnVal.length) {
                        returnVal = false;
                    } else {
                        returnVal = true;
                    }
                }

                return returnVal;
            },

            // Check if the checkbox value matches the value passed in and
            // toggle the checked property based on the match
            setVal: function (value, options) {
                var isSelfValue = (elements.nativeInput.val() + '') === (value + '');

                options = options || {};

                elements.nativeInput.prop('checked', isSelfValue);

                if (!options.silent) {
                    elements.nativeInput.trigger('change', value);
                }

                if (options.isDefault && isSelfValue) {
                    elements.nativeInput.trigger('change:default', value);
                }
            }
        };

        // Event handlers
        handlers = {};

        // A map of methods to be exposed on the instance of this module
        api = {
            getVal: fn.getVal,
            setVal: fn.setVal
        };

        // Initialize the CustomCheckbox by building it in the fieldFactory
        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    // Module markup
    CustomCheckbox.markup = {
        PARTIAL: 'state-partial'
    };

    return CustomCheckbox;
});

define('forms/fields/CustomSelect', [
    'jquery',
    'utils/globalElements',
    'factories/fieldFactory',
    'forms/widgets/DropMenu'
], function (
    $,
    globalElements,
    fieldFactory,
    DropMenu
) {
    'use strict';

    /*
        Custom Selects
        ==============

        A module for custom selects, utilizing a DropMenu. It does the following:
        - Syncs the custom select ui with a native select.
        - Co-ordinates the DropMenu instance's open/close state
        - Updates itself when a selection is made in the DropMenu instance

        Example:
        <div class='field custom-select variant-linked-visibility'>
            <p class='custom-select-control' placeholder='Select a group type'>&nbsp;</p>
            <ul class='custom-select-options'>
                <li class='custom-option' data-value='linkedOption1'>Linked Option 1</li>
                <!-- additional custom options here. Must container the same values as
                the native options below -->
            </ul>
            <select name='linkedCustomSelect_2'>
                <option value='linkedOption1'>Linked Option 1</option>
                <!-- additional options here -->
            </select>
        </div>

        new CustomSelect({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
        - Must have custom-select as a class of the top level DOM element
        - Use variant-linked-visibility to specify that the linked custom select
          should only be visible when its partner has a value
    */

    var CustomSelect = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = CustomSelect.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.custom-select'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'CustomSelect',
            $e: o.$e || $(o.selector),
            placeholder: null,
            explicitInit: true,
            focused: false,

            // Dict of components used by this module.
            components: {
                customControl: {
                    selector: '.custom-select-control'
                },
                customPlaceholder: {
                    selector: '.custom-placeholder'
                },
                nativeInput: {
                    selector: 'select'
                },
                nativeOption: {
                    selector: 'select option'
                },
                customOption: {
                    selector: '.custom-option'
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'click @customControl': 'customControlClick',
                'change @nativeInput': 'nativeInputChange',
                'blur @nativeInput': 'nativeInputBlur'
            }
        };

        // Elements cache
        elements = {
            allOptions: null
        };

        // Primary methods
        fn = {
            // Initialize the CustomeSelect instance and create a new DropMenu
            // then get the initialValue.
            init: function () {
                internal.dropMenu = new DropMenu({
                    $e: internal.$e,
                    menuControl: '.custom-select-control',
                    menuItemsWrapper: '.custom-select-options',
                    menuItem: '.custom-select-options .custom-option',
                    onSelect: fn.setValByEl
                });

                fn.getPlaceholder();
                fn.getInitialValue();
                fn.setDisabled();
                fn.setOptionStates();
                fn.cacheOptions();
            },

            // Get the initialValue applied to the native input and set it to
            // the custom select and the DropMenu instance.
            getInitialValue: function () {
                var initialValue;

                initialValue = internal.$e.data('initialVal');// || elements.nativeOption.filter(':selected').prop('value');

                if (initialValue && (initialValue + '').length) {
                    fn.setDefaultVal(initialValue);
                }

                if (fn.isBlank()) {
                    fn.showPlaceholder();
                } else {
                    fn.setCustomControlValue();
                }
            },

            // Check for the placeholder attribute on the customControl element
            // and cache the value
            getPlaceholder: function () {
                internal.placeholder = elements.customControl.attr('placeholder') || '&nbsp;';
            },

            setDisabled: function () {
                if (fn.isDisabled()) {
                    fn.disable();
                }
            },

            setOptionStates: function () {
                elements.nativeOption.each(function (i, option) {
                    var $option, isDisabled, value;

                    $option = $(option);
                    isDisabled = $option.is(':disabled');
                    value = $option.prop('value');

                    elements.customOption.filter('[data-value="' + value + '"]').toggleClass(m.DISABLED, isDisabled);
                });
            },

            cacheOptions: function () {
                elements.allOptions = elements.nativeOption.clone();
            },

            isDisabled: function () {
                return elements.nativeInput[0].hasAttribute('disabled');
            },

            // Set the display value of the CustomSelect instance, propagate the
            // value to the DropMenu instance.
            setCustomControlValue: function () {
                var currentVal = fn.getVal(),
                    selectedOption = elements.nativeOption.filter('[value="' + currentVal + '"]'),
                    optionLabel = selectedOption.html();

                elements.customControl.data('value', currentVal);
                elements.customControl.html(optionLabel);
                if (internal.dropMenu) {
                    internal.dropMenu.selectItemByVal(currentVal);
                }

                if (fn.isBlank()) {
                    fn.showPlaceholder();
                } else {
                    fn.hidePlaceholder();
                }
            },

            // The callback given to the DropMenu to handle selections.
            setValByEl: function ($dropMenuItem) {
                if (!$dropMenuItem.hasClass(m.DISABLED)) {
                    fn.setVal($dropMenuItem.data('value'));
                }
            },

            // Check if a customPlaceholder element is available otherwise use
            // the cached placeholder and set it as the html for the customControl
            // and set the placeholder state class
            showPlaceholder: function () {
                var placeholder;

                if (elements.customPlaceholder) {
                    placeholder = elements.customPlaceholder;
                    placeholder.show();
                } else {
                    placeholder = internal.placeholder;
                }

                elements.customControl.html(placeholder);
                internal.$e.addClass(m.PLACEHOLDER);
            },

            // If there is a customPlaceholder element, remove it. Then remove
            // the placeholder state class
            hidePlaceholder: function () {
                if (elements.customPlaceholder) {
                    elements.customPlaceholder.hide();
                }

                internal.$e.removeClass(m.PLACEHOLDER);
            },

            // Iterate over the nativeOptions using the supplied filterFn. Propagate
            // to dropMenu instance.
            filter: function (filterFn) {
                elements.nativeOption.each(filterFn);
                internal.dropMenu.filter(filterFn);
                fn.getComponents();
            },

            // Replace the cached nativeOptions. Propagate to the dropMenu instance.
            unfilter: function () {
                elements.nativeInput.html(elements.allOptions);
                internal.dropMenu.unfilter();
                fn.getComponents();
            },

            disable: function () {
                elements.nativeInput.attr('disabled', true);
                internal.$e.addClass(m.DISABLED);
            },

            getVal: function () {
                return elements.nativeInput.val();
            },

            setVal: function (val, options) {
                options = options || {};

                elements.nativeOption.filter(':selected').prop('selected', false);
                if (!!val || typeof val === 'boolean') {
                    elements.nativeInput[0].value = val;
                }

                fn.setCustomControlValue();

                if (!options.silent) {
                    internal.$e.trigger('change');
                }

                if (options.isDefault) {
                    elements.nativeInput.trigger('change:default', val);
                }
            },

            reset: function (options) {
                elements.nativeOption.filter(':selected').removeAttr('selected');
                fn.setVal('', options);
                fn.showPlaceholder();
            }
        };

        // Event handlers
        handlers = {
            // Toggle the DropMenu instance when the customControl is clicked.
            customControlClick: function () {
                internal.dropMenu.toggle();
            },

            // When the native input emits a change event, update the custom
            // display with the value
            nativeInputChange: function () {
                fn.setCustomControlValue();
            },

            // Close the DropMenu instance when the native input is blurred.
            nativeInputBlur: function () {
                if (internal.dropMenu.isActive()) {
                    setTimeout(function () {
                        elements.nativeInput.focus();
                    }, 50);
                } else {
                    globalElements.doc.one('mouseup', function () {
                        internal.dropMenu.close({ delay: true });
                    });
                }
            }
        };

        // A map of methods to be exposed on the instance of this module
        api = {
            filter: fn.filter,
            unfilter: fn.unfilter,
            reset: fn.reset,
            getVal: fn.getVal,
            setVal: fn.setVal
        };

        // Use the fieldFactory to build the module.
        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    // Module markup
    CustomSelect.markup = {};

    return CustomSelect;
});

define('forms/fields/LinkedCustomSelect', [
    'jquery',
    'factories/fieldFactory',
    'forms/fields/CustomSelect'
], function (
    $,
    fieldFactory,
    CustomSelect
) {
    'use strict';
    /*
        Linked Custom Select
        ====================

        A module to link custom selects so that linked selects filter their options
        based on the value of their partner. It does the following:
        - Watches its partner and updates itself whenever the partner changes
        - Will toggle its visibility when variant-linked-visibility is applied
        - Will filter its list of options based on the value of its partner

        Example:
        <div class='field linked-custom-select variant-linked-visibility'
            data-link-to='linkedCustomSelect_1'>
            <p class='custom-select-control' placeholder='Select a group type'>&nbsp;</p>
            <ul class='custom-select-options'>
                <li class='custom-option' data-value='linkedOption1' data-partner-value='option1,option2'>Linked Option 1</li>
            </ul>
            <select name='linkedCustomSelect_2'>
                <option value='linkedOption1' data-partner-value='option1,option2'>Linked Option 1</option>
            </select>
        </div>

        var linkedCustomSelect  = new LinkedCustomSelect({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
        - Identical markup as a custom select, except it should have
          linked-custom-select as its primary class.
        - Must also container a data-link-to attribute with the name of the target
          field to which this select should be linked
        - Options (both custom and native) must have a data-partner-value attribute
          which can container a comma separated list of partner values for which
          this option will be valid.
    */
    var LinkedCustomSelect = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = LinkedCustomSelect.markup;

        // Options
        o = $.extend({
            $e: null,
            $form: null,
            selector: '.linked-custom-select',
            toggleOnPartnerValue: false
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'LinkedCustomSelect',
            $e: o.$e || $(o.selector),
            partner: null,
            hasOptions: false,
            explicitInit: true,

            // Privates intended to be used internally
            components: {
                customControl: {
                    selector: '.custom-select-control'
                },
                nativeInput: {
                    selector: 'select'
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'change !partner': 'partnerChange',
                'field:error': 'fieldError'
            }
        };

        // Elements cache
        elements = {
            partner: null
        };

        // Primary methods
        fn = {
            beforeInit: function () {
                fn.linkToPartner();
            },

            // First link to partner, then initialize itself, then initialize
            // a custom select on itself as well, then finally set its state.
            init: function () {
                internal.customSelect = new CustomSelect({
                    $e: internal.$e
                });
                internal.customSelect.init();

                fn.filterOptions();
                fn.setState();
            },

            // Request the partner field from the form and cache it and its
            // primary element
            linkToPartner: function () {
                var partnerName, partnerField, $partner;

                partnerName = internal.$e.data('link-to');
                partnerField = o.form.getField(partnerName, o.fieldset.getClosestParentName());
                $partner = partnerField.getEl();

                elements.partner = $partner;
                internal.partner = partnerField;
            },

            // If the variant-linked-visibility class is applied, toggle the visibility
            // state based on the value of its partner.
            setState: function (forceShow) {
                var showSelf;

                if (internal.isVariant.linkedVisibility) {
                    showSelf = forceShow || !!internal.hasOptions && !internal.partner.isBlank();
                    internal.$e.toggleClass(m.VISIBLE, showSelf);
                }
            },

            forceShow: function () {
                fn.setState(true);

                if (internal.partner.forceShow) {
                    internal.partner.forceShow();
                }
            },

            // Check the options available to this instances customSelect and remove
            // and that are not valid based on their data-partner-value list.
            filterOptions: function () {
                var partnerVal = internal.partner.getVal();

                if (!partnerVal || !partnerVal.length) {
                    return;
                }

                internal.hasOptions = false;
                // First put all the options back...
                internal.customSelect.unfilter();
                // ...then filter them again.
                internal.customSelect.filter(function (i, option) {
                    var $option, optionPartnerVal, optionVal;

                    $option = $(option);
                    optionPartnerVal = $option.data('partnerValue');
                    optionVal = option.tagName === 'OPTION' ? $option.val() : $option.data('value');
                    optionVal = optionVal + ''; // Stringify the value so that it has a length

                    if (
                        optionVal.length &&
                        optionPartnerVal.split(',').indexOf(partnerVal) > -1
                    ) {
                        internal.hasOptions = true;
                    } else {
                        $option.remove();
                    }
                });
            },

            getVal: function () {
                if (internal.customSelect) {
                    return internal.customSelect.getVal();
                }
            },

            setVal: function (val, options) {
                if (internal.customSelect) {
                    internal.customSelect.setVal(val, options);
                }
            }
        };

        // Event handlers
        handlers = {
            // Listen to changes on the partner field and update this instance.
            partnerChange: function () {
                internal.customSelect.reset();
                fn.filterOptions();
                fn.setState();
            },

            fieldError: function () {
                fn.forceShow();
            }
        };

        api = {
            forceShow: fn.forceShow,
            getVal: fn.getVal,
            setVal: fn.setVal
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    // Module markup
    LinkedCustomSelect.markup = {};

    return LinkedCustomSelect;
});

/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define('DOMPurify', t) : (e = e || self).DOMPurify = t() }(this, (function () { "use strict"; var e = Object.hasOwnProperty, t = Object.setPrototypeOf, n = Object.isFrozen, r = Object.getPrototypeOf, o = Object.getOwnPropertyDescriptor, i = Object.freeze, a = Object.seal, l = Object.create, c = "undefined" != typeof Reflect && Reflect, s = c.apply, u = c.construct; s || (s = function (e, t, n) { return e.apply(t, n) }), i || (i = function (e) { return e }), a || (a = function (e) { return e }), u || (u = function (e, t) { return new (Function.prototype.bind.apply(e, [null].concat(function (e) { if (Array.isArray(e)) { for (var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t]; return n } return Array.from(e) }(t)))) }); var m, f = x(Array.prototype.forEach), d = x(Array.prototype.pop), p = x(Array.prototype.push), h = x(String.prototype.toLowerCase), g = x(String.prototype.match), y = x(String.prototype.replace), v = x(String.prototype.indexOf), b = x(String.prototype.trim), T = x(RegExp.prototype.test), A = (m = TypeError, function () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return u(m, t) }); function x(e) { return function (t) { for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)r[o - 1] = arguments[o]; return s(e, t, r) } } function S(e, r) { t && t(e, null); for (var o = r.length; o--;) { var i = r[o]; if ("string" == typeof i) { var a = h(i); a !== i && (n(r) || (r[o] = a), i = a) } e[i] = !0 } return e } function w(t) { var n = l(null), r = void 0; for (r in t) s(e, t, [r]) && (n[r] = t[r]); return n } function E(e, t) { for (; null !== e;) { var n = o(e, t); if (n) { if (n.get) return x(n.get); if ("function" == typeof n.value) return x(n.value) } e = r(e) } return function (e) { return console.warn("fallback value for", e), null } } var R = i(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), _ = i(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), N = i(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), D = i(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), k = i(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), O = i(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), M = i(["#text"]), L = i(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), F = i(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), I = i(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), C = i(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), z = a(/\{\{[\s\S]*|[\s\S]*\}\}/gm), H = a(/<%[\s\S]*|[\s\S]*%>/gm), U = a(/^data-[\-\w.\u00B7-\uFFFF]/), P = a(/^aria-[\-\w]+$/), j = a(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), B = a(/^(?:\w+script|data):/i), W = a(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; function q(e) { if (Array.isArray(e)) { for (var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t]; return n } return Array.from(e) } var Y = function () { return "undefined" == typeof window ? null : window }, K = function (e, t) { if ("object" !== (void 0 === e ? "undefined" : G(e)) || "function" != typeof e.createPolicy) return null; var n = null, r = "data-tt-policy-suffix"; t.currentScript && t.currentScript.hasAttribute(r) && (n = t.currentScript.getAttribute(r)); var o = "dompurify" + (n ? "#" + n : ""); try { return e.createPolicy(o, { createHTML: function (e) { return e } }) } catch (e) { return console.warn("TrustedTypes policy " + o + " could not be created."), null } }; return function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y(), n = function (t) { return e(t) }; if (n.version = "2.3.3", n.removed = [], !t || !t.document || 9 !== t.document.nodeType) return n.isSupported = !1, n; var r = t.document, o = t.document, a = t.DocumentFragment, l = t.HTMLTemplateElement, c = t.Node, s = t.Element, u = t.NodeFilter, m = t.NamedNodeMap, x = void 0 === m ? t.NamedNodeMap || t.MozNamedAttrMap : m, V = t.Text, X = t.Comment, $ = t.DOMParser, Z = t.trustedTypes, J = s.prototype, Q = E(J, "cloneNode"), ee = E(J, "nextSibling"), te = E(J, "childNodes"), ne = E(J, "parentNode"); if ("function" == typeof l) { var re = o.createElement("template"); re.content && re.content.ownerDocument && (o = re.content.ownerDocument) } var oe = K(Z, r), ie = oe && ze ? oe.createHTML("") : "", ae = o, le = ae.implementation, ce = ae.createNodeIterator, se = ae.createDocumentFragment, ue = ae.getElementsByTagName, me = r.importNode, fe = {}; try { fe = w(o).documentMode ? o.documentMode : {} } catch (e) { } var de = {}; n.isSupported = "function" == typeof ne && le && void 0 !== le.createHTMLDocument && 9 !== fe; var pe = z, he = H, ge = U, ye = P, ve = B, be = W, Te = j, Ae = null, xe = S({}, [].concat(q(R), q(_), q(N), q(k), q(M))), Se = null, we = S({}, [].concat(q(L), q(F), q(I), q(C))), Ee = null, Re = null, _e = !0, Ne = !0, De = !1, ke = !1, Oe = !1, Me = !1, Le = !1, Fe = !1, Ie = !1, Ce = !0, ze = !1, He = !0, Ue = !0, Pe = !1, je = {}, Be = null, We = S({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Ge = null, qe = S({}, ["audio", "video", "img", "source", "image", "track"]), Ye = null, Ke = S({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ve = "http://www.w3.org/1998/Math/MathML", Xe = "http://www.w3.org/2000/svg", $e = "http://www.w3.org/1999/xhtml", Ze = $e, Je = !1, Qe = void 0, et = ["application/xhtml+xml", "text/html"], tt = "text/html", nt = void 0, rt = null, ot = o.createElement("form"), it = function (e) { rt && rt === e || (e && "object" === (void 0 === e ? "undefined" : G(e)) || (e = {}), e = w(e), Ae = "ALLOWED_TAGS" in e ? S({}, e.ALLOWED_TAGS) : xe, Se = "ALLOWED_ATTR" in e ? S({}, e.ALLOWED_ATTR) : we, Ye = "ADD_URI_SAFE_ATTR" in e ? S(w(Ke), e.ADD_URI_SAFE_ATTR) : Ke, Ge = "ADD_DATA_URI_TAGS" in e ? S(w(qe), e.ADD_DATA_URI_TAGS) : qe, Be = "FORBID_CONTENTS" in e ? S({}, e.FORBID_CONTENTS) : We, Ee = "FORBID_TAGS" in e ? S({}, e.FORBID_TAGS) : {}, Re = "FORBID_ATTR" in e ? S({}, e.FORBID_ATTR) : {}, je = "USE_PROFILES" in e && e.USE_PROFILES, _e = !1 !== e.ALLOW_ARIA_ATTR, Ne = !1 !== e.ALLOW_DATA_ATTR, De = e.ALLOW_UNKNOWN_PROTOCOLS || !1, ke = e.SAFE_FOR_TEMPLATES || !1, Oe = e.WHOLE_DOCUMENT || !1, Fe = e.RETURN_DOM || !1, Ie = e.RETURN_DOM_FRAGMENT || !1, Ce = !1 !== e.RETURN_DOM_IMPORT, ze = e.RETURN_TRUSTED_TYPE || !1, Le = e.FORCE_BODY || !1, He = !1 !== e.SANITIZE_DOM, Ue = !1 !== e.KEEP_CONTENT, Pe = e.IN_PLACE || !1, Te = e.ALLOWED_URI_REGEXP || Te, Ze = e.NAMESPACE || $e, Qe = Qe = -1 === et.indexOf(e.PARSER_MEDIA_TYPE) ? tt : e.PARSER_MEDIA_TYPE, nt = "application/xhtml+xml" === Qe ? function (e) { return e } : h, ke && (Ne = !1), Ie && (Fe = !0), je && (Ae = S({}, [].concat(q(M))), Se = [], !0 === je.html && (S(Ae, R), S(Se, L)), !0 === je.svg && (S(Ae, _), S(Se, F), S(Se, C)), !0 === je.svgFilters && (S(Ae, N), S(Se, F), S(Se, C)), !0 === je.mathMl && (S(Ae, k), S(Se, I), S(Se, C))), e.ADD_TAGS && (Ae === xe && (Ae = w(Ae)), S(Ae, e.ADD_TAGS)), e.ADD_ATTR && (Se === we && (Se = w(Se)), S(Se, e.ADD_ATTR)), e.ADD_URI_SAFE_ATTR && S(Ye, e.ADD_URI_SAFE_ATTR), e.FORBID_CONTENTS && (Be === We && (Be = w(Be)), S(Be, e.FORBID_CONTENTS)), Ue && (Ae["#text"] = !0), Oe && S(Ae, ["html", "head", "body"]), Ae.table && (S(Ae, ["tbody"]), delete Ee.tbody), i && i(e), rt = e) }, at = S({}, ["mi", "mo", "mn", "ms", "mtext"]), lt = S({}, ["foreignobject", "desc", "title", "annotation-xml"]), ct = S({}, _); S(ct, N), S(ct, D); var st = S({}, k); S(st, O); var ut = function (e) { var t = ne(e); t && t.tagName || (t = { namespaceURI: $e, tagName: "template" }); var n = h(e.tagName), r = h(t.tagName); if (e.namespaceURI === Xe) return t.namespaceURI === $e ? "svg" === n : t.namespaceURI === Ve ? "svg" === n && ("annotation-xml" === r || at[r]) : Boolean(ct[n]); if (e.namespaceURI === Ve) return t.namespaceURI === $e ? "math" === n : t.namespaceURI === Xe ? "math" === n && lt[r] : Boolean(st[n]); if (e.namespaceURI === $e) { if (t.namespaceURI === Xe && !lt[r]) return !1; if (t.namespaceURI === Ve && !at[r]) return !1; var o = S({}, ["title", "style", "font", "a", "script"]); return !st[n] && (o[n] || !ct[n]) } return !1 }, mt = function (e) { p(n.removed, { element: e }); try { e.parentNode.removeChild(e) } catch (t) { try { e.outerHTML = ie } catch (t) { e.remove() } } }, ft = function (e, t) { try { p(n.removed, { attribute: t.getAttributeNode(e), from: t }) } catch (e) { p(n.removed, { attribute: null, from: t }) } if (t.removeAttribute(e), "is" === e && !Se[e]) if (Fe || Ie) try { mt(t) } catch (e) { } else try { t.setAttribute(e, "") } catch (e) { } }, dt = function (e) { var t = void 0, n = void 0; if (Le) e = "<remove></remove>" + e; else { var r = g(e, /^[\r\n\t ]+/); n = r && r[0] } "application/xhtml+xml" === Qe && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>"); var i = oe ? oe.createHTML(e) : e; if (Ze === $e) try { t = (new $).parseFromString(i, Qe) } catch (e) { } if (!t || !t.documentElement) { t = le.createDocument(Ze, "template", null); try { t.documentElement.innerHTML = Je ? "" : i } catch (e) { } } var a = t.body || t.documentElement; return e && n && a.insertBefore(o.createTextNode(n), a.childNodes[0] || null), Ze === $e ? ue.call(t, Oe ? "html" : "body")[0] : Oe ? t.documentElement : a }, pt = function (e) { return ce.call(e.ownerDocument || e, e, u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT, null, !1) }, ht = function (e) { return !(e instanceof V || e instanceof X) && !("string" == typeof e.nodeName && "string" == typeof e.textContent && "function" == typeof e.removeChild && e.attributes instanceof x && "function" == typeof e.removeAttribute && "function" == typeof e.setAttribute && "string" == typeof e.namespaceURI && "function" == typeof e.insertBefore) }, gt = function (e) { return "object" === (void 0 === c ? "undefined" : G(c)) ? e instanceof c : e && "object" === (void 0 === e ? "undefined" : G(e)) && "number" == typeof e.nodeType && "string" == typeof e.nodeName }, yt = function (e, t, r) { de[e] && f(de[e], (function (e) { e.call(n, t, r, rt) })) }, vt = function (e) { var t = void 0; if (yt("beforeSanitizeElements", e, null), ht(e)) return mt(e), !0; if (g(e.nodeName, /[\u0080-\uFFFF]/)) return mt(e), !0; var r = nt(e.nodeName); if (yt("uponSanitizeElement", e, { tagName: r, allowedTags: Ae }), !gt(e.firstElementChild) && (!gt(e.content) || !gt(e.content.firstElementChild)) && T(/<[/\w]/g, e.innerHTML) && T(/<[/\w]/g, e.textContent)) return mt(e), !0; if ("select" === r && T(/<template/i, e.innerHTML)) return mt(e), !0; if (!Ae[r] || Ee[r]) { if (Ue && !Be[r]) { var o = ne(e) || e.parentNode, i = te(e) || e.childNodes; if (i && o) for (var a = i.length - 1; a >= 0; --a)o.insertBefore(Q(i[a], !0), ee(e)) } return mt(e), !0 } return e instanceof s && !ut(e) ? (mt(e), !0) : "noscript" !== r && "noembed" !== r || !T(/<\/no(script|embed)/i, e.innerHTML) ? (ke && 3 === e.nodeType && (t = e.textContent, t = y(t, pe, " "), t = y(t, he, " "), e.textContent !== t && (p(n.removed, { element: e.cloneNode() }), e.textContent = t)), yt("afterSanitizeElements", e, null), !1) : (mt(e), !0) }, bt = function (e, t, n) { if (He && ("id" === t || "name" === t) && (n in o || n in ot)) return !1; if (Ne && !Re[t] && T(ge, t)); else if (_e && T(ye, t)); else { if (!Se[t] || Re[t]) return !1; if (Ye[t]); else if (T(Te, y(n, be, ""))); else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== v(n, "data:") || !Ge[e]) { if (De && !T(ve, y(n, be, ""))); else if (n) return !1 } else; } return !0 }, Tt = function (e) { var t = void 0, r = void 0, o = void 0, i = void 0; yt("beforeSanitizeAttributes", e, null); var a = e.attributes; if (a) { var l = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: Se }; for (i = a.length; i--;) { var c = t = a[i], s = c.name, u = c.namespaceURI; if (r = b(t.value), o = nt(s), l.attrName = o, l.attrValue = r, l.keepAttr = !0, l.forceKeepAttr = void 0, yt("uponSanitizeAttribute", e, l), r = l.attrValue, !l.forceKeepAttr && (ft(s, e), l.keepAttr)) if (T(/\/>/i, r)) ft(s, e); else { ke && (r = y(r, pe, " "), r = y(r, he, " ")); var m = nt(e.nodeName); if (bt(m, o, r)) try { u ? e.setAttributeNS(u, s, r) : e.setAttribute(s, r), d(n.removed) } catch (e) { } } } yt("afterSanitizeAttributes", e, null) } }, At = function e(t) { var n = void 0, r = pt(t); for (yt("beforeSanitizeShadowDOM", t, null); n = r.nextNode();)yt("uponSanitizeShadowNode", n, null), vt(n) || (n.content instanceof a && e(n.content), Tt(n)); yt("afterSanitizeShadowDOM", t, null) }; return n.sanitize = function (e, o) { var i = void 0, l = void 0, s = void 0, u = void 0, m = void 0; if ((Je = !e) && (e = "\x3c!--\x3e"), "string" != typeof e && !gt(e)) { if ("function" != typeof e.toString) throw A("toString is not a function"); if ("string" != typeof (e = e.toString())) throw A("dirty is not a string, aborting") } if (!n.isSupported) { if ("object" === G(t.toStaticHTML) || "function" == typeof t.toStaticHTML) { if ("string" == typeof e) return t.toStaticHTML(e); if (gt(e)) return t.toStaticHTML(e.outerHTML) } return e } if (Me || it(o), n.removed = [], "string" == typeof e && (Pe = !1), Pe); else if (e instanceof c) 1 === (l = (i = dt("\x3c!----\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === l.nodeName || "HTML" === l.nodeName ? i = l : i.appendChild(l); else { if (!Fe && !ke && !Oe && -1 === e.indexOf("<")) return oe && ze ? oe.createHTML(e) : e; if (!(i = dt(e))) return Fe ? null : ie } i && Le && mt(i.firstChild); for (var f = pt(Pe ? e : i); s = f.nextNode();)3 === s.nodeType && s === u || vt(s) || (s.content instanceof a && At(s.content), Tt(s), u = s); if (u = null, Pe) return e; if (Fe) { if (Ie) for (m = se.call(i.ownerDocument); i.firstChild;)m.appendChild(i.firstChild); else m = i; return Ce && (m = me.call(r, m, !0)), m } var d = Oe ? i.outerHTML : i.innerHTML; return ke && (d = y(d, pe, " "), d = y(d, he, " ")), oe && ze ? oe.createHTML(d) : d }, n.setConfig = function (e) { it(e), Me = !0 }, n.clearConfig = function () { rt = null, Me = !1 }, n.isValidAttribute = function (e, t, n) { rt || it({}); var r = nt(e), o = nt(t); return bt(r, o, n) }, n.addHook = function (e, t) { "function" == typeof t && (de[e] = de[e] || [], p(de[e], t)) }, n.removeHook = function (e) { de[e] && d(de[e]) }, n.removeHooks = function (e) { de[e] && (de[e] = []) }, n.removeAllHooks = function () { de = {} }, n }() }));
//# sourceMappingURL=purify.min.js.map
;
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define('Typester', factory) :
            (global.Typester = factory());
}(this, (function () {
    'use strict';

    // Production steps of ECMA-262, Edition 5, 15.4.4.18
    // Reference: http://es5.github.io/#x15.4.4.18
    if (!Array.prototype.forEach) {

        Array.prototype.forEach = function (callback /*, thisArg*/) {

            var T, k;

            if (this == null) {
                throw new TypeError('this is null or not defined');
            }

            // 1. Let O be the result of calling toObject() passing the
            // |this| value as the argument.
            var O = Object(this);

            // 2. Let lenValue be the result of calling the Get() internal
            // method of O with the argument "length".
            // 3. Let len be toUint32(lenValue).
            var len = O.length >>> 0;

            // 4. If isCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            // 5. If thisArg was supplied, let T be thisArg; else let
            // T be undefined.
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // 6. Let k be 0
            k = 0;

            // 7. Repeat, while k < len
            while (k < len) {

                var kValue;

                // a. Let Pk be ToString(k).
                //    This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty
                //    internal method of O with argument Pk.
                //    This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {

                    // i. Let kValue be the result of calling the Get internal
                    // method of O with argument Pk.
                    kValue = O[k];

                    // ii. Call the Call internal method of callback with T as
                    // the this value and argument list containing kValue, k, and O.
                    callback.call(T, kValue, k, O);
                }
                // d. Increase k by 1.
                k++;
            }
            // 8. return undefined
        };
    }

    if (window.NodeList && !NodeList.prototype.forEach) {
        NodeList.prototype.forEach = function (callback, thisArg) {
            thisArg = thisArg || window;
            for (var i = 0; i < this.length; i++) {
                callback.call(thisArg, this[i], i, this);
            }
        };
    }

    if (typeof Object.assign !== 'function') {
        Object.assign = function (target) {
            // .length of function is 2
            'use strict';

            var to, index, nextSource, nextKey;

            if (target === null) {
                // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            to = Object(target);

            for (index = 1; index < arguments.length; index++) {
                nextSource = arguments[index];

                if (nextSource !== null) {
                    // Skip over if undefined or null
                    for (nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }

    // jshint strict: false

    /**
     * guid - generates guids.
     * @access protected
     * @return {string}  guid
     */
    var guid = function guid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    };

    // jshint strict: false
    /**
     * Mediator - The glue that holds the entire app together. Nothing can cross
     * communicate without going through the mediator.
     *
     * There are 3 kinds of messages: Commands, Requests, Events.
     *
     * Commands - One-to-one message with no response.
     * Requests - One-to-one message with a response.
     * Events - One-to-many message with no response.
     *
     * @access protected
     * @module core/Mediator
     *
     * @requires utils/guid
     *
     * @example
     * const mediator = new Mediator({
     *   parent: someOtherMediator,
     *   conceal: [/modulename:.*?/]
     * });
     *
     * mediator.getId() // Returns the uid of the mediator
     *
     * // Register handlers
     * mediator.registerRequestHandlers({ 'handler:call:string': function handler (opts) {} })
     * mediator.registerCommandHandlers({ 'handler:call:string': function handler (opts) {} })
     * mediator.registerEventHandlers({ 'event:emit:string': function handler (opts) {} })
     * // registerHandler(type, handlerCallString, handlerFunction)
     * mediator.registerHandler('request', 'handler:call:string', function handler (opts) {} )
     *
     * // Call a request handler
     * mediator.request('handler:call:string', opts) // opts will be passed on to the handler
     * mediator.get('handler:call:string', opts)
     *
     * // Call a command handler
     * mediator.exec('handler:call:string', opts) // opts will be passed on to the handler
     *
     * // Emit an event and trigger an event handler
     * mediator.emit('event:emit:string', opts) // opts will be passed on to the handler
     *
     * // Check if a handler has been registered and a call string or emit string can be handled
     * mediator.canHandle('some:other:call:string') // --> true / false
     *
     * // Handle a call string or emit string message by type
     * mediator.handle('request', 'request:call:string', args, opts) // args will be passed along to the handle, opts allows for call specific options
     *
     * // Register a child mediator
     * mediator.registerChild(mediator)
     *
     * // Deregister a child mediator
     * mediator.deregisterChild(mediator)
     *
     * // Set the parent for the mediator
     * mediator.setParent(mediator)
     *
     * // Delegate a command, request, or event to either child mediators or parents.
     * mediator.delegate('command', 'command:call:string', args, opts) // args will be passed along to the handle, opts allows for call specific options
     *
     */

    /**
     * @constructor
     * @param {object} opts - Mediator options
     * @param {mediator} opts.parent - A parent mediator to delegate to if necessary
     * @param {Array<RegExp>} opts.conceal - An array of regular expressions to test the request, command and event keys against to determine whether they should get delegated if unhandled
     */
    var Mediator = function Mediator() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


        /**
         * @prop {object} internal - The internal options and state object of the mediator instance
         * @access protected
         */
        var internal = {
            parent: opts.parent,
            children: [],
            id: guid(),
            conceal: opts.conceal || []
        };

        /**
         * @prop {object} requests
         * @namespace
         * @desc The requests object that stores requests and offers methods to interact with them
         * @access protected
         */
        var requests = {

            /**
             * @prop {object} handlers - An enumerable object store of regitered request key/handler pairs.
             */
            handlers: {},

            /**
             * @func new
             * @desc register a new request key/handler pair. Check if an existing handler is present for the key and throw and error if there is
             * @param  {string} requestKey     the key/call string for the handler. e.g. modulename:get:value
             * @param  {function} requestHandler the handler method to be called
             * @return {any}                the response from the handler method
             */
            new: function _new(requestKey, requestHandler) {
                if (requests.handlers[requestKey]) {
                    throw new Error('Only one requestHandler per requestKey: ' + requestKey);
                }

                requests.handlers[requestKey] = requestHandler;
            },
            getHandler: function getHandler(requestKey) {
                return requests.handlers[requestKey];
            },
            canHandle: function canHandle(requestKey) {
                return !!requests.getHandler(requestKey);
            },
            request: function request(requestKey, options) {
                var requestHandler = requests.getHandler(requestKey);

                if (requestHandler) {
                    return requestHandler(options);
                }
            }
        };

        /**
         * @private
         */
        var commands = {
            handlers: {},

            new: function _new(commandKey, commandHandler) {
                if (commands.handlers[commandKey]) {
                    throw new Error('Only one commandHandler per commandKey: ' + commandKey);
                }

                commands.handlers[commandKey] = commandHandler;
            },
            getHandler: function getHandler(commandKey) {
                return commands.handlers[commandKey];
            },
            canHandle: function canHandle(commandKey) {
                return !!commands.getHandler(commandKey);
            },
            exec: function exec(commandKey, options) {
                var commandHandler = commands.getHandler(commandKey);
                if (commandHandler) {
                    commandHandler(options);
                }
            }
        };

        /**
         * @private
         */
        var events = {
            handlers: {},

            new: function _new(eventKey, eventHandler) {
                events.handlers[eventKey] = events.handlers[eventKey] || [];
                events.handlers[eventKey].push(eventHandler);
            },
            getHandlers: function getHandlers(eventKey) {
                return events.handlers[eventKey] || [];
            },
            canHandle: function canHandle(eventKey) {
                return !!events.getHandlers(eventKey);
            },
            emit: function emit(eventKey, options) {
                var eventHandlers = events.getHandlers(eventKey);
                if (eventHandlers.length) {
                    eventHandlers.forEach(function (eventHandler) {
                        return eventHandler(options);
                    });
                }
            }
        };

        /**
         * @private
         */
        var registers = {
            registerHandler: function registerHandler(type, typeKey, typeHandler) {
                switch (type) {
                    case 'request':
                        requests.new(typeKey, typeHandler);
                        break;
                    case 'command':
                        commands.new(typeKey, typeHandler);
                        break;
                    case 'event':
                        events.new(typeKey, typeHandler);
                        break;
                }
            },
            registerRequestHandlers: function registerRequestHandlers() {
                var requestHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                Object.keys(requestHandlers).forEach(function (requestKey) {
                    var requestHandler = requestHandlers[requestKey];
                    registers.registerHandler('request', requestKey, requestHandler);
                });
            },
            registerCommandHandlers: function registerCommandHandlers() {
                var commandHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                Object.keys(commandHandlers).forEach(function (commandKey) {
                    var commandHandler = commandHandlers[commandKey];
                    registers.registerHandler('command', commandKey, commandHandler);
                });
            },
            registerEventHandlers: function registerEventHandlers() {
                var eventHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                Object.keys(eventHandlers).forEach(function (eventKey) {
                    var eventHandler = eventHandlers[eventKey];
                    registers.registerHandler('event', eventKey, eventHandler);
                });
            }
        };

        /**
         * @private
         */
        var fn = {
            init: function init() {
                if (internal.parent) {
                    internal.parent.registerChild(api);
                }
            },
            shouldConceal: function shouldConceal(msgKey) {
                var shouldConceal = false;

                internal.conceal.forEach(function (concealPattern) {
                    shouldConceal = shouldConceal || concealPattern.test(msgKey);
                });

                return shouldConceal;
            },
            delegate: function delegate(type, msgKey) {
                var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
                var _state = opts._state;


                if (!_state.hasAttempted(internal.id)) {
                    fn.handle(type, msgKey, args, opts);
                }

                if (!_state.hasBeenHandled) {
                    internal.children.forEach(function (childMediator) {
                        if (!_state.hasBeenHandled && !_state.hasAttempted(childMediator.getId())) {
                            childMediator.handle(type, msgKey, args, opts);
                        }
                    });
                }

                if (!_state.hasBeenHandled) {
                    if (internal.parent && !_state.hasAttempted(internal.parent.getId()) && !fn.shouldConceal(msgKey)) {
                        internal.parent.delegate(type, msgKey, args, opts);
                    }
                }

                return _state.response;
            },
            canHandle: function canHandle(type, msgKey) {
                switch (type) {
                    case 'request':
                        return requests.canHandle(msgKey);
                    case 'command':
                        return commands.canHandle(msgKey);
                    case 'event':
                        return events.canHandle(msgKey);
                }
            },
            handle: function handle(type, msgKey) {
                var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

                opts._state = opts._state || fn.newStateObj();

                var canHandle = fn.canHandle(type, msgKey);
                var _state = opts._state;


                if (_state.hasAttempted(internal.id)) {
                    return _state.response;
                }

                opts._state.logAttempt(internal.id);
                if (canHandle) {
                    switch (type) {
                        case 'request':
                            _state.response = requests.request(msgKey, args);
                            _state.hasBeenHandled = true;
                            break;
                        case 'command':
                            commands.exec(msgKey, args);
                            _state.hasBeenHandled = true;
                            break;
                        case 'event':
                            events.emit(msgKey, args);
                            fn.delegate(type, msgKey, args, opts);
                            break;
                    }

                    return _state.response;
                } else {
                    return fn.delegate(type, msgKey, args, opts);
                }
            },
            newStateObj: function newStateObj() {
                var stateObj = {
                    attempts: [],
                    hasBeenHandled: false,
                    response: null,
                    logAttempt: function logAttempt(mediatorId) {
                        this.attempts.push(mediatorId);
                    },
                    hasAttempted: function hasAttempted(mediatorId) {
                        return this.attempts.indexOf(mediatorId) > -1;
                    }
                };

                return stateObj;
            },
            request: function request(requestKey) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                return fn.handle('request', requestKey, opts);
            },
            exec: function exec(commandKey) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                fn.handle('command', commandKey, opts);
            },
            emit: function emit(eventKey) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                fn.handle('event', eventKey, opts);
            },


            // NB: Seems like this isn't actually being used.
            hasAttemptedToHandle: function hasAttemptedToHandle(opts) {
                return opts.attemptedDelegates.indexOf(internal.id) > -1;
            },
            registerChild: function registerChild(childApi) {
                childApi.childIndex = internal.children.length;
                internal.children.push(childApi);
            },
            deregisterChild: function deregisterChild(childApi) {
                internal.children.slice(childApi.childIndex, 1);
            },
            setParent: function setParent(parentApi) {
                if (internal.parent) {
                    internal.parent.deregisterChild(api);
                }

                internal.parent = parentApi;
                internal.parent.registerChild(api);
            },
            getId: function getId() {
                return internal.id;
            }
        };

        /**
         * @public
         */
        var api = {
            getId: fn.getId,
            registerRequestHandlers: registers.registerRequestHandlers,
            registerCommandHandlers: registers.registerCommandHandlers,
            registerEventHandlers: registers.registerEventHandlers,
            registerHandler: registers.registerHandler,
            request: fn.request,
            exec: fn.exec,
            emit: fn.emit,
            get: fn.request,
            canHandle: fn.canHandle,
            handle: fn.handle,
            registerChild: fn.registerChild,
            hasAttemptedToHandle: fn.hasAttemptedToHandle,
            deregisterChild: fn.deregisterChild,
            setParent: fn.setParent,
            delegate: fn.delegate,

            // NB this also doesn't seem to be used anywhere.
            getHandlerKeys: function getHandlerKeys() {
                var handlers = [];

                handlers.concat(Object.keys(requests.handlers));
                handlers.concat(Object.keys(commands.handlers));
                handlers.concat(Object.keys(events.handlers));

                return handlers;
            }
        };

        fn.init();

        return api;
    };

    // jshint strict: false


    /**
     * Context -
     * Instance safe context builder that can mixin multiple additional objects as
     * contexts. These can then be used to bind methods into a shared context.
     *
     * @module core/Context
     * @access protected
     *
     * @example
     * let context = new Context({ ping: 'pong' });
     * // context.ping = 'pong'
     *
     * context.mixin({ foo: 'bar' }, { jim: 'jam' })
     * // context.foo = 'bar'
     * // context.jim = 'jam'
     *
     * context.extendWith({ bing: 'bong', bang: 'boom' }, { keys: ['bing'] })
     * // context.bing = 'bong'
     * // context.bang = undefined
     */

    /** @constructor Context */
    var Context = function Context() {
        this.mixin.apply(this, arguments);
    };

    Object.assign(Context.prototype, {
        /**
         * mixin - accepts additional contexts to mixin into itself
         * @param  {Array<Object>} ...contexts description
         */
        mixin: function mixin() {
            var _this = this;

            for (var _len = arguments.length, contexts = Array(_len), _key = 0; _key < _len; _key++) {
                contexts[_key] = arguments[_key];
            }

            contexts.forEach(function (context) {
                Object.assign(_this, context);
            });
        },


        /**
         * extendWith - extend the current context with a single object. Allows for
         * the specification of specific keys to be cherry picked of the passed in
         * object.
         *
         * @param  {object} mixinContext the additional context to mix into the current context.
         * @param  {object} opts={}      options to allow for fine grained mixing in.
         * @param  {Array<string>} opts.keys a list of keys to cherry pick from the additional context.
         */
        extendWith: function extendWith(mixinContext) {
            var _this2 = this;

            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (opts.keys) {
                opts.keys.forEach(function (key) {
                    _this2[key] = mixinContext[key];
                });
            } else {
                this.mixin(mixinContext);
            }
        }
    });

    // jshint strict: false

    /**
     * func -
     * namespaced collection of utililty methods for binding function contexts.
     * @access protected
     */
    var func = {
        bind: function bind(func, context) {
            return function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                return func.apply(context, args);
            };
        },
        bindObj: function bindObj(funcObj, context) {
            var boundFuncObj = {};

            Object.keys(funcObj).forEach(function (funcKey) {
                boundFuncObj[funcKey] = func.bind(funcObj[funcKey], context);
            });

            return boundFuncObj;
        }
    };

    // jshint strict: false

    /**
     * Container -
     * A factory for building container classes.
     * Containers are built up of a mediator instance that is shared with its child
     * modules.
     *
     * @module core/Container
     * @access protected
     *
     * @param  {object} containerObj - **(Required)** A descriptor of the container
     * @param  {string} containerObj.name - **(Required)** The name of the container
     * @param  {object} containerObj.handlers - A map of mediator event strings and method names: 'event:string' : 'methodName'.
     *                                          Event strings are then mapped to the named method.
     * @param  {object} containerObj.methods - A map of named methods.
     * @param  {array} containerObj.modules - An array of modules to be instantiated by the container. [{ class: ModuleClass }]
     * @param  {object} containerObj.mediatorOpts - A map of options to be passed on to the {@link Mediator}.
     * @param  {mediator} containerObj.mediator - A mediator instance to act as a parent for the mediator instance created in this container.
     *
     * @return {function} - A container class that can be instantiated.
     *
     * @example
     * import MyModule from '../modules/MyModule.js';
     *
     * const MyContainer = Container({
     *   name: 'MyContainer',
     *   modules: [
     *     { class: MyModule }
     *   ],
     *   handlers: {
     *     requests: { // Request handlers mapped to methods & registered with the mediator
     *       'mycontainer:request:something' : 'getSomething'
     *     },
     *     commands: { // Command handlers mapped to methods & registered with the mediator
     *       'mycontainer:do:something' : 'doSomething'
     *     },
     *     events: { // Event handlers mapped to methods & registered with the mediator
     *       'module:event' : 'handlerMethod'
     *     }
     *   },
     *   methods: {
     *     setup () {}, // A setup hook called before modules and child containers are initialized.
     *     init () {} // An init hook called after all modules and child containers have been initialized.
     *
     *     // The rest of the methods required for this container.
     *     getSomething () {},
     *     doSomething () {},
     *     handlerMethod () {}
     *   }
     * });
     *
     * const myContainer = new MyContainer(containerOpts);
     *
     * // myContainer has a method you can use to update the parent mediator using:
     * myContainer.setMediatorParent(mediatorInstance);
     */

    var Container = function Container(containerObj) {
        var containerName = containerObj.name,
            containerHandlers = containerObj.handlers,
            containerMethods = containerObj.methods,
            containerModules = containerObj.modules,
            containerChildContainers = containerObj.containers,
            mediatorOpts = containerObj.mediatorOpts;


        if (!containerName) {
            throw new Error('No name given for container');
        }

        var containerUtils = {
            createContext: function createContext() {
                for (var _len = arguments.length, contexts = Array(_len), _key = 0; _key < _len; _key++) {
                    contexts[_key] = arguments[_key];
                }

                return new (Function.prototype.bind.apply(Context, [null].concat(contexts)))();
            },
            bindMethods: function bindMethods(methods, context) {
                methods = methods || {};
                return func.bindObj(methods, context);
            },
            initModules: function initModules() {
                var modules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                modules.forEach(function (module) {
                    var moduleOpts = Object.assign({}, opts, module.opts || {});
                    module.instance = new module.class(moduleOpts);
                });
            },
            initChildContainers: function initChildContainers() {
                var childContainers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                childContainers.forEach(function (containerObj) {
                    var containerOpts = Object.assign({}, opts, containerObj.opts || {});
                    containerObj.instance = new containerObj.class(containerOpts);
                });
            },
            registerHandlers: function registerHandlers(mediator, handlers, context) {
                Object.keys(handlers).forEach(function (handlerKey) {
                    var handlerMap = handlers[handlerKey];
                    var handlerMethods = containerUtils.getHandlerMethods(handlerMap, context);

                    switch (handlerKey) {
                        case 'requests':
                            mediator.registerRequestHandlers(handlerMethods);
                            break;
                        case 'commands':
                            mediator.registerCommandHandlers(handlerMethods);
                            break;
                        case 'events':
                            mediator.registerEventHandlers(handlerMethods);
                            break;
                    }
                });
            },
            getHandlerMethods: function getHandlerMethods(handlerMap, context) {
                var routedHandlers = {};

                Object.keys(handlerMap).forEach(function (commandStr) {
                    var methodKey = handlerMap[commandStr];
                    var handlerMethod = context[methodKey];
                    routedHandlers[commandStr] = handlerMethod;
                });

                return routedHandlers;
            }
        };

        var containerProto = {
            containerConstructor: function containerConstructor() {
                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                var context = containerUtils.createContext();
                var boundMethods = containerUtils.bindMethods(containerMethods, context);
                context.extendWith(boundMethods);
                var mediator = new Mediator(Object.assign({ parent: opts.mediator }, mediatorOpts));
                context.extendWith({ mediator: mediator });

                if (containerHandlers) {
                    containerUtils.registerHandlers(mediator, containerHandlers, context);
                }

                if (boundMethods.setup) {
                    boundMethods.setup();
                }

                containerUtils.initModules(containerModules, {
                    dom: opts.dom,
                    mediator: mediator
                });

                containerUtils.initChildContainers(containerChildContainers, {
                    dom: opts.dom,
                    mediator: mediator
                });

                if (boundMethods.init) {
                    boundMethods.init();
                }

                return {
                    setMediatorParent: function setMediatorParent(parentMediator) {
                        mediator.setParent(parentMediator);
                    }
                };
            }
        };

        return containerProto.containerConstructor;
    };

    // jshint strict: false

    /**
     * browser -
     * a utility to check browser version.
     * @access protected
     */
    var browser = {
        // From https://codepen.io/gapcode/pen/vEJNZN
        ieVersion: function ieVersion() {
            var ua = window.navigator.userAgent;

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },
        isIE: function isIE() {
            var ieVersion = browser.ieVersion();
            return ieVersion && ieVersion < 12;
        },
        isFirefox: function isFirefox() {
            return window.navigator.userAgent.indexOf('Firefox') > -1;
        }
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };





    var asyncGenerator = function () {
        function AwaitValue(value) {
            this.value = value;
        }

        function AsyncGenerator(gen) {
            var front, back;

            function send(key, arg) {
                return new Promise(function (resolve, reject) {
                    var request = {
                        key: key,
                        arg: arg,
                        resolve: resolve,
                        reject: reject,
                        next: null
                    };

                    if (back) {
                        back = back.next = request;
                    } else {
                        front = back = request;
                        resume(key, arg);
                    }
                });
            }

            function resume(key, arg) {
                try {
                    var result = gen[key](arg);
                    var value = result.value;

                    if (value instanceof AwaitValue) {
                        Promise.resolve(value.value).then(function (arg) {
                            resume("next", arg);
                        }, function (arg) {
                            resume("throw", arg);
                        });
                    } else {
                        settle(result.done ? "return" : "normal", result.value);
                    }
                } catch (err) {
                    settle("throw", err);
                }
            }

            function settle(type, value) {
                switch (type) {
                    case "return":
                        front.resolve({
                            value: value,
                            done: true
                        });
                        break;

                    case "throw":
                        front.reject(value);
                        break;

                    default:
                        front.resolve({
                            value: value,
                            done: false
                        });
                        break;
                }

                front = front.next;

                if (front) {
                    resume(front.key, front.arg);
                } else {
                    back = null;
                }
            }

            this._invoke = send;

            if (typeof gen.return !== "function") {
                this.return = undefined;
            }
        }

        if (typeof Symbol === "function" && Symbol.asyncIterator) {
            AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
                return this;
            };
        }

        AsyncGenerator.prototype.next = function (arg) {
            return this._invoke("next", arg);
        };

        AsyncGenerator.prototype.throw = function (arg) {
            return this._invoke("throw", arg);
        };

        AsyncGenerator.prototype.return = function (arg) {
            return this._invoke("return", arg);
        };

        return {
            wrap: function (fn) {
                return function () {
                    return new AsyncGenerator(fn.apply(this, arguments));
                };
            },
            await: function (value) {
                return new AwaitValue(value);
            }
        };
    }();



































    var slicedToArray = function () {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);

                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }

            return _arr;
        }

        return function (arr, i) {
            if (Array.isArray(arr)) {
                return arr;
            } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
            } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
        };
    }();

    // jshint strict: false
    /* eslint-disable no-alert, no-console */

    /**
     * DOM -
     * namespaced collection of utility methods for working with the DOM.
     * @access protected
     */
    var DOM = {
        regex: {
            getById: /^#/,
            getByClassName: /^\./,
            getByTag: /^[a-z]/
        },

        getElements: function getElements(elementsObj, rootEl) {
            for (var elementKey in elementsObj) {
                if (elementsObj.hasOwnProperty(elementKey) && elementKey !== 'rootEl') {
                    var elementObj = elementsObj[elementKey];
                    var selector = elementObj.selector;


                    rootEl = elementObj.rootEl || rootEl;
                    rootEl = typeof rootEl === 'function' ? rootEl() : rootEl;

                    elementObj.el = DOM.get(selector, rootEl);
                }
            }
        },


        // Public methods
        get: function get$$1(selector) {
            var domRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

            if (DOM.isElement(selector)) {
                return [selector];
            }
            var getMethodName = DOM._getGetMethodName(selector);
            return DOM[getMethodName](selector, domRoot);
        },
        getByClassName: function getByClassName(className) {
            var domRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

            className = DOM._cleanSelector(className);
            return domRoot.getElementsByClassName(className);
        },
        getByTag: function getByTag(tag) {
            var domRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

            tag = DOM._cleanSelector(tag);
            return domRoot.getElementsByTagName(tag);
        },
        getById: function getById(id) {
            return document.getElementById(id);
        },
        getClosest: function getClosest(node, selector, ceilNode) {
            var rootEl = ceilNode || DOM.getRootEl();
            var checkType = /^\[/.test(selector) ? 'attribute' : /^\./.test(selector) ? 'class' : /^\#/.test(selector) ? 'id' : 'tag';

            var returnNode = false;
            var attrName = void 0,
                className = void 0,
                idStr = void 0,
                parentId = void 0;

            if (node === rootEl) {
                return null;
            }

            while (node.nodeType !== Node.ELEMENT_NODE) {
                node = node.parentNode;
            }

            switch (checkType) {
                case 'attribute':
                    attrName = selector.match(/\[(.*?)\]/)[1];
                    returnNode = node.hasAttribute(attrName);
                    break;
                case 'class':
                    className = selector.replace('.', '');
                    returnNode = node.classList && node.classList.contains(className);
                    break;
                case 'id':
                    idStr = selector.replace('#', '');
                    parentId = node.getAttribute('id');
                    returnNode = idStr === parentId;
                    break;
                case 'tag':
                    returnNode = node.nodeName.toLowerCase() === selector.toLowerCase();
                    break;
            }

            if (returnNode) {
                return node;
            } else {
                return DOM.getClosest(node.parentNode, selector, rootEl);
            }
        },
        getClosestInArray: function getClosestInArray(node, nameArray, ceilNode) {
            var parentNode = node;

            while (nameArray.indexOf(parentNode.nodeName) < 0 && parentNode !== ceilNode) {
                parentNode = parentNode.parentNode;
            }

            if (parentNode !== ceilNode) {
                return parentNode;
            } else {
                return null;
            }
        },
        getFurthest: function getFurthest(node, selector) {
            var rootEl = DOM.getRootEl();
            var currentNode = node;
            var furthest = null;

            selector = selector instanceof Array ? selector : [selector];

            while (currentNode && currentNode !== rootEl) {
                if (selector.indexOf(currentNode.nodeName) > -1) {
                    furthest = currentNode;
                }
                currentNode = currentNode.parentNode || currentNode.parentElement;
            }

            return furthest;
        },
        nextNode: function nextNode(node) {
            if (node.hasChildNodes()) {
                return node.firstChild;
            } else {
                while (node && !node.nextSibling) {
                    node = node.parentNode;
                }
                if (!node) {
                    return null;
                }
                return node.nextSibling;
            }
        },
        appendTo: function appendTo(selector, tag) {
            var htmlNode = DOM.isElement(tag) ? tag : document.createElement(tag);
            var targetEl = DOM.get(selector);

            for (var i = 0; i < targetEl.length; i++) {
                targetEl[i].appendChild(htmlNode);
            }

            return htmlNode;
        },
        addStyles: function addStyles(styles) {
            var styleEl = DOM.appendTo('head', 'style');

            styleEl.setAttribute('id', 'typester-styles');
            styleEl.setAttribute('type', 'text/css');

            if (styleEl.styleSheet) {
                styleEl.styleSheet.cssText = styles;
            } else {
                styleEl.appendChild(document.createTextNode(styles));
            }

            return styleEl;
        },


        // From http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
        isNode: function isNode(o) {
            return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? o instanceof Node : o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && typeof o.nodeType === 'number' && typeof o.nodeName === 'string';
        },
        isElement: function isElement(elem) {
            var isElement = false;

            isElement = elem instanceof Window || elem instanceof Document;
            isElement = isElement || (typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object' && elem instanceof HTMLElement;
            isElement = isElement || elem && (typeof elem === 'undefined' ? 'undefined' : _typeof(elem)) === 'object' && elem !== null && elem.nodeType === 1 && typeof elem.nodeName === 'string';

            return isElement;
        },
        isIn: function isIn(node, nodeName, ceilNode) {
            var isIn = false;
            var currentNode = node;
            var nameArray = nodeName instanceof Array ? nodeName : nodeName.split('/');

            ceilNode = ceilNode || DOM.getRootEl();
            nameArray = nameArray.map(function (name) {
                return name.toLowerCase();
            });

            while (!isIn && currentNode !== ceilNode) {
                isIn = nameArray.indexOf(currentNode.nodeName.toLowerCase()) > -1;
                currentNode = currentNode.parentNode;
            }

            return isIn;
        },
        isChildOf: function isChildOf(childNode, parentNode) {
            if (childNode instanceof Array) {
                childNode = childNode[0];
            }

            if (parentNode instanceof Array) {
                parentNode = parentNode[0];
            }

            return parentNode && childNode && parentNode.contains(childNode);
        },
        addClass: function addClass(el, classStr) {
            el.classList.add(classStr);
        },
        toggleClass: function toggleClass(el, classStr, force) {
            var addClass = force !== undefined ? force : !el.classList.contains(classStr);

            if (addClass) {
                DOM.addClass(el, classStr);
            } else {
                DOM.removeClass(el, classStr);
            }
        },
        removeClass: function removeClass(el, classStr) {
            el.classList.remove(classStr);
        },
        isBlock: function isBlock(node) {
            return DOM.getStyle(node, 'display') === 'block';
        },
        closestElement: function closestElement(node) {
            var returnNode = node;

            while (returnNode.nodeType !== 1) {
                returnNode = returnNode.parentNode;
            }

            return returnNode;
        },
        getStyles: function getStyles(node) {
            var closestElement = DOM.closestElement(node);
            var gcs = 'getComputedStyle' in window;
            return gcs ? window.getComputedStyle(closestElement) : closestElement.currentStyle;
        },
        getStyle: function getStyle(node, property) {
            var nodeStyles = DOM.getStyles(node);
            return nodeStyles[property];
        },
        insertBefore: function insertBefore(newNode, referenceNode) {
            var parentNode = referenceNode.parentNode;
            parentNode.insertBefore(newNode, referenceNode);
        },
        insertAfter: function insertAfter(newNode, referenceNode) {
            var parentNode = referenceNode.parentNode;

            if (parentNode.lastChild === referenceNode) {
                parentNode.appendChild(newNode);
            } else {
                parentNode.insertBefore(newNode, referenceNode.nextSibling);
            }
        },
        isLastChild: function isLastChild(node) {
            return node === node.parentNode.lastChild;
        },
        isFirstChild: function isFirstChild(node) {
            return node === node.parentNode.firstChild;
        },
        wrapRange: function wrapRange(nodeName, nodeOpts) {
            var sel = window.getSelection();
            var range = sel.getRangeAt(0);
            var wrapper = document.createElement(nodeName);

            for (var optKey in nodeOpts) {
                if (nodeOpts.hasOwnProperty(optKey)) {
                    wrapper[optKey] = nodeOpts[optKey];
                }
            }

            range.surroundContents(wrapper);

            return wrapper;
        },
        unwrap: function unwrap(node) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var unwrappedNodes = [];

            if (node.childNodes) {
                while (node.firstChild) {
                    unwrappedNodes.push(node.firstChild);
                    DOM.insertBefore(node.firstChild, node);
                }
            }

            if (!opts.keepNode) {
                DOM.removeNode(node);
            }
            return unwrappedNodes;
        },
        unwrapFrom: function unwrapFrom(node, wrappers) {
            var rootEl = DOM.getRootEl();
            var currentNode = node;
            var unwrappedNodes = [currentNode];

            while (currentNode !== rootEl) {
                var parentNode = currentNode.parentNode || currentNode.parentElement;

                if (wrappers.indexOf(currentNode.nodeName) > -1) {
                    unwrappedNodes = DOM.unwrap(currentNode);
                }

                currentNode = parentNode;
            }

            return unwrappedNodes;
        },
        unwrapToRoot: function unwrapToRoot(node) {
            var rootEl = DOM.getRootEl();
            var currentNode = node.parentNode;

            while (currentNode !== rootEl) {
                var parentNode = currentNode.parentNode;
                DOM.unwrap(currentNode);
                currentNode = parentNode;
            }
        },
        removeNode: function removeNode(node) {
            var parentNode = node.parentElement || node.parentNode;
            if (parentNode) {
                parentNode.removeChild(node);
            }
        },
        replaceNode: function replaceNode(node, newNode) {
            var parentNode = node.parentNode || node.parentElement;
            if (parentNode) {
                parentNode.replaceChild(newNode, node);
            }
        },
        getContainerZIndex: function getContainerZIndex(node) {
            var container = node;
            var topMostContainerZIndex = 0;

            while (container && container !== document.body) {
                var containerZIndex = window.getComputedStyle(container).zIndex;
                if (/^[0-9]+$/.test(containerZIndex)) {
                    topMostContainerZIndex = parseInt(containerZIndex);
                }
                container = container.parentNode;
            }

            return topMostContainerZIndex;
        },


        // // From http://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element
        // selectNodeContents(node) {
        //     node = node || DOM.getAnchorNode();
        //     if (!node) {
        //         return;
        //     }
        //
        //     const nodes = node instanceof Array ? node : [node];
        //     const startNode = nodes[0];
        //     const endNode = nodes[nodes.length - 1];
        //
        //     const range = document.createRange();
        //     range.setStart(startNode, 0);
        //     range.setEnd(endNode, endNode.length);
        //
        //     const sel = window.getSelection();
        //     if (sel.rangeCount > 0) {
        //         sel.removeAllRanges();
        //     }
        //     sel.addRange(range);
        // },

        getRootEl: function getRootEl() {
            var selection = document.getSelection();
            var anchorNode = selection.anchorNode;

            var rootEl = anchorNode;
            while (rootEl && !(rootEl.nodeType === Node.ELEMENT_NODE && rootEl.hasAttribute('contenteditable'))) {
                rootEl = rootEl.parentNode;
            }

            return rootEl;
        },
        removeInvalidTagsUpward: function removeInvalidTagsUpward(node, acceptedTags) {
            var rootEl = DOM.getRootEl();
            var currentNode = node;
            var invalidTags = [];
            var unwrappedNodes = [node];

            while (currentNode !== rootEl) {
                if (currentNode.nodeType === 1 && acceptedTags.indexOf(currentNode.nodeName) < 0) {
                    invalidTags.push(currentNode);
                }
                currentNode = currentNode.parentNode || currentNode.parentElement;
            }

            for (var i = 0; i < invalidTags.length; i++) {
                var invalidTag = invalidTags[i];
                unwrappedNodes = DOM.unwrap(invalidTag);
            }

            return unwrappedNodes;
        },


        // From: http://stackoverflow.com/questions/37025488/remove-whitespace-from-window-selection-in-js
        trimSelection: function trimSelection(opts) {
            opts = opts || { fromEnd: true };

            var sel = window.getSelection();
            var range = sel.getRangeAt(0);
            var selStr = sel.toString();

            var regEx = void 0,
                container = void 0,
                method = void 0,
                regExResult = void 0,
                offset = range.startOffset,
                rangeClone = void 0;

            if (opts.bothEnds) {
                opts.fromEnd = true;
            }

            if (opts.fromEnd) {
                regEx = /\s+$/;
                container = range.endContainer;
                method = range.setEnd;
            } else if (opts.fromStart) {
                regEx = /[^\s]/;
                container = range.startContainer;
                method = range.setStart;
            }

            regExResult = regEx.exec(selStr);
            if (regExResult && regExResult.index > 0) {
                if (opts.fromEnd && offset + regExResult.index > container.length) {
                    regExResult = regEx.exec(container.textContent);
                    if (regExResult) {
                        method.call(range, container, regExResult.index);
                    }
                } else {
                    method.call(range, container, offset + regExResult.index);
                }

                rangeClone = range.cloneRange();
                sel.removeAllRanges();
                sel.addRange(rangeClone);
            }

            if (opts.bothEnds) {
                if (opts.fromEnd) {
                    DOM.trimSelection({ fromStart: true });
                } else {
                    DOM.trimSelection({ fromEnd: true });
                }
            }
        },
        createPseudoSelect: function createPseudoSelect() {
            var rootEl = DOM.getRootEl();
            var wrapper = DOM.wrapRange('SPAN', {
                className: 'pseudo-selection'
            });
            var selectionStyles = void 0;

            if (browser.isFirefox()) {
                selectionStyles = window.getComputedStyle(rootEl, '::-moz-selection');
            } else {
                selectionStyles = window.getComputedStyle(rootEl, '::selection');
            }

            wrapper.style['background-color'] = selectionStyles['background-color'];
            if (wrapper.style['background-color'] === 'transparent') {
                wrapper.style['background-color'] = '#EEEEEE';
            }
            wrapper.style.color = selectionStyles.color;

            return wrapper;
        },


        // From: https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY
        getScrollOffset: function getScrollOffset() {
            var supportPageOffset = window.pageXOffset !== undefined;
            var isCSS1Compat = (document.compatMode || '') === 'CSS1Compat';

            var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
            var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

            return { x: x, y: y };
        },
        childIndex: function childIndex(node) {
            var child = node;
            var childIndex = 0;

            while ((child = child.previousSibling) !== null) {
                childIndex++;
            }

            return childIndex;
        },


        //Pseudo-private methods
        _getGetMethodName: function _getGetMethodName(selector) {
            var methodName = null;

            Object.keys(DOM.regex).forEach(function (regexKey) {
                var regex = DOM.regex[regexKey];
                if (regex.test(selector)) {
                    methodName = regexKey;
                }
            });

            return methodName;
        },
        _cleanSelector: function _cleanSelector(selector) {
            return selector.replace(/^[\.#]/, '');
        },
        _createEl: function _createEl(tag) {
            return document.createElement(tag);
        }
    };

    // jshint strict: false

    /**
     * Module -
     * A factory for building module classes.
     * Modules are built up from a module dictionary/object.
     *
     * @module core/Module
     * @access protected
     *
     * @example
     * import Module from '../core/Module'
     * const MyModule = Module({
     *   name: 'MyModule', // Required
     *
     *   // An object that is mixed into the module context that is bound to the methods
     *   props: {
     *     foo: "bar" // -> this.foo inside methods
     *   },
     *
     *   requiredProps: ['foo'], // An array listing the keys of props that are required
     *
     *   // An object map used to declare handler strings ~> method names: @see core/Mediator
     *   handlers: {
     *     requests: {},
     *     commands: {},
     *     events: {},
     *     domEvents: {}
     *   },
     *
     *   // An object map used to get dom elements and cache them to keys on the contect
     *   dom: {
     *     'myModuleElem': '.my-module-elem' // Accessable via this.dome.myModule
     *   },
     *
     *   // An object of methods to be bound to the module's context
     *   methods: {
     *     setup () {}, // The module setup hook. Called before the module initialized
     *     init () {} // The init hook. Called once the modules has been initialized,
     *     ... // The rest is up to the developer
     *  }
     * })
     */

    var Module = function Module(moduleObj) {
        var moduleName = moduleObj.name,
            moduleProps = moduleObj.props,
            moduleHandlers = moduleObj.handlers,
            moduleDom = moduleObj.dom,
            moduleMethods = moduleObj.methods,
            moduleRequiredProps = moduleObj.requiredProps;


        if (!moduleName) {
            throw new Error('No name given for module', moduleObj);
        }

        var moduleUtils = {
            createContext: function createContext() {
                for (var _len = arguments.length, contexts = Array(_len), _key = 0; _key < _len; _key++) {
                    contexts[_key] = arguments[_key];
                }

                return new (Function.prototype.bind.apply(Context, [null].concat(contexts)))();
            },
            bindMethods: function bindMethods(methods, context) {
                methods = methods || {};
                return func.bindObj(methods, context);
            },
            wrapRenderMethod: function wrapRenderMethod(renderMethod, opts) {
                var wrappedRenderMethod = function wrappedRenderMethod() {
                    var context = opts.context;

                    var mergedDom = void 0;

                    mergedDom = moduleUtils.mergeDom(moduleDom, opts.dom);
                    mergedDom.el = renderMethod.apply(undefined, arguments);

                    moduleUtils.getDom(mergedDom);
                    context.extendWith({ dom: mergedDom });

                    if (moduleHandlers.domEvents) {
                        moduleUtils.registerDomHandlers(moduleHandlers.domEvents, context);
                    }
                };
                return wrappedRenderMethod;
            },
            registerHandlers: function registerHandlers(mediator, handlers, context) {
                Object.keys(handlers).forEach(function (handlerKey) {
                    var handlerMap = handlers[handlerKey];
                    var handlerMethods = moduleUtils.getHandlerMethods(handlerMap, context);
                    switch (handlerKey) {
                        case 'requests':
                            mediator.registerRequestHandlers(handlerMethods);
                            break;
                        case 'commands':
                            mediator.registerCommandHandlers(handlerMethods);
                            break;
                        case 'events':
                            mediator.registerEventHandlers(handlerMethods);
                            break;
                    }
                });
            },
            registerDomHandlers: function registerDomHandlers(domHandlersMap, context) {
                var handlerMethods = moduleUtils.getHandlerMethods(domHandlersMap, context);
                moduleUtils.bindDomEvents(handlerMethods, context);
            },
            getHandlerMethods: function getHandlerMethods(handlerMap, context) {
                var routedHandlers = {};

                Object.keys(handlerMap).forEach(function (commandStr) {
                    var methodKey = handlerMap[commandStr];
                    var handlerMethod = context[methodKey];
                    routedHandlers[commandStr] = handlerMethod;
                });

                return routedHandlers;
            },
            mergeDom: function mergeDom(defaultDom) {
                var dom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                var mergedDom = {};
                Object.keys(defaultDom).forEach(function (domKey) {
                    mergedDom[domKey] = defaultDom[domKey];
                });

                Object.keys(dom).forEach(function (domKey) {
                    mergedDom[domKey] = dom[domKey];
                    mergedDom[domKey].selector = dom[domKey];
                });

                return mergedDom;
            },
            getDom: function getDom(dom) {
                var rootEl = dom.el || document.body;
                Object.keys(dom).forEach(function (domKey) {
                    var selector = void 0,
                        domEl = void 0;

                    selector = dom[domKey];
                    if (selector === null) {
                        return;
                    } else if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
                        selector = selector.selector || selector;
                    }

                    domEl = DOM.get(selector, rootEl);
                    domEl.selector = selector;

                    dom[domKey] = domEl;
                });
            },
            bindDomEvents: function bindDomEvents(handlers, context) {
                var dom = context.dom;


                Object.keys(handlers).forEach(function (eventElKey) {
                    var _eventElKey$split = eventElKey.split(' @'),
                        _eventElKey$split2 = slicedToArray(_eventElKey$split, 2),
                        eventKey = _eventElKey$split2[0],
                        elemKey = _eventElKey$split2[1];

                    var elem = elemKey ? dom[elemKey][0] : dom.el[0];
                    var eventHandler = handlers[eventElKey];

                    elem.addEventListener(eventKey, eventHandler);
                });
            },
            mergeProps: function mergeProps(defaultProps) {
                var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                var mergedProps = {};

                Object.keys(defaultProps).forEach(function (propKey) {
                    var propValue = props[propKey] || defaultProps[propKey];
                    mergedProps[propKey] = propValue;
                });

                return mergedProps;
            },
            validateProps: function validateProps(props, requiredProps) {
                Object.keys(props).forEach(function (propKey) {
                    if (requiredProps.indexOf(propKey) > -1 && !props[propKey]) {
                        throw new Error(moduleName + ' requires prop: ' + propKey);
                    }
                });
            }
        };

        var moduleProto = {
            moduleConstructor: function moduleConstructor(opts) {
                moduleProto.prepModule(opts);
                moduleProto.buildModule(opts);
                moduleProto.setupModule(opts);
                moduleProto.renderModule(opts);
                moduleProto.initModule(opts);
            },

            prepModule: function prepModule(opts) {
                var context = moduleUtils.createContext();

                if (moduleProps) {
                    var mergedProps = moduleUtils.mergeProps(moduleProps, opts.props);
                    context.extendWith({ props: mergedProps });

                    if (moduleRequiredProps) {
                        moduleUtils.validateProps(mergedProps, moduleRequiredProps);
                    }
                }

                opts.context = context;
            },
            buildModule: function buildModule(opts) {
                var context = opts.context;

                var boundMethods = moduleUtils.bindMethods(moduleMethods, context);

                if (boundMethods.render) {
                    boundMethods.render = moduleUtils.wrapRenderMethod(boundMethods.render, opts);
                }

                context.extendWith(boundMethods);
                context.extendWith({ mediator: opts.mediator });
            },
            setupModule: function setupModule(opts) {
                var context = opts.context;

                if (context.setup) {
                    context.setup();
                }

                if (moduleHandlers) {
                    moduleUtils.registerHandlers(opts.mediator, moduleHandlers, context);
                }
            },
            renderModule: function renderModule(opts) {
                var context = opts.context;

                var mergedDom = void 0;

                if (context.render) {
                    return;
                }

                if (moduleDom) {
                    mergedDom = moduleUtils.mergeDom(moduleDom, opts.dom);
                    moduleUtils.getDom(mergedDom);
                    context.extendWith({ dom: mergedDom });
                }

                if (moduleHandlers.domEvents) {
                    moduleUtils.registerDomHandlers(moduleHandlers.domEvents, context);
                }
            },
            initModule: function initModule(opts) {
                var context = opts.context;


                if (context.init) {
                    context.init();
                }
            },
            destroyModule: function destroyModule() { }
        };

        return moduleProto.moduleConstructor;
    };

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var utils = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        exports.extend = extend;
        exports.indexOf = indexOf;
        exports.escapeExpression = escapeExpression;
        exports.isEmpty = isEmpty;
        exports.createFrame = createFrame;
        exports.blockParams = blockParams;
        exports.appendContextPath = appendContextPath;
        var escape = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '`': '&#x60;',
            '=': '&#x3D;'
        };

        var badChars = /[&<>"'`=]/g,
            possible = /[&<>"'`=]/;

        function escapeChar(chr) {
            return escape[chr];
        }

        function extend(obj /* , ...source */) {
            for (var i = 1; i < arguments.length; i++) {
                for (var key in arguments[i]) {
                    if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                        obj[key] = arguments[i][key];
                    }
                }
            }

            return obj;
        }

        var toString = Object.prototype.toString;

        exports.toString = toString;
        // Sourced from lodash
        // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
        /* eslint-disable func-style */
        var isFunction = function isFunction(value) {
            return typeof value === 'function';
        };
        // fallback for older versions of Chrome and Safari
        /* istanbul ignore next */
        if (isFunction(/x/)) {
            exports.isFunction = isFunction = function (value) {
                return typeof value === 'function' && toString.call(value) === '[object Function]';
            };
        }
        exports.isFunction = isFunction;

        /* eslint-enable func-style */

        /* istanbul ignore next */
        var isArray = Array.isArray || function (value) {
            return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
        };

        exports.isArray = isArray;
        // Older IE versions do not directly support indexOf so we must implement our own, sadly.

        function indexOf(array, value) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }

        function escapeExpression(string) {
            if (typeof string !== 'string') {
                // don't escape SafeStrings, since they're already safe
                if (string && string.toHTML) {
                    return string.toHTML();
                } else if (string == null) {
                    return '';
                } else if (!string) {
                    return string + '';
                }

                // Force a string conversion as this will be done by the append regardless and
                // the regex test will do this transparently behind the scenes, causing issues if
                // an object's to string has escaped characters in it.
                string = '' + string;
            }

            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        }

        function isEmpty(value) {
            if (!value && value !== 0) {
                return true;
            } else if (isArray(value) && value.length === 0) {
                return true;
            } else {
                return false;
            }
        }

        function createFrame(object) {
            var frame = extend({}, object);
            frame._parent = object;
            return frame;
        }

        function blockParams(params, ids) {
            params.path = ids;
            return params;
        }

        function appendContextPath(contextPath, id) {
            return (contextPath ? contextPath + '.' : '') + id;
        }

    });

    var exception = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;

        var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

        function Exception(message, node) {
            var loc = node && node.loc,
                line = undefined,
                column = undefined;
            if (loc) {
                line = loc.start.line;
                column = loc.start.column;

                message += ' - ' + line + ':' + column;
            }

            var tmp = Error.prototype.constructor.call(this, message);

            // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
            for (var idx = 0; idx < errorProps.length; idx++) {
                this[errorProps[idx]] = tmp[errorProps[idx]];
            }

            /* istanbul ignore else */
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, Exception);
            }

            try {
                if (loc) {
                    this.lineNumber = line;

                    // Work around issue under safari where we can't directly set the column value
                    /* istanbul ignore next */
                    if (Object.defineProperty) {
                        Object.defineProperty(this, 'column', {
                            value: column,
                            enumerable: true
                        });
                    } else {
                        this.column = column;
                    }
                }
            } catch (nop) {
                /* Ignore if the browser is very particular */
            }
        }

        Exception.prototype = new Error();

        exports['default'] = Exception;
        module.exports = exports['default'];

    });

    var blockHelperMissing = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;



        exports['default'] = function (instance) {
            instance.registerHelper('blockHelperMissing', function (context, options) {
                var inverse = options.inverse,
                    fn = options.fn;

                if (context === true) {
                    return fn(this);
                } else if (context === false || context == null) {
                    return inverse(this);
                } else if (utils.isArray(context)) {
                    if (context.length > 0) {
                        if (options.ids) {
                            options.ids = [options.name];
                        }

                        return instance.helpers.each(context, options);
                    } else {
                        return inverse(this);
                    }
                } else {
                    if (options.data && options.ids) {
                        var data = utils.createFrame(options.data);
                        data.contextPath = utils.appendContextPath(options.data.contextPath, options.name);
                        options = { data: data };
                    }

                    return fn(context, options);
                }
            });
        };

        module.exports = exports['default'];

    });

    var each = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





        var _exception2 = _interopRequireDefault(exception);

        exports['default'] = function (instance) {
            instance.registerHelper('each', function (context, options) {
                if (!options) {
                    throw new _exception2['default']('Must pass iterator to #each');
                }

                var fn = options.fn,
                    inverse = options.inverse,
                    i = 0,
                    ret = '',
                    data = undefined,
                    contextPath = undefined;

                if (options.data && options.ids) {
                    contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                }

                if (utils.isFunction(context)) {
                    context = context.call(this);
                }

                if (options.data) {
                    data = utils.createFrame(options.data);
                }

                function execIteration(field, index, last) {
                    if (data) {
                        data.key = field;
                        data.index = index;
                        data.first = index === 0;
                        data.last = !!last;

                        if (contextPath) {
                            data.contextPath = contextPath + field;
                        }
                    }

                    ret = ret + fn(context[field], {
                        data: data,
                        blockParams: utils.blockParams([context[field], field], [contextPath + field, null])
                    });
                }

                if (context && typeof context === 'object') {
                    if (utils.isArray(context)) {
                        for (var j = context.length; i < j; i++) {
                            if (i in context) {
                                execIteration(i, i, i === context.length - 1);
                            }
                        }
                    } else {
                        var priorKey = undefined;

                        for (var key in context) {
                            if (context.hasOwnProperty(key)) {
                                // We're running the iterations one step out of sync so we can detect
                                // the last iteration without have to scan the object twice and create
                                // an itermediate keys array.
                                if (priorKey !== undefined) {
                                    execIteration(priorKey, i - 1);
                                }
                                priorKey = key;
                                i++;
                            }
                        }
                        if (priorKey !== undefined) {
                            execIteration(priorKey, i - 1, true);
                        }
                    }
                }

                if (i === 0) {
                    ret = inverse(this);
                }

                return ret;
            });
        };

        module.exports = exports['default'];

    });

    var helperMissing = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



        var _exception2 = _interopRequireDefault(exception);

        exports['default'] = function (instance) {
            instance.registerHelper('helperMissing', function () /* [args, ]options */ {
                if (arguments.length === 1) {
                    // A missing field in a {{foo}} construct.
                    return undefined;
                } else {
                    // Someone is actually trying to call something, blow up.
                    throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                }
            });
        };

        module.exports = exports['default'];

    });

    var _if = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;



        exports['default'] = function (instance) {
            instance.registerHelper('if', function (conditional, options) {
                if (utils.isFunction(conditional)) {
                    conditional = conditional.call(this);
                }

                // Default behavior is to render the positive path if the value is truthy and not empty.
                // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                if (!options.hash.includeZero && !conditional || utils.isEmpty(conditional)) {
                    return options.inverse(this);
                } else {
                    return options.fn(this);
                }
            });

            instance.registerHelper('unless', function (conditional, options) {
                return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
            });
        };

        module.exports = exports['default'];

    });

    var log = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;

        exports['default'] = function (instance) {
            instance.registerHelper('log', function () /* message, options */ {
                var args = [undefined],
                    options = arguments[arguments.length - 1];
                for (var i = 0; i < arguments.length - 1; i++) {
                    args.push(arguments[i]);
                }

                var level = 1;
                if (options.hash.level != null) {
                    level = options.hash.level;
                } else if (options.data && options.data.level != null) {
                    level = options.data.level;
                }
                args[0] = level;

                instance.log.apply(instance, args);
            });
        };

        module.exports = exports['default'];

    });

    var lookup = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;

        exports['default'] = function (instance) {
            instance.registerHelper('lookup', function (obj, field) {
                return obj && obj[field];
            });
        };

        module.exports = exports['default'];

    });

    var _with = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;



        exports['default'] = function (instance) {
            instance.registerHelper('with', function (context, options) {
                if (utils.isFunction(context)) {
                    context = context.call(this);
                }

                var fn = options.fn;

                if (!utils.isEmpty(context)) {
                    var data = options.data;
                    if (options.data && options.ids) {
                        data = utils.createFrame(options.data);
                        data.contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]);
                    }

                    return fn(context, {
                        data: data,
                        blockParams: utils.blockParams([context], [data && data.contextPath])
                    });
                } else {
                    return options.inverse(this);
                }
            });
        };

        module.exports = exports['default'];

    });

    var helpers = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        exports.registerDefaultHelpers = registerDefaultHelpers;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



        var _helpersBlockHelperMissing2 = _interopRequireDefault(blockHelperMissing);



        var _helpersEach2 = _interopRequireDefault(each);



        var _helpersHelperMissing2 = _interopRequireDefault(helperMissing);



        var _helpersIf2 = _interopRequireDefault(_if);



        var _helpersLog2 = _interopRequireDefault(log);



        var _helpersLookup2 = _interopRequireDefault(lookup);



        var _helpersWith2 = _interopRequireDefault(_with);

        function registerDefaultHelpers(instance) {
            _helpersBlockHelperMissing2['default'](instance);
            _helpersEach2['default'](instance);
            _helpersHelperMissing2['default'](instance);
            _helpersIf2['default'](instance);
            _helpersLog2['default'](instance);
            _helpersLookup2['default'](instance);
            _helpersWith2['default'](instance);
        }

    });

    var inline = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;



        exports['default'] = function (instance) {
            instance.registerDecorator('inline', function (fn, props, container, options) {
                var ret = fn;
                if (!props.partials) {
                    props.partials = {};
                    ret = function (context, options) {
                        // Create a new partials stack frame prior to exec.
                        var original = container.partials;
                        container.partials = utils.extend({}, original, props.partials);
                        var ret = fn(context, options);
                        container.partials = original;
                        return ret;
                    };
                }

                props.partials[options.args[0]] = options.fn;

                return ret;
            });
        };

        module.exports = exports['default'];

    });

    var decorators = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        exports.registerDefaultDecorators = registerDefaultDecorators;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



        var _decoratorsInline2 = _interopRequireDefault(inline);

        function registerDefaultDecorators(instance) {
            _decoratorsInline2['default'](instance);
        }

    });

    var logger_1 = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;



        var logger = {
            methodMap: ['debug', 'info', 'warn', 'error'],
            level: 'info',

            // Maps a given level value to the `methodMap` indexes above.
            lookupLevel: function lookupLevel(level) {
                if (typeof level === 'string') {
                    var levelMap = utils.indexOf(logger.methodMap, level.toLowerCase());
                    if (levelMap >= 0) {
                        level = levelMap;
                    } else {
                        level = parseInt(level, 10);
                    }
                }

                return level;
            },

            // Can be overridden in the host environment
            log: function log(level) {
                level = logger.lookupLevel(level);

                if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                    var method = logger.methodMap[level];
                    if (!console[method]) {
                        // eslint-disable-line no-console
                        method = 'log';
                    }

                    for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        message[_key - 1] = arguments[_key];
                    }

                    console[method].apply(console, message); // eslint-disable-line no-console
                }
            }
        };

        exports['default'] = logger;
        module.exports = exports['default'];

    });

    var base = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        exports.HandlebarsEnvironment = HandlebarsEnvironment;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





        var _exception2 = _interopRequireDefault(exception);







        var _logger2 = _interopRequireDefault(logger_1);

        var VERSION = '4.0.10';
        exports.VERSION = VERSION;
        var COMPILER_REVISION = 7;

        exports.COMPILER_REVISION = COMPILER_REVISION;
        var REVISION_CHANGES = {
            1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
            2: '== 1.0.0-rc.3',
            3: '== 1.0.0-rc.4',
            4: '== 1.x.x',
            5: '== 2.0.0-alpha.x',
            6: '>= 2.0.0-beta.1',
            7: '>= 4.0.0'
        };

        exports.REVISION_CHANGES = REVISION_CHANGES;
        var objectType = '[object Object]';

        function HandlebarsEnvironment(helpers$$1, partials, decorators$$1) {
            this.helpers = helpers$$1 || {};
            this.partials = partials || {};
            this.decorators = decorators$$1 || {};

            helpers.registerDefaultHelpers(this);
            decorators.registerDefaultDecorators(this);
        }

        HandlebarsEnvironment.prototype = {
            constructor: HandlebarsEnvironment,

            logger: _logger2['default'],
            log: _logger2['default'].log,

            registerHelper: function registerHelper(name, fn) {
                if (utils.toString.call(name) === objectType) {
                    if (fn) {
                        throw new _exception2['default']('Arg not supported with multiple helpers');
                    }
                    utils.extend(this.helpers, name);
                } else {
                    this.helpers[name] = fn;
                }
            },
            unregisterHelper: function unregisterHelper(name) {
                delete this.helpers[name];
            },

            registerPartial: function registerPartial(name, partial) {
                if (utils.toString.call(name) === objectType) {
                    utils.extend(this.partials, name);
                } else {
                    if (typeof partial === 'undefined') {
                        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                    }
                    this.partials[name] = partial;
                }
            },
            unregisterPartial: function unregisterPartial(name) {
                delete this.partials[name];
            },

            registerDecorator: function registerDecorator(name, fn) {
                if (utils.toString.call(name) === objectType) {
                    if (fn) {
                        throw new _exception2['default']('Arg not supported with multiple decorators');
                    }
                    utils.extend(this.decorators, name);
                } else {
                    this.decorators[name] = fn;
                }
            },
            unregisterDecorator: function unregisterDecorator(name) {
                delete this.decorators[name];
            }
        };

        var log = _logger2['default'].log;

        exports.log = log;
        exports.createFrame = utils.createFrame;
        exports.logger = _logger2['default'];

    });

    var safeString = createCommonjsModule(function (module, exports) {
        // Build out our basic SafeString type


        exports.__esModule = true;
        function SafeString(string) {
            this.string = string;
        }

        SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
            return '' + this.string;
        };

        exports['default'] = SafeString;
        module.exports = exports['default'];

    });

    var runtime$1 = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        exports.checkRevision = checkRevision;
        exports.template = template;
        exports.wrapProgram = wrapProgram;
        exports.resolvePartial = resolvePartial;
        exports.invokePartial = invokePartial;
        exports.noop = noop;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

        // istanbul ignore next

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }



        var Utils = _interopRequireWildcard(utils);



        var _exception2 = _interopRequireDefault(exception);



        function checkRevision(compilerInfo) {
            var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                currentRevision = base.COMPILER_REVISION;

            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = base.REVISION_CHANGES[currentRevision],
                        compilerVersions = base.REVISION_CHANGES[compilerRevision];
                    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                } else {
                    // Use the embedded version info since the runtime doesn't know about this revision yet
                    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                }
            }
        }

        function template(templateSpec, env) {
            /* istanbul ignore next */
            if (!env) {
                throw new _exception2['default']('No environment passed to template');
            }
            if (!templateSpec || !templateSpec.main) {
                throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
            }

            templateSpec.main.decorator = templateSpec.main_d;

            // Note: Using env.VM references rather than local var references throughout this section to allow
            // for external users to override these as psuedo-supported APIs.
            env.VM.checkRevision(templateSpec.compiler);

            function invokePartialWrapper(partial, context, options) {
                if (options.hash) {
                    context = Utils.extend({}, context, options.hash);
                    if (options.ids) {
                        options.ids[0] = true;
                    }
                }

                partial = env.VM.resolvePartial.call(this, partial, context, options);
                var result = env.VM.invokePartial.call(this, partial, context, options);

                if (result == null && env.compile) {
                    options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                    result = options.partials[options.name](context, options);
                }
                if (result != null) {
                    if (options.indent) {
                        var lines = result.split('\n');
                        for (var i = 0, l = lines.length; i < l; i++) {
                            if (!lines[i] && i + 1 === l) {
                                break;
                            }

                            lines[i] = options.indent + lines[i];
                        }
                        result = lines.join('\n');
                    }
                    return result;
                } else {
                    throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                }
            }

            // Just add water
            var container = {
                strict: function strict(obj, name) {
                    if (!(name in obj)) {
                        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                    }
                    return obj[name];
                },
                lookup: function lookup(depths, name) {
                    var len = depths.length;
                    for (var i = 0; i < len; i++) {
                        if (depths[i] && depths[i][name] != null) {
                            return depths[i][name];
                        }
                    }
                },
                lambda: function lambda(current, context) {
                    return typeof current === 'function' ? current.call(context) : current;
                },

                escapeExpression: Utils.escapeExpression,
                invokePartial: invokePartialWrapper,

                fn: function fn(i) {
                    var ret = templateSpec[i];
                    ret.decorator = templateSpec[i + '_d'];
                    return ret;
                },

                programs: [],
                program: function program(i, data, declaredBlockParams, blockParams, depths) {
                    var programWrapper = this.programs[i],
                        fn = this.fn(i);
                    if (data || depths || blockParams || declaredBlockParams) {
                        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                    } else if (!programWrapper) {
                        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                    }
                    return programWrapper;
                },

                data: function data(value, depth) {
                    while (value && depth--) {
                        value = value._parent;
                    }
                    return value;
                },
                merge: function merge(param, common) {
                    var obj = param || common;

                    if (param && common && param !== common) {
                        obj = Utils.extend({}, common, param);
                    }

                    return obj;
                },
                // An empty object to use as replacement for null-contexts
                nullContext: Object.seal({}),

                noop: env.VM.noop,
                compilerInfo: templateSpec.compiler
            };

            function ret(context) {
                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                var data = options.data;

                ret._setup(options);
                if (!options.partial && templateSpec.useData) {
                    data = initData(context, data);
                }
                var depths = undefined,
                    blockParams = templateSpec.useBlockParams ? [] : undefined;
                if (templateSpec.useDepths) {
                    if (options.depths) {
                        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
                    } else {
                        depths = [context];
                    }
                }

                function main(context /*, options*/) {
                    return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                }
                main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                return main(context, options);
            }
            ret.isTop = true;

            ret._setup = function (options) {
                if (!options.partial) {
                    container.helpers = container.merge(options.helpers, env.helpers);

                    if (templateSpec.usePartial) {
                        container.partials = container.merge(options.partials, env.partials);
                    }
                    if (templateSpec.usePartial || templateSpec.useDecorators) {
                        container.decorators = container.merge(options.decorators, env.decorators);
                    }
                } else {
                    container.helpers = options.helpers;
                    container.partials = options.partials;
                    container.decorators = options.decorators;
                }
            };

            ret._child = function (i, data, blockParams, depths) {
                if (templateSpec.useBlockParams && !blockParams) {
                    throw new _exception2['default']('must pass block params');
                }
                if (templateSpec.useDepths && !depths) {
                    throw new _exception2['default']('must pass parent depths');
                }

                return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
            };
            return ret;
        }

        function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
            function prog(context) {
                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                var currentDepths = depths;
                if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
                    currentDepths = [context].concat(depths);
                }

                return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
            }

            prog = executeDecorators(fn, prog, container, depths, data, blockParams);

            prog.program = i;
            prog.depth = depths ? depths.length : 0;
            prog.blockParams = declaredBlockParams || 0;
            return prog;
        }

        function resolvePartial(partial, context, options) {
            if (!partial) {
                if (options.name === '@partial-block') {
                    partial = options.data['partial-block'];
                } else {
                    partial = options.partials[options.name];
                }
            } else if (!partial.call && !options.name) {
                // This is a dynamic partial that returned a string
                options.name = partial;
                partial = options.partials[partial];
            }
            return partial;
        }

        function invokePartial(partial, context, options) {
            // Use the current closure context to save the partial-block if this partial
            var currentPartialBlock = options.data && options.data['partial-block'];
            options.partial = true;
            if (options.ids) {
                options.data.contextPath = options.ids[0] || options.data.contextPath;
            }

            var partialBlock = undefined;
            if (options.fn && options.fn !== noop) {
                (function () {
                    options.data = base.createFrame(options.data);
                    // Wrapper function to get access to currentPartialBlock from the closure
                    var fn = options.fn;
                    partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
                        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        // Restore the partial-block from the closure for the execution of the block
                        // i.e. the part inside the block of the partial call.
                        options.data = base.createFrame(options.data);
                        options.data['partial-block'] = currentPartialBlock;
                        return fn(context, options);
                    };
                    if (fn.partials) {
                        options.partials = Utils.extend({}, options.partials, fn.partials);
                    }
                })();
            }

            if (partial === undefined && partialBlock) {
                partial = partialBlock;
            }

            if (partial === undefined) {
                throw new _exception2['default']('The partial ' + options.name + ' could not be found');
            } else if (partial instanceof Function) {
                return partial(context, options);
            }
        }

        function noop() {
            return '';
        }

        function initData(context, data) {
            if (!data || !('root' in data)) {
                data = data ? base.createFrame(data) : {};
                data.root = context;
            }
            return data;
        }

        function executeDecorators(fn, prog, container, depths, data, blockParams) {
            if (fn.decorator) {
                var props = {};
                prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                Utils.extend(prog, props);
            }
            return prog;
        }

    });

    var noConflict = createCommonjsModule(function (module, exports) {
        /* global window */


        exports.__esModule = true;

        exports['default'] = function (Handlebars) {
            /* istanbul ignore next */
            var root = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : window,
                $Handlebars = root.Handlebars;
            /* istanbul ignore next */
            Handlebars.noConflict = function () {
                if (root.Handlebars === Handlebars) {
                    root.Handlebars = $Handlebars;
                }
                return Handlebars;
            };
        };

        module.exports = exports['default'];

    });

    var handlebars_runtime = createCommonjsModule(function (module, exports) {
        'use strict';

        exports.__esModule = true;
        // istanbul ignore next

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

        // istanbul ignore next

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }



        var base$$1 = _interopRequireWildcard(base);

        // Each of these augment the Handlebars object. No need to setup here.
        // (This is done to easily share code between commonjs and browse envs)



        var _handlebarsSafeString2 = _interopRequireDefault(safeString);



        var _handlebarsException2 = _interopRequireDefault(exception);



        var Utils = _interopRequireWildcard(utils);



        var runtime = _interopRequireWildcard(runtime$1);



        var _handlebarsNoConflict2 = _interopRequireDefault(noConflict);

        // For compatibility and usage outside of module systems, make the Handlebars object a namespace
        function create() {
            var hb = new base$$1.HandlebarsEnvironment();

            Utils.extend(hb, base$$1);
            hb.SafeString = _handlebarsSafeString2['default'];
            hb.Exception = _handlebarsException2['default'];
            hb.Utils = Utils;
            hb.escapeExpression = Utils.escapeExpression;

            hb.VM = runtime;
            hb.template = function (spec) {
                return runtime.template(spec, hb);
            };

            return hb;
        }

        var inst = create();
        inst.create = create;

        _handlebarsNoConflict2['default'](inst);

        inst['default'] = inst;

        exports['default'] = inst;
        module.exports = exports['default'];

    });

    // Create a simple path alias to allow browserify to resolve
    // the runtime on a supported path.
    var runtime = handlebars_runtime['default'];

    var Template = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            return "<i class='typester-icon'>\n    <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n         viewBox=\"0 0 20 20\" enable-background=\"new 0 0 20 20\" xml:space=\"preserve\" width=\"20px\" height=\"20px\">\n        <path id=\"XMLID_110_\" d=\"M9.2,18.4c-2.1,2.1-5.5,2.1-7.7,0c-2.1-2.1-2.1-5.6,0-7.7l2.9-2.8C4.3,9,4.5,10,4.8,11l-1.5,1.5\n            c-1.1,1.1-1.1,3,0,4.1c1.1,1.1,3,1.1,4.1,0l3.1-3.1c1.2-1.1,1.2-3,0-4.1c-0.5-0.5-0.5-1.3,0-1.8s1.3-0.5,1.8,0\n            c2.1,2.1,2.1,5.6,0,7.7L9.2,18.4z M15.6,12.1c0.1-1.1,0-2.1-0.4-3.1l1.5-1.5c1.1-1.1,1.1-3,0-4.1s-3-1.1-4.1,0L9.4,6.5\n            c-1.1,1.2-1.1,3,0,4.1c0.5,0.5,0.5,1.3,0,1.8c-0.5,0.5-1.3,0.5-1.8,0c-2.1-2.1-2.1-5.6,0-7.7l3.1-3.1c2.1-2.1,5.6-2.1,7.7,0\n            c2.1,2.1,2.1,5.5,0,7.7L15.6,12.1z\"/>\n    </svg>\n</i>\n";
        }, "useData": true
    });
    var linkIcon = function (data, options, asString) {
        var html = Template(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var Template$1 = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            return "<i class='typester-icon'>\n    <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n       viewBox=\"0 0 20 20\" enable-background=\"new 0 0 20 20\" xml:space=\"preserve\" width=\"20px\" height=\"20px\">\n       <path id=\"XMLID_126_\" d=\"M20,7.6C20,7.8,19.8,8,19.6,8H6.9C6.7,8,6.5,7.8,6.5,7.6V5.3C6.5,5.1,6.7,5,6.9,5h12.7\n        C19.8,5,20,5.1,20,5.3V7.6z M20,13.5c0-0.2-0.2-0.4-0.4-0.4H6.9c-0.2,0-0.4,0.2-0.4,0.4v2.2c0,0.2,0.2,0.4,0.4,0.4h12.7\n        c0.2,0,0.4-0.2,0.4-0.4V13.5z M1.6,8.4H3v-5H1.9C1.8,4.1,1.3,4.5,0.5,4.6v1h1V8.4z M0,16.6h4.1v-1.2h-2v0c0.5-0.4,1.1-0.7,1.6-1.2\n        c0.3-0.3,0.4-0.6,0.4-1.1c0-0.9-0.7-1.6-2-1.6c-0.9,0-1.6,0.4-1.8,0.9c-0.2,0.3-0.2,0.6-0.2,1.2h1.4c0-0.3,0.1-0.5,0.2-0.7\n        c0.1-0.2,0.3-0.2,0.5-0.2c0.4,0,0.6,0.2,0.6,0.5c0,0.3-0.2,0.5-0.4,0.7c-0.5,0.4-1.3,0.8-1.7,1.3C0.1,15.5,0,15.9,0,16.6z\"/>\n    </svg>\n</i>\n";
        }, "useData": true
    });
    var orderedlistIcon = function (data, options, asString) {
        var html = Template$1(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var Template$2 = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            return "<i class='typester-icon'>\n    <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n       viewBox=\"0 0 20 20\" enable-background=\"new 0 0 20 20\" xml:space=\"preserve\" width=\"20px\" height=\"20px\">\n       <path id=\"XMLID_3_\" d=\"M3.3,4.2c0,0.2-0.2,0.4-0.4,0.4H0.4C0.2,4.6,0,4.4,0,4.2V1.7c0-0.2,0.2-0.4,0.4-0.4h2.5\n        c0.2,0,0.4,0.2,0.4,0.4V4.2z M3.3,11.3c0,0.2-0.2,0.4-0.4,0.4H0.4c-0.2,0-0.4-0.2-0.4-0.4V8.8c0-0.2,0.2-0.4,0.4-0.4h2.5\n        c0.2,0,0.4,0.2,0.4,0.4V11.3z M3.3,18.3c0,0.2-0.2,0.4-0.4,0.4H0.4c-0.2,0-0.4-0.2-0.4-0.4v-2.5c0-0.2,0.2-0.4,0.4-0.4h2.5\n        c0.2,0,0.4,0.2,0.4,0.4V18.3z M20,4.2c0,0.2-0.2,0.4-0.4,0.4H5.4C5.2,4.6,5,4.4,5,4.2V1.7c0-0.2,0.2-0.4,0.4-0.4h14.2\n        c0.2,0,0.4,0.2,0.4,0.4V4.2z M20,11.3c0,0.2-0.2,0.4-0.4,0.4H5.4c-0.2,0-0.4-0.2-0.4-0.4V8.8c0-0.2,0.2-0.4,0.4-0.4h14.2\n        c0.2,0,0.4,0.2,0.4,0.4V11.3z M20,18.3c0,0.2-0.2,0.4-0.4,0.4H5.4c-0.2,0-0.4-0.2-0.4-0.4v-2.5c0-0.2,0.2-0.4,0.4-0.4h14.2\n        c0.2,0,0.4,0.2,0.4,0.4V18.3z\"/>\n    </svg>\n</i>\n";
        }, "useData": true
    });
    var unorderedlistIcon = function (data, options, asString) {
        var html = Template$2(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var Template$3 = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            return "<i class='typester-icon'>\n    <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"768\" height=\"768\" viewBox=\"0 0 768 768\">\n        <path d=\"M494.819 659.759l108.242-221.638h-164.939v-329.879h329.879v329.879l-108.241 221.638h-164.939zM54.121 659.759l110.819-221.638h-164.939v-329.879h329.879v329.879l-110.819 221.638h-164.939z\"></path>\n    </svg>\n</i>\n";
        }, "useData": true
    });
    var quoteIcon = function (data, options, asString) {
        var html = Template$3(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    /**
     * The toolbar config. NB could do with a revision, some of the props in here could
     * be moved to the main config.
     * @access protected
     * @module config/toolbar
     */
    var Toolbar$2 = {
        buttons: ['bold', 'italic', 'h1', 'h2', 'orderedlist', 'unorderedlist', 'quote', 'link'],
        preventNewlineDefault: ['ul', 'ol'],
        blockTags: ['P'],
        validTags: ['P'],
        listTags: [],
        getValidTags: function getValidTags() {
            var validTags = Toolbar$2.validTags;


            if (validTags.length === 1) {
                Toolbar$2.parseForTagLists();
            }

            return Toolbar$2.validTags;
        },
        getBlockTags: function getBlockTags() {
            var blockTags = Toolbar$2.blockTags;


            if (blockTags.length === 1) {
                Toolbar$2.parseForTagLists();
            }

            return Toolbar$2.blockTags;
        },
        getListTags: function getListTags() {
            var listTags = Toolbar$2.listTags;


            if (listTags.length === 0) {
                Toolbar$2.parseForTagLists();
            }

            return Toolbar$2.listTags;
        },
        parseForTagLists: function parseForTagLists() {
            var validTags = Toolbar$2.validTags,
                blockTags = Toolbar$2.blockTags,
                listTags = Toolbar$2.listTags;


            Toolbar$2.buttons.forEach(function (buttonKey) {
                var buttonConfig = Toolbar$2.buttonConfigs[buttonKey];
                var configValidTags = buttonConfig.opts.validTags;

                validTags = validTags.concat(configValidTags);

                switch (buttonConfig.formatter) {
                    case 'block':
                        blockTags = blockTags.concat(configValidTags);
                        break;
                    case 'list':
                        listTags = listTags.concat(configValidTags);
                        break;
                }
            });

            Toolbar$2.validTags = validTags;
            Toolbar$2.blockTags = blockTags;
            Toolbar$2.listTags = listTags;
        },

        buttonConfigs: {
            // Text styles
            bold: {
                formatter: 'text',
                opts: {
                    style: 'bold',
                    rootEl: 'b',
                    validTags: ['B', 'STRONG']
                },
                content: '<b>B</b>',
                disabledIn: ['H1', 'H2', 'BLOCKQUOTE'],
                activeIn: ['B']
            },

            italic: {
                formatter: 'text',
                opts: {
                    style: 'italic',
                    rootEl: 'i',
                    validTags: ['I']
                },
                content: '<i>I</i>',
                activeIn: ['I']
            },

            underline: {
                formatter: 'text:underline',
                content: '<u>U</u>'
            },

            strikethrough: {
                formatter: 'text:strikethrough',
                content: '<s>A</s>'
            },

            superscript: {
                formatter: 'text:superscript',
                content: '<sup>1</sup>'
            },

            subscript: {
                formatter: 'text:subscript',
                content: '<sub>1</sub>'
            },

            // Paragraph styles
            justifyCenter: {
                formatter: 'paragraph:justifyCenter'
            },

            justifyFull: {
                formatter: 'paragraph:justifyFull'
            },

            justifyLeft: {
                formatter: 'paragraph:justifyLeft'
            },

            justifyRight: {
                formatter: 'paragraph:justifyRight'
            },

            indent: {
                formatter: 'paragraph:indent'
            },

            outdent: {
                formatter: 'paragraph:outdent'
            },

            // Lists
            orderedlist: {
                formatter: 'list',
                content: orderedlistIcon({}, {}, true),
                opts: {
                    style: 'ordered',
                    validTags: ['OL', 'LI']
                },
                activeIn: ['OL']
            },

            unorderedlist: {
                formatter: 'list',
                content: unorderedlistIcon({}, {}, true),
                opts: {
                    style: 'unordered',
                    validTags: ['UL', 'LI']
                },
                activeIn: ['UL']
            },

            // Block level elements
            quote: {
                formatter: 'block',
                content: quoteIcon({}, {}, true),
                opts: {
                    style: 'BLOCKQUOTE',
                    validTags: ['BLOCKQUOTE']
                },
                activeIn: ['BLOCKQUOTE'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            pre: {
                formatter: 'block',
                opts: {
                    style: 'PRE'
                },
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                content: 'PRE'
            },

            h1: {
                formatter: 'block',
                opts: {
                    style: 'H1',
                    validTags: ['H1']
                },
                content: 'H1',
                activeIn: ['H1'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            h2: {
                formatter: 'block',
                opts: {
                    style: 'H2',
                    validTags: ['H2']
                },
                content: 'H2',
                activeIn: ['H2'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            h3: {
                formatter: 'block',
                opts: {
                    style: 'H3',
                    validTags: ['H3']
                },
                content: 'H3',
                activeIn: ['H3'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            h4: {
                formatter: 'block',
                opts: {
                    style: 'H4',
                    validTags: ['H4']
                },
                content: 'H4',
                activeIn: ['H4'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            h5: {
                formatter: 'block',
                opts: {
                    style: 'H5',
                    validTags: ['H5']
                },
                content: 'H5',
                activeIn: ['H5'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            h6: {
                formatter: 'block',
                opts: {
                    style: 'H6',
                    validTags: ['H6']
                },
                content: 'H6',
                activeIn: ['H6'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);
                    disabled = disabled || mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                },

                toggles: true
            },

            // Link
            link: {
                formatter: 'link',
                opts: {
                    validTags: ['A']
                },
                content: linkIcon({}, {}, true),
                activeIn: ['A'],
                disabledIn: function disabledIn(mediator) {
                    var disabled = mediator.get('selection:spans:multiple:blocks');
                    return disabled;
                }
            }
        }
    };

    var Template$4 = runtime.template({
        "1": function _(container, depth0, helpers, partials, data, blockParams) {
            var stack1, helper;

            return "            <li>\n                <a class='typester-menu-item' data-config-key='" + container.escapeExpression((helper = (helper = helpers.configKey || (depth0 != null ? depth0.configKey : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "configKey", "hash": {}, "data": data }) : helper)) + "'>\n                    " + ((stack1 = container.lambda((stack1 = blockParams[0][0]) != null ? stack1.content : stack1, depth0)) != null ? stack1 : "") + "\n                </a>\n            </li>\n";
        }, "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data, blockParams) {
            var stack1;

            return "<div class='typester-toolbar'>\n    <ul class='buttons-wrapper s--active'>\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.buttons : depth0, { "name": "each", "hash": {}, "fn": container.program(1, data, 1, blockParams), "inverse": container.noop, "data": data, "blockParams": blockParams })) != null ? stack1 : "") + "    </ul>\n    <div class='inputs-wrapper'>\n        <input class='link-input' type='text' name='link-uri'/>\n    </div>\n</div>\n";
        }, "useData": true, "useBlockParams": true
    });
    var toolbarTemplate = function (data, options, asString) {
        var html = Template$4(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var toolbarStyles = ".typester-toolbar .buttons-wrapper,\n.typester-toolbar .inputs-wrapper {\n  transition: opacity 200ms, -webkit-transform 200ms;\n  transition: opacity 200ms, transform 200ms;\n  transition: opacity 200ms, transform 200ms, -webkit-transform 200ms;\n  -webkit-transform: translateY(-40px);\n          transform: translateY(-40px);\n  opacity: 0; }\n  .typester-toolbar .buttons-wrapper.s--active,\n  .typester-toolbar .inputs-wrapper.s--active {\n    -webkit-transform: translateY(0px);\n            transform: translateY(0px);\n    opacity: 1; }\n\n.typester-toolbar .inputs-wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%; }\n\n.typester-toolbar ul {\n  overflow: hidden;\n  list-style: none; }\n\n.typester-toolbar li {\n  float: left;\n  list-style: none; }\n\n.typester-toolbar .typester-menu-item {\n  color: #FFF;\n  font-family: sans-serif;\n  font-size: 16px;\n  width: 40px;\n  height: 40px;\n  display: block;\n  line-height: 40px;\n  font-weight: bold;\n  text-align: center;\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n  .typester-toolbar .typester-menu-item svg {\n    display: block;\n    fill: #FFF;\n    height: 16px;\n    width: 16px;\n    padding: 12px; }\n  .typester-toolbar .typester-menu-item b {\n    font-weight: bold; }\n  .typester-toolbar .typester-menu-item i {\n    font-style: italic; }\n  .typester-toolbar .typester-menu-item:hover {\n    background: #00aeef; }\n  .typester-toolbar .typester-menu-item.s--active {\n    background: #0089bc; }\n  .typester-toolbar .typester-menu-item[disabled] {\n    width: 0;\n    overflow: hidden; }\n";

    // jshint strict: false

    /**
     * Toolbar -
     * Handle the display of the toolbar and its controls and wire interactions to the
     * correct formatter using the toolbar config.
     * @access protected
     * @module modules/Toolbar
     *
     * @example
     * // Available commands
     * commands: {
     *   'toolbar:hide' : 'hideToolbar',
     *   'toolbar:set:buttons' : 'setButtons'
     * }
     */
    var Toolbar = Module({
        name: 'Toolbar',
        dom: {
            'toolbarMenuItems': '.typester-menu-item'
        },
        props: {
            el: null,
            styles: null,
            mouseover: 0,
            classNames: {
                MENU_ITEM: 'typester-menu-item',
                ACTIVE: 's--active'
            }
        },
        handlers: {
            commands: {
                'toolbar:hide': 'hideToolbar',
                'toolbar:set:buttons': 'setButtons'
            },
            events: {
                // 'contenteditable:focus': 'showToolbar',
                'app:destroy': 'destroy',
                'selection:update': 'handleSelectionChange',
                // 'selection:start' : 'handleSelectStart',
                'selection:change': 'handleSelectionChange',
                'mouse:down': 'handleMouseDown',
                'mouse:up': 'handleMouseUp',
                'import:from:canvas:complete': 'handleCanvasImport'
            },
            domEvents: {
                'click': 'handleToolbarClick',
                'mouseover': 'handleMouseOver',
                'mouseout': 'handleMouseOut'
            }
        },
        methods: {
            setup: function setup() {
                this.appendStyles();
                this.render();
            },
            init: function init() {
                this.updateToolbarState();
            },
            appendStyles: function appendStyles() {
                var props = this.props;

                props.styles = DOM.addStyles(toolbarStyles);
            },
            render: function render() {
                var mediator = this.mediator,
                    props = this.props;

                var buttonConfigs = this.getButtonConfigs();
                var wrapperEl = document.createElement('div');

                var toolbarHTML = toolbarTemplate(buttonConfigs);

                if (typeof toolbarHTML === 'string') {
                    wrapperEl.innerHTML = toolbarHTML;
                } else {
                    wrapperEl.appendChild(toolbarHTML[0]);
                }

                var toolbarEl = wrapperEl.childNodes[0];
                props.flyout = props.flyout || mediator.get('flyout:new');
                props.flyout.clearContent();
                props.flyout.show();
                props.flyout.appendContent(wrapperEl.childNodes[0]);

                return toolbarEl;
            },
            getButtonConfigs: function getButtonConfigs() {
                var mediator = this.mediator;

                var contentEditableButtons = mediator.get('contenteditable:toolbar:buttons') || [];
                var configButtons = contentEditableButtons.length ? contentEditableButtons : Toolbar$2.buttons;

                var buttons = [];

                configButtons.forEach(function (configKey) {
                    // NB This needs to be looked at
                    if (configKey === 'anchor') {
                        configKey = 'link';
                    }
                    var buttonConfig = Object.assign({ configKey: configKey }, Toolbar$2.buttonConfigs[configKey]);
                    buttons.push(buttonConfig);
                });

                return { buttons: buttons };
            },
            handleToolbarClick: function handleToolbarClick(evnt) {
                var mediator = this.mediator,
                    props = this.props;

                mediator.exec('contenteditable:refocus');
                mediator.exec('selection:reselect');

                var menuItemEl = DOM.getClosest(evnt.target, '.' + props.classNames.MENU_ITEM);
                var dataset = menuItemEl.dataset;
                var configKey = dataset.configKey;

                var buttonConfig = Toolbar$2.buttonConfigs[configKey];
                var formatter = buttonConfig.formatter,
                    opts = buttonConfig.opts;

                var toolbarMenuItemState = this.getMenuItemState(menuItemEl);

                opts.toggle = buttonConfig.toggles && toolbarMenuItemState.isActive;
                mediator.exec('format:' + formatter, opts);
            },


            // handleSelectStart () {
            //     this.hideToolbar();
            // },

            handleSelectionChange: function handleSelectionChange() {
                var _this = this;

                var props = this.props;

                if (props.selectionChangeTimeout) {
                    clearTimeout(props.selectionChangeTimeout);
                }
                props.selectionChangeTimeout = setTimeout(function () {
                    _this.updateToolbarState();
                }, 10);
            },
            handleMouseDown: function handleMouseDown() {
                this.updateToolbarState();
            },
            handleMouseUp: function handleMouseUp() {
                this.updateToolbarState();
            },
            handleMouseOver: function handleMouseOver() {
                var props = this.props;

                props.mouseover += 1;
                props.mouseover = Math.min(1, props.mouseover);
            },
            handleMouseOut: function handleMouseOut() {
                var props = this.props;

                props.mouseover -= 1;
                props.mouseover = Math.max(0, props.mouseover);
            },
            handleCanvasImport: function handleCanvasImport() {
                this.updateToolbarState();
            },
            hideToolbar: function hideToolbar() {
                var props = this.props;

                props.flyout.hide();
            },
            showToolbar: function showToolbar() {
                this.render();
            },
            positionToolbar: function positionToolbar() {
                var mediator = this.mediator,
                    props = this.props;

                var selectionBounds = mediator.get('selection:bounds');

                if (selectionBounds.initialWidth > 0) {
                    var scrollOffset = DOM.getScrollOffset();
                    var docRelTop = selectionBounds.top + scrollOffset.y;
                    var docRelLeft = selectionBounds.initialLeft + scrollOffset.x;
                    var docRelCenter = selectionBounds.initialWidth / 2 + docRelLeft;

                    props.flyout.position({
                        left: docRelCenter + 'px',
                        top: docRelTop + 'px'
                    });
                }
            },
            updateToolbarState: function updateToolbarState() {
                var mediator = this.mediator,
                    props = this.props;

                var currentSelection = mediator.get('selection:current');
                var linkFormatterActive = mediator.get('format:link:active');
                var mouseIsDown = mediator.get('mouse:is:down');

                if (!currentSelection || currentSelection.isCollapsed || !currentSelection.toString().trim().length || linkFormatterActive || !document.activeElement.hasAttribute('contenteditable') || mouseIsDown) {
                    if (props.mouseover) {
                        return;
                    }
                    this.hideToolbar();
                } else {
                    this.positionToolbar();
                    this.showToolbar();
                    this.updateMenuItems();
                }
            },
            updateMenuItems: function updateMenuItems() {
                var dom = this.dom,
                    mediator = this.mediator;

                mediator.exec('selection:ensure:text:only');
                for (var i = 0; i < dom.toolbarMenuItems.length; i++) {
                    var toolbarMenuItem = dom.toolbarMenuItems[i];
                    this.updateMenuItemState(toolbarMenuItem);
                }
            },
            updateMenuItemState: function updateMenuItemState(toolbarMenuItem) {
                var props = this.props;

                var toolbarMenuItemState = this.getMenuItemState(toolbarMenuItem);

                if (toolbarMenuItemState.isDisabled) {
                    toolbarMenuItem.setAttribute('disabled', '');
                } else {
                    toolbarMenuItem.removeAttribute('disabled');
                }

                DOM.toggleClass(toolbarMenuItem, props.classNames.ACTIVE, toolbarMenuItemState.isActive);
            },
            getMenuItemState: function getMenuItemState(toolbarMenuItem) {
                var mediator = this.mediator;
                var configKey = toolbarMenuItem.dataset.configKey;


                var config = Toolbar$2.buttonConfigs[configKey];

                var activeIn = config.activeIn || [];
                var disabledIn = config.disabledIn || [];
                var isActive = mediator.get('selection:in:or:contains', activeIn);

                var isDisabled = false;
                if (typeof disabledIn === 'function') {
                    isDisabled = disabledIn.call(config, mediator);
                } else {
                    isDisabled = mediator.get('selection:in:or:contains', disabledIn);
                }

                return {
                    isActive: isActive,
                    isDisabled: isDisabled
                };
            },
            destroy: function destroy() {
                var props = this.props;

                props.flyout.remove();
            }
        }
    });

    var Template$5 = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            var stack1, helper;

            return "<div class='typester-flyout place-above'>\n    <div class='typester-flyout-content'>\n        " + ((stack1 = (helper = (helper = helpers.content || (depth0 != null ? depth0.content : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "content", "hash": {}, "data": data }) : helper)) != null ? stack1 : "") + "\n    </div>\n</div>\n";
        }, "useData": true
    });
    var flyoutTemplate = function (data, options, asString) {
        var html = Template$5(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var flyoutStyles = ".typester-flyout {\n  transition: top 200ms, left 200ms;\n  position: absolute;\n  z-index: 1600;\n  top: 50%;\n  left: 50%; }\n  .typester-flyout .typester-flyout-content {\n    background: #201f20;\n    height: 40px;\n    width: auto; }\n    .typester-flyout .typester-flyout-content:after {\n      content: '';\n      position: absolute;\n      left: 50%;\n      height: 0;\n      width: 0;\n      border-left: 10px solid transparent;\n      border-right: 10px solid transparent; }\n  .typester-flyout.place-above {\n    -webkit-transform: translate3d(-50%, -100%, 0);\n            transform: translate3d(-50%, -100%, 0);\n    padding-bottom: 12px; }\n    .typester-flyout.place-above .typester-flyout-content:after {\n      top: 100%;\n      border-top: 10px solid #201f20;\n      -webkit-transform: translate3d(-50%, -13px, 0);\n              transform: translate3d(-50%, -13px, 0); }\n  .typester-flyout.place-below {\n    -webkit-transform: translate3d(-50%, 0, 0);\n            transform: translate3d(-50%, 0, 0);\n    padding-top: 12px; }\n    .typester-flyout.place-below .typester-flyout-content:after {\n      bottom: 100%;\n      border-bottom: 10px solid #201f20;\n      -webkit-transform: translate3d(-50%, 13px, 0);\n              transform: translate3d(-50%, 13px, 0); }\n  .typester-flyout a {\n    color: #FFF; }\n";

    // jshint strict: false

    /**
     * Flyout -
     * A utility module to control the flyout DOM element that is used to wrap tooltips
     * and floating toolbars.
     * @access protected
     * @module modules/Flyout
     *
     * @example
     * const flyout = mediator.get('flyout:new');
     * flyout.clearContent();
     * flyout.show();
     * flyout.appendContent(domElement);
     * flyout.position({ left: '100px', top: '100px' });
     * flyout.setPlacement('above'); // or 'below'
     *
     * // ... later ...
     * flyout.hide();
     * flyout.remove();
     */
    var Flyout = Module({
        name: 'Flyout',
        dom: {},
        props: {
            minZIndex: 90,
            styles: null,
            flyouts: []
        },
        handlers: {
            requests: {
                'flyout:new': 'newFlyout'
            },
            commands: {},
            events: {
                'app:destroy': 'destroy'
            }
        },
        methods: {
            setup: function setup() {
                this.appendStyles();
            },
            init: function init() { },
            appendStyles: function appendStyles() {
                var props = this.props;

                props.styles = DOM.addStyles(flyoutStyles);
            },
            newFlyout: function newFlyout() {
                var props = this.props;

                var flyout = this.buildFlyout();
                props.flyouts.push(flyout);
                return flyout;
            },
            buildFlyout: function buildFlyout() {
                var _this = this;

                var flyout = {
                    el: this.buildTemplate(),
                    appended: null
                };

                flyout.contentEl = flyout.el.querySelector('.typester-flyout-content');

                flyout.clearContent = function () {
                    flyout.contentEl.innerHTML = '';
                };

                flyout.appendContent = function (content) {
                    return DOM.appendTo(flyout.contentEl, content);
                };
                flyout.show = function () {
                    _this.showFlyout(flyout);
                };
                flyout.remove = function () {
                    _this.removeFlyout(flyout);
                };
                flyout.hide = function () {
                    _this.hideFlyout(flyout);
                };
                flyout.position = function (coordinates) {
                    _this.positionFlyout(flyout, coordinates);
                };
                flyout.setPlacement = function (placement) {
                    _this.setPlacement(flyout, placement);
                };

                return flyout;
            },
            buildTemplate: function buildTemplate() {
                var wrapperEl = document.createElement('div');
                var flyoutHTML = void 0,
                    flyoutEl = void 0;

                flyoutHTML = flyoutTemplate();
                if (typeof flyoutHTML === 'string') {
                    wrapperEl.innerHTML = flyoutHTML;
                } else {
                    wrapperEl.appendChild(flyoutHTML[0]);
                }
                flyoutEl = wrapperEl.childNodes[0];

                return flyoutEl;
            },
            appendFlyout: function appendFlyout(flyout) {
                DOM.appendTo(document.body, flyout.el);
            },
            removeFlyout: function removeFlyout(flyout) {
                if (flyout.appended) {
                    DOM.removeNode(flyout.el);
                    flyout.appended = false;
                }
            },
            positionFlyout: function positionFlyout(flyout, coordinates) {
                var mediator = this.mediator,
                    props = this.props;

                var contentEditableEl = mediator.get('contenteditable:element');
                var containerZIndex = Math.max(props.minZIndex, DOM.getContainerZIndex(contentEditableEl));

                Object.keys(coordinates).forEach(function (coordinateKey) {
                    flyout.el.style[coordinateKey] = coordinates[coordinateKey];
                });

                flyout.el.style.zIndex = containerZIndex + 1;
            },
            setPlacement: function setPlacement(flyout) {
                var placement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'above';

                flyout.el.classList.remove('place-below');
                flyout.el.classList.remove('place-above');
                flyout.el.classList.add('place-' + placement);
            },
            showFlyout: function showFlyout(flyout) {
                if (!flyout.appended) {
                    this.appendFlyout(flyout);
                    flyout.appended = true;
                } else {
                    flyout.el.style.display = 'block';
                }
            },
            hideFlyout: function hideFlyout(flyout) {
                flyout.el.style.display = 'none';
            },
            destroy: function destroy() {
                var props = this.props;

                props.flyouts.forEach(function (flyout) {
                    flyout.remove();
                });
            }
        }
    });

    // jshint strict: false

    /**
     * Mouse -
     * Responsible for tracking the up/down state of the mouse button
     * @access protected
     * @module modules/Mouse
     *
     * @example
     * mediator.get('mouse:is:down'); // Returns true if mouse button is down.
     */

    var Mouse = Module({
        name: 'Mouse',
        props: {
            mousedown: 0
        },
        dom: {},
        handlers: {
            requests: {
                'mouse:is:down': 'mouseIsDown'
            },
            commands: {},
            events: {
                'contenteditable:blur': 'handleContentEditableBlur'
            }
        },
        methods: {
            init: function init() {
                var _this = this;

                var mediator = this.mediator;

                document.body.onmousedown = function () {
                    _this.setMousedown();
                    mediator.emit('mouse:down');
                };
                document.body.onmouseup = function () {
                    _this.unsetMousedown();
                    mediator.emit('mouse:up');
                };
                // document.body.onmouseout = () => {
                //     props.mousedown = 0;
                // };
            },
            setMousedown: function setMousedown() {
                var props = this.props;

                props.mousedown += 1;
                props.mousedown = Math.min(1, props.mousedown);
            },
            unsetMousedown: function unsetMousedown() {
                var props = this.props;

                props.mousedown -= 1;
                props.mousedown = Math.max(0, props.mousedown);
            },
            mouseIsDown: function mouseIsDown() {
                var props = this.props;

                return !!props.mousedown;
            },
            handleContentEditableBlur: function handleContentEditableBlur() {
                var props = this.props;

                props.mousedown = 0;
            }
        }
    });

    // jshint strict: false

    /**
     * UIContainer - Initializes and bootstraps the UI modules. It requires only a
     * mediator instance to delegate events to.
     *
     * @access protected
     * @module containers/UIContainer
     *
     * @requires core/Container
     * @requires modules/Toolbar
     * @requires modules/Flyout
     * @requires modulesMouse
     *
     * @example
     * new UIContainer({ mediator: mediatorInstance });
     */
    /**
     * @constructor UIContainer
     * @param {object} opts={} - container options
     * @param {mediator} opts.mediator - The mediator to delegate events to
     * @return {container} UIContainer instance
     */
    var UIContainer = Container({
        name: 'UIContainer',

        /**
         * Child Modules: [{@link modules/Flyout}, {@link modules/Toolbar}]
         * Note: The Toobar is instantiated with the document body set as it's dom.el.
         * @enum {Array<{class:Module}>} modules    
         */
        modules: [{
            class: Flyout
        }, {
            class: Toolbar,
            opts: {
                dom: {
                    el: document.body
                }
            }
        }, {
            class: Mouse
        }]
    });

    /**
     * The main config.
     * @access protected
     * @module config/config
     *
     * @example
     * config.defaultBlock = "P" // the defaultBlock formatting to use when creating a new line etc.
     * config.blockElementName = [ ... ] // a list of all the expected block level element names.
     */

    var config = {
        defaultBlock: 'P',
        blockElementNames: ['blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'ul', 'li', 'p', 'pre', 'address', 'article', 'aside', 'canvas', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'header', 'hgroup', 'hr', 'main', 'nav', 'noscript', 'output', 'section', 'table', 'tfoot', 'video']
    };

    // jshint strict: false

    /**
     * commands -
     * utility to abstract the interface for document.execCommand
     * @access protected
     */
    var commands = {
        exec: function exec(command) {
            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var contextDocument = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;

            if (command === 'formatBlock') {
                value = commands.prepBlockValue(value);
            }
            contextDocument.execCommand(command, false, value);
        },
        formatBlock: function formatBlock(style) {
            var contextDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

            commands.exec('formatBlock', style, contextDocument);
        },
        defaultBlockFormat: function defaultBlockFormat() {
            var contextDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

            commands.formatBlock(config.defaultBlock, contextDocument);
        },
        prepBlockValue: function prepBlockValue(value) {
            var ieVersion = browser.ieVersion();
            value = value.toUpperCase();
            return ieVersion && ieVersion < 12 ? '<' + value + '>' : value;
        }
    };

    // jshint strict: false

    var zeroWidthSpaceEntity = '&ZeroWidthSpace;';

    /**
     * zeroWidthSpace -
     * utililties for generating and asserting zeroWidthSpace entities used as bookend
     * hooks when dynamically setting selection range around content.
     * @access protected
     */
    var zeroWidthSpace = {
        generate: function generate() {
            var tmpEl = document.createElement('span');
            tmpEl.innerHTML = zeroWidthSpaceEntity;
            return tmpEl;
        },
        get: function get() {
            var tmpEl = zeroWidthSpace.generate();
            return tmpEl.firstChild;
        },
        assert: function assert(node) {
            var tmpEl = zeroWidthSpace.generate();
            if (node.nodeType === Node.ELEMENT_NODE) {
                return node.innerHTML === tmpEl.innerHTML;
            } else if (node.nodeType === Node.TEXT_NODE) {
                return node.nodeValue === tmpEl.firstChild.nodeValue;
            }
        }
    };

    // jshint strict: false


    /**
     * BaseFormatter -
     * A collection of the common formatter methods.
     * @access protected
     * @module modules/BaseFormatter
     *
     * @example
     * // Available commands
     * commands: {
     *     'format:export:to:canvas': 'exportToCanvas',
     *     'format:import:from:canvas': 'importFromCanvas',
     *     'format:default': 'formatDefault',
     *     'format:clean': 'formatClean'
     * }
     *
     * // Usage
     * mediator.exec('format:export:to:canvas'); // Export editor's content to canvas
     * mediator.exec('format:import:from:canvas'); // Import content from canvas
     * mediator.exec('format:default'); // Apply the default block formatting to the selection
     * mediator.exec('format:clean', elem); // Clean the HTML inside elem
     */
    var validTags = Toolbar$2.getValidTags();
    var blockTags = Toolbar$2.getBlockTags();
    var listTags = Toolbar$2.getListTags();

    var BaseFormatter = Module({
        name: 'BaseFormatter',
        props: {},
        handlers: {
            requests: {},
            commands: {
                'format:export:to:canvas': 'exportToCanvas',
                'format:import:from:canvas': 'importFromCanvas',
                'format:default': 'formatDefault',
                'format:clean': 'formatClean'
            },
            events: {
                'contenteditable:newline': 'handleNewLine'
            }
        },
        methods: {
            init: function init() { },


            /**
             * @func exportToCanvas
             * @access protected
             * @description mediator.exec("format:export:to:canvas") - Selects the content from the current editor root element and
             * sends it to the canvas
             */
            exportToCanvas: function exportToCanvas() {
                var mediator = this.mediator;

                var rootElement = mediator.get('selection:rootelement');
                var canvasBody = mediator.get('canvas:body');
                this.injectHooks(rootElement);

                var rangeCoordinates = mediator.get('selection:range:coordinates');
                var clonedNodes = this.cloneNodes(rootElement);
                mediator.exec('canvas:content', clonedNodes);
                mediator.exec('canvas:select:by:coordinates', rangeCoordinates);

                this.removeZeroWidthSpaces(canvasBody);
            },


            /**
             * @func importFromCanvas
             * @access protected
             * @description mediator.exec("format:import:from:canvas", { importFilter() }) - Imports the content from the canvas and replaces the current editor's
             * content via a past execCommand
             * @param  {method} opts.importFilter optional - a filter method that will be given a reference to the canvasBody allowing for custom manipulation of the formatted content.
             */
            importFromCanvas: function importFromCanvas() {
                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var mediator = this.mediator;

                var canvasBody = mediator.get('canvas:body');

                mediator.exec('canvas:cache:selection');
                mediator.exec('format:clean', canvasBody);
                if (opts.importFilter) {
                    opts.importFilter(canvasBody);
                }
                mediator.exec('canvas:select:cachedSelection');

                var canvasSelectionCoordinates = mediator.get('canvas:selection:coordinates');
                mediator.exec('selection:select:all');
                mediator.exec('contenteditable:inserthtml', canvasBody.innerHTML);
                mediator.exec('selection:select:coordinates', canvasSelectionCoordinates);

                mediator.emit('import:from:canvas:complete');
            },


            /**
             * @func formatDefault
             * @access protected
             * @description mediator.exec("format:default") - Applies the default formatting to the current selection or line
             */
            formatDefault: function formatDefault() {
                var mediator = this.mediator;

                var rootElem = mediator.get('selection:rootelement');
                commands.defaultBlockFormat();
                this.removeStyledSpans(rootElem);
            },


            /**
             * @func formatClean
             * @access protected
             * @description mediator.exec("format:clean") - Cleans up the html in the current editor.
             */
            formatClean: function formatClean(rootElem) {
                this.unwrapInvalidElements(rootElem);
                this.defaultOrphanedTextNodes(rootElem);
                this.removeBrNodes(rootElem);
                this.ensureRootElems(rootElem);
                this.removeStyleAttributes(rootElem);
                this.removeEmptyNodes(rootElem, { recursive: true });

                // -----

                // this.removeBrNodes(rootElem);
                // // this.removeEmptyNodes(rootElem);
                // this.removeFontTags(rootElem);
                // this.removeStyledSpans(rootElem);
                // this.clearEntities(rootElem);
                // this.removeZeroWidthSpaces(rootElem);
                // this.defaultOrphanedTextNodes(rootElem);
                // this.removeEmptyNodes(rootElem, { recursive: true });
            },


            /**
             * PRIVATE METHODS:
             */
            cloneNodes: function cloneNodes(rootElement) {
                var clonedNodes = [];
                rootElement.childNodes.forEach(function (node) {
                    clonedNodes.push(node.cloneNode(true));
                });
                return clonedNodes;
            },
            injectHooks: function injectHooks(rootElement) {
                while (!/\w+/.test(rootElement.firstChild.textContent)) {
                    DOM.removeNode(rootElement.firstChild);
                }

                while (!/\w+/.test(rootElement.lastChild.textContent)) {
                    DOM.removeNode(rootElement.lastChild);
                }

                DOM.insertBefore(zeroWidthSpace.get(), rootElement.firstChild);
                DOM.insertAfter(zeroWidthSpace.get(), rootElement.lastChild);
            },
            formatEmptyNewLine: function formatEmptyNewLine() {
                var mediator = this.mediator;

                var anchorNode = mediator.get('selection:anchornode');
                var canDefaultNewline = !(anchorNode.innerText && anchorNode.innerText.trim().length) && !DOM.isIn(anchorNode, Toolbar$2.preventNewlineDefault);
                var anchorIsContentEditable = anchorNode.hasAttribute && anchorNode.hasAttribute('contenteditable');

                if (canDefaultNewline || anchorIsContentEditable) {
                    this.formatDefault();
                }
            },
            formateBlockquoteNewLine: function formateBlockquoteNewLine() {
                var mediator = this.mediator;


                commands.exec('outdent');
                this.formatDefault();

                var currentRangeClone = mediator.get('selection:range').cloneRange();
                var startContainer = currentRangeClone.startContainer;


                if (startContainer.previousSibling && startContainer.previousSibling.nodeName === 'BLOCKQUOTE') {
                    var brEls = startContainer.previousSibling.querySelectorAll('br');
                    var divEls = startContainer.previousSibling.querySelectorAll('div');

                    for (var i = 0; i < brEls.length; i++) {
                        DOM.removeNode(brEls[i]);
                    }

                    for (var _i = 0; _i < divEls.length; _i++) {
                        DOM.unwrap(divEls[_i]);
                    }

                    mediator.exec('selection:update:range', currentRangeClone);
                }
            },
            handleNewLine: function handleNewLine() {
                var mediator = this.mediator;

                var _mediator$get = mediator.get('selection:range'),
                    startContainer = _mediator$get.startContainer;

                var containerIsEmpty = !/\w+/.test(startContainer.textContent);
                var containerIsBlockquote = DOM.isIn(startContainer, 'BLOCKQUOTE');
                var isContentEditable = startContainer.nodeType === Node.ELEMENT_NODE && startContainer.hasAttribute('contenteditable');

                if (containerIsBlockquote) {
                    this.formateBlockquoteNewLine();
                } else if (containerIsEmpty || isContentEditable) {
                    this.formatEmptyNewLine();
                }
            },
            removeStyleAttributes: function removeStyleAttributes(rootElem) {
                var styleAttributeNodes = rootElem.querySelectorAll('[style]');
                styleAttributeNodes.forEach(function (styleAttributeNode) {
                    styleAttributeNode.removeAttribute('style');
                });
            },
            removeBrNodes: function removeBrNodes(rootElem) {
                var brNodes = rootElem.querySelectorAll('br');
                var brNodesToProcess = [];
                var brNodesToRemove = [];

                brNodes.forEach(function (brNode) {
                    var skipNode = brNode.skipNode;

                    if (skipNode) {
                        return;
                    }

                    var isLastChild = brNode === brNode.parentNode.lastChild;
                    var isDoubleBreak = brNode.nextSibling && brNode.nextSibling.nodeName === 'BR';
                    var isInBlock = DOM.isIn(brNode, blockTags, rootElem);

                    if (isLastChild) {
                        brNodesToRemove.push(isLastChild);
                        return;
                    }

                    if (isDoubleBreak && isInBlock) {
                        brNodesToProcess.push([brNode, brNode.nextSibling]);
                        brNode.nextSibling.skipNode = true;
                        return;
                    }
                });

                brNodesToProcess.forEach(function (brNodePair) {
                    var _brNodePair = slicedToArray(brNodePair, 2),
                        firstBrNode = _brNodePair[0],
                        secondBrNode = _brNodePair[1];

                    var closestBlock = DOM.getClosestInArray(firstBrNode, blockTags, rootElem);
                    var newParagraph = document.createElement('p');
                    var previousSibling = void 0;

                    while (previousSibling = firstBrNode.previousSibling) {
                        if (newParagraph.firstChild) {
                            DOM.insertBefore(previousSibling, newParagraph.firstChild);
                        } else {
                            newParagraph.appendChild(previousSibling);
                        }

                        DOM.insertBefore(newParagraph, closestBlock);
                    }

                    DOM.removeNode(firstBrNode);
                    DOM.removeNode(secondBrNode);
                });

                brNodesToRemove.forEach(function (brNode) {
                    DOM.removeNode(brNode);
                });
            },
            unwrapInvalidElements: function unwrapInvalidElements(rootElem) {
                var rootDoc = rootElem.ownerDocument;
                var walker = rootDoc.createTreeWalker(rootElem, NodeFilter.SHOW_ELEMENT, null, false);

                var invalidElements = [];
                while (walker.nextNode()) {
                    var currentNode = walker.currentNode;

                    var isInvalid = validTags.indexOf(currentNode.nodeName) < 0;
                    var isBrNode = currentNode.nodeName === 'BR'; // BR nodes are handled elsewhere
                    var isTypesterElem = currentNode.className && /typester/.test(currentNode.className);

                    if (isInvalid && !isBrNode && !isTypesterElem) {
                        invalidElements.unshift(currentNode);
                    }
                }

                invalidElements.forEach(function (invalidElement) {
                    var unwrappedNodes = DOM.unwrap(invalidElement, { keepNode: true });
                    if (!DOM.isIn(invalidElement, validTags, rootElem) && unwrappedNodes.length) {
                        var newParagraph = rootDoc.createElement('p');
                        unwrappedNodes.forEach(function (unwrappedNode) {
                            newParagraph.appendChild(unwrappedNode);
                        });
                        DOM.insertBefore(newParagraph, invalidElement);
                    }
                    DOM.removeNode(invalidElement);
                });
            },
            defaultOrphanedTextNodes: function defaultOrphanedTextNodes(rootElem) {
                var childNodes = rootElem.childNodes;

                for (var i = 0; i < childNodes.length; i++) {
                    var childNode = childNodes[i];
                    if (childNode.nodeType === Node.TEXT_NODE && /\w+/.test(childNode.textContent)) {
                        var newParagraph = document.createElement('p');
                        DOM.insertBefore(newParagraph, childNode);
                        newParagraph.appendChild(childNode);
                        while (newParagraph.nextSibling && blockTags.concat(listTags).indexOf(newParagraph.nextSibling.nodeName) < 0) {
                            newParagraph.appendChild(newParagraph.nextSibling);
                        }
                    }
                }
            },
            clearEntities: function clearEntities(rootElem) {
                var rootDoc = rootElem.ownerDocument;
                var walker = rootDoc.createTreeWalker(rootElem, NodeFilter.SHOW_TEXT, null, false);

                var textNodes = [];
                while (walker.nextNode()) {
                    textNodes.push(walker.currentNode);
                }

                textNodes.forEach(function (textNode) {
                    if (/\w+/.test(textNode.textContent)) {
                        textNode.nodeValue = textNode.nodeValue.replace(/^\u00a0/, '');
                        textNode.nodeValue = textNode.nodeValue.replace(/\u00a0$/, '');
                    }
                });
            },
            ensureRootElems: function ensureRootElems(rootElem) {
                var rootNodeTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'OL', 'UL', 'BLOCKQUOTE', 'P'];
                var nestableTags = [{
                    tags: ['OL', 'UL'],
                    validParents: ['OL', 'UL', 'LI']
                }, {
                    tags: ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'],
                    validParents: ['LI']
                }];
                var rootNodes = rootElem.querySelectorAll(rootNodeTags.join(', '));
                var validNesting = function validNesting(node) {
                    var validNesting = false;
                    nestableTags.forEach(function (nestingDict) {
                        if (nestingDict.tags.indexOf(node.tagName) > -1 && nestingDict.validParents.indexOf(node.parentNode.tagName) > -1) {
                            validNesting = true;
                        }
                    });
                    return validNesting;
                };

                var moveNodeToRoot = function moveNodeToRoot(node) {
                    if (node.parentNode === rootElem) {
                        return;
                    }

                    if (validNesting(node)) {
                        return;
                    }

                    var rootParentNode = node.parentNode;
                    if (node.tagName === 'P' && ['LI', 'BLOCKQUOTE'].indexOf(rootParentNode.tagName) > -1) {
                        while (node.firstChild) {
                            DOM.insertBefore(node.firstChild, node);
                        }
                        DOM.removeNode(node);
                        return;
                    }

                    while (rootParentNode.parentNode !== rootElem) {
                        rootParentNode = rootParentNode.parentNode;
                    }

                    DOM.insertBefore(node, rootParentNode);
                };

                rootNodes.forEach(moveNodeToRoot);
            },
            removeZeroWidthSpaces: function removeZeroWidthSpaces(rootElem) {
                rootElem.childNodes.forEach(function (childNode) {
                    if (childNode.nodeType === Node.TEXT_NODE && zeroWidthSpace.assert(childNode)) {
                        DOM.removeNode(childNode);
                    }
                });
            },
            removeEmptyNodes: function removeEmptyNodes(rootElem) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                if (rootElem.normalize) {
                    rootElem.normalize();
                }

                for (var i = rootElem.childNodes.length - 1; i >= 0; i--) {
                    var childNode = rootElem.childNodes[i];

                    if (childNode.nodeName === 'BR') {
                        continue;
                    }

                    if (opts.recursive && childNode.childNodes.length) {
                        this.removeEmptyNodes(childNode, { recursive: true, rootIsChild: true });
                    }

                    if (!/[\w\.,\/#!$%\^&\*;:{}=\-_`~()\'\"]/.test(childNode.textContent)) {
                        if (!opts.rootIsChild && !zeroWidthSpace.assert(childNode) && i > 0 || childNode.nodeType === Node.ELEMENT_NODE) {
                            DOM.removeNode(childNode);
                        }
                    }
                }
            },
            removeStyledSpans: function removeStyledSpans(rootElem) {
                var styledSpans = rootElem.querySelectorAll('span[style]');
                for (var i = styledSpans.length - 1; i >= 0; i--) {
                    var styledSpan = styledSpans[i];
                    while (styledSpan.firstChild) {
                        DOM.insertBefore(styledSpan.firstChild, styledSpan);
                    }
                    DOM.removeNode(styledSpan);
                }
            },
            removeFontNodes: function removeFontNodes(rootElem) {
                var fontTags = rootElem.querySelectorAll('font');
                for (var i = fontTags.length - 1; i >= 0; i--) {
                    var fontTag = fontTags[i];
                    while (fontTag.firstChild) {
                        DOM.insertBefore(fontTag.firstChild, fontTag);
                    }
                    DOM.removeNode(fontTag);
                }
            }
        }
    });

    // jshint strict: false

    /**
     * BlockFormatter -
     * Formatter responsible for handling block level formatting for: P, Blockquote
     * H1, H2, H3, etc.
     *
     * @access protected
     * @module modules/BlockFormatter
     *
     * @example
     * // Available commands
     * commands: {
     *   'format:block': 'formatBlock'
     * }
     *
     * mediator.exec('format:block', { style: 'H1' }); // Format selection to a H1 heading
     * mediator.exec('format:block', { style: 'BLOCKQUOTE' }); // Format selection to a blockquote
     *
     * // Other options include
     * { style: 'H1' } // H2, H3...H6
     * { style: 'P' }
     * { style: 'BLOCKQUOTE' }
     * { style: 'PRE' }
     */

    /**
    * @access protected
    */
    var BlockFormatter = Module({
        name: 'BlockFormatter',
        props: {
            selectionRootEl: null
        },
        handlers: {
            commands: {
                'format:block': 'formatBlock'
            },
            events: {}
        },
        methods: {
            init: function init() { },
            formatBlock: function formatBlock(opts) {
                this.preProcess(opts);
                this.process(opts);
                this.commit(opts);
            },
            preProcess: function preProcess() {
                var mediator = this.mediator;

                mediator.exec('format:export:to:canvas');
            },
            process: function process(opts) {
                var mediator = this.mediator;

                var canvasDoc = mediator.get('canvas:document');

                if (opts.toggle) {
                    if (opts.style === 'BLOCKQUOTE') {
                        commands.exec('outdent', null, canvasDoc);
                    }
                    commands.defaultBlockFormat(canvasDoc);
                } else {
                    commands.formatBlock(opts.style, canvasDoc);
                }
            },
            commit: function commit(opts) {
                var mediator = this.mediator,
                    cleanupBlockquote = this.cleanupBlockquote;

                var importFilter = opts.style === 'BLOCKQUOTE' ? cleanupBlockquote : null;
                mediator.exec('format:import:from:canvas', { importFilter: importFilter });
            },
            cleanupBlockquote: function cleanupBlockquote(rootElem) {
                var blockquoteParagraphs = rootElem.querySelectorAll('BLOCKQUOTE P');
                blockquoteParagraphs.forEach(function (paragraph) {
                    DOM.unwrap(paragraph);
                });
            }
        }
    });

    // jshint strict: false

    /**
     * TextFormatter -
     * Responsible for handling formatting for inline text. Bold. Italic.
     * @access protected
     * @module modules/TextFormatter
     *
     * @example
     * mediator.exec('format:text', { style: 'bold' });
     * mediator.exec('format:text', { style: 'italic' });
     */
    var TextFormatter = Module({
        name: 'TextFormatter',
        props: {
            cachedRange: null
        },
        handlers: {
            requests: {},
            commands: {
                'format:text': 'formatText'
            },
            events: {}
        },
        methods: {
            formatText: function formatText(opts) {
                this.preProcess();
                this.process(opts);
                this.postProcess();
            },
            preProcess: function preProcess() {
                var mediator = this.mediator;

                mediator.exec('contenteditable:refocus');
                mediator.exec('selection:reselect');
            },
            process: function process(opts) {
                commands.exec(opts.style, null);
            },
            postProcess: function postProcess() {
                var mediator = this.mediator;


                mediator.exec('contenteditable:refocus');
                // mediator.exec('selection:reselect');
            }
        }
    });

    // jshint strict: false


    /**
     * ListFormatter -
     * Responsible for the creation, cleanup, and removal of lists.
     * @access protected
     * @module modules/ListFormatter
     *
     * @example
     * mediator.exec('format:list', { style: 'ordered'}); // Toggle ordered list on current selection
     * mediator.exec('format:list', { style: 'unordered'}); // Toggle unordered list on current selection
     * mediator.exec('format:list:cleanup', domElement); // Find all lists and clean them up
     */
    var ListFormatter = Module({
        name: 'ListFormatter',
        props: {},
        dom: {},
        handlers: {
            requests: {},
            commands: {
                'format:list': 'formatList',
                'format:list:cleanup': 'cleanupListDOM'
            },
            events: {
                'contenteditable:tab:down': 'handleTabDown',
                'contenteditable:tab:up': 'handleTabUp'
            }
        },
        methods: {
            init: function init() { },
            formatList: function formatList(opts) {
                this.preProcess(opts);
                this.process(opts);
                this.commit(opts);
            },
            preProcess: function preProcess() {
                var mediator = this.mediator;

                mediator.exec('format:export:to:canvas');
            },
            process: function process(opts) {
                var mediator = this.mediator;

                var canvasDoc = mediator.get('canvas:document');
                var toggle = false;

                mediator.exec('canvas:cache:selection');
                switch (opts.style) {
                    case 'ordered':
                        toggle = mediator.get('selection:in:or:contains', ['OL']);
                        if (toggle) {
                            // this.prepListItemsForToggle();
                            // while (mediator.get('canvas:selection:in:or:contains', ['OL'])) {
                            //     commands.exec('outdent', null, canvasDoc);
                            // }
                            // commands.exec('insertOrderedList', null, canvasDoc);
                            // return;
                        } else if (mediator.get('selection:in:or:contains', ['UL'])) {
                            commands.exec('insertUnorderedList', null, canvasDoc);
                        }
                        commands.exec('insertOrderedList', null, canvasDoc);
                        break;
                    case 'unordered':
                        toggle = mediator.get('selection:in:or:contains', ['UL']);

                        if (mediator.get('selection:in:or:contains', ['OL'])) {
                            commands.exec('insertOrderedList', null, canvasDoc);
                        }
                        commands.exec('insertUnorderedList', null, canvasDoc);
                        break;
                    case 'outdent':
                        commands.exec('outdent', null, canvasDoc);
                        break;
                    case 'indent':
                        commands.exec('indent', null, canvasDoc);
                        break;
                }

                if (toggle) {
                    // mediator.exec('canvas:select:cachedSelection');
                    this.postProcessToggle(opts);
                } else {
                    mediator.exec('canvas:select:ensure:offsets');
                }

                // mediator.exec('canvas:select:cachedSelection');
            },
            commit: function commit() {
                var mediator = this.mediator,
                    cleanupListDOM = this.cleanupListDOM;

                mediator.exec('format:import:from:canvas', {
                    importFilter: cleanupListDOM
                });
            },
            handleTabDown: function handleTabDown(evnt) {
                var mediator = this.mediator;

                var isInList = mediator.get('selection:in:or:contains', ['UL', 'OL']);

                if (isInList) {
                    evnt.preventDefault();
                }
            },
            handleTabUp: function handleTabUp(evnt) {
                var mediator = this.mediator;

                var isInList = mediator.get('selection:in:or:contains', ['UL', 'OL']);

                if (isInList) {
                    evnt.preventDefault();


                }
            },
            prepListItemsForToggle: function prepListItemsForToggle() {
                var mediator = this.mediator;


                var canvasDoc = mediator.get('canvas:document');
                var canvasBody = mediator.get('canvas:body');

                var _mediator$get = mediator.get('canvas:selection'),
                    anchorNode = _mediator$get.anchorNode,
                    focusNode = _mediator$get.focusNode;

                var anchorLiNode = DOM.getClosest(anchorNode, 'LI', canvasBody);
                var focusLiNode = DOM.getClosest(focusNode, 'LI', canvasBody);

                mediator.exec('canvas:cache:selection');

                var selectedLiNodes = [anchorLiNode];
                var nextLiNode = anchorLiNode.nextSibling;
                while (nextLiNode && nextLiNode !== focusLiNode) {
                    selectedLiNodes.push(nextLiNode);
                    nextLiNode = nextLiNode.nextSibling;
                }
                selectedLiNodes.push(focusLiNode);

                selectedLiNodes.forEach(function (selectedLiNode) {
                    var contentWrapper = canvasDoc.createElement('span');
                    selectedLiNode.appendChild(contentWrapper);
                    while (selectedLiNode.firstChild !== contentWrapper) {
                        contentWrapper.appendChild(selectedLiNode.firstChild);
                    }
                });

                mediator.exec('canvas:select:cachedSelection');

                return;
                // const canvasBody = mediator.get('canvas:body');
                // const canvasDoc = mediator.get('canvas:document');
                //
                // let rootBlock = anchorNode;
                // while(rootBlock.parentNode !== canvasBody) {
                //     rootBlock = rootBlock.parentNode;
                // }
                //
                // const liNodes = rootBlock.querySelectorAll('li');
                // liNodes.forEach((liNode) => {
                //     let pNode = canvasDoc.createElement('span');
                //     liNode.appendChild(pNode);
                //     while (liNode.firstChild !== pNode) {
                //         pNode.appendChild(liNode.firstChild);
                //     }
                // });
            },
            postProcessToggle: function postProcessToggle() {
                var mediator = this.mediator;
                // return;

                var canvasDoc = mediator.get('canvas:document');
                var canvasBody = mediator.get('canvas:body');

                mediator.exec('canvas:cache:selection');

                var _mediator$get2 = mediator.get('canvas:selection'),
                    anchorNode = _mediator$get2.anchorNode,
                    focusNode = _mediator$get2.focusNode;

                var walkToRoot = function walkToRoot(node) {
                    var rootNode = node;
                    while (rootNode.parentNode !== canvasBody) {
                        rootNode = rootNode.parentNode;
                    }
                    return rootNode;
                };

                var anchorRootNode = walkToRoot(anchorNode);
                var focusRootNode = walkToRoot(focusNode);

                var currentNode = anchorRootNode;
                var currentParagraph = void 0;

                var createParagraph = function createParagraph() {
                    currentParagraph = canvasDoc.createElement('p');
                    DOM.insertBefore(currentParagraph, currentNode);
                };

                var handleBrNode = function handleBrNode(brNode) {
                    createParagraph();
                    currentNode = brNode.nextSibling;
                    DOM.removeNode(brNode);
                };

                var handleDivNode = function handleDivNode(divNode) {
                    createParagraph();
                    currentNode = divNode.nextSibling;
                    while (divNode.firstChild) {
                        currentParagraph.appendChild(divNode.firstChild);
                    }
                    DOM.removeNode(divNode);
                };

                createParagraph();

                while (currentNode !== focusRootNode) {
                    if (currentNode.nodeName === 'BR') {
                        handleBrNode(currentNode);
                    } else if (currentNode.nodeName === 'DIV') {
                        handleDivNode(currentNode);
                    } else {
                        var orphanedNode = currentNode;
                        currentNode = currentNode.nextSibling;
                        currentParagraph.appendChild(orphanedNode);
                    }
                }

                if (focusRootNode.nodeName === 'DIV') {
                    handleDivNode(focusRootNode);
                } else {
                    currentParagraph.appendChild(focusRootNode);
                }

                mediator.exec('canvas:select:cachedSelection');
            },
            cleanupListDOM: function cleanupListDOM(rootElem) {
                var listContainers = rootElem.querySelectorAll('OL, UL');

                for (var i = listContainers.length - 1; i >= 0; i--) {
                    var listContainer = listContainers[i];
                    if (['OL', 'UL'].indexOf(listContainer.parentNode.nodeName) > -1) {
                        if (listContainer.previousSibling) {
                            if (listContainer.previousSibling.nodeName === 'LI') {
                                listContainer.previousSibling.appendChild(listContainer);
                            }

                            if (['OL', 'UL'].indexOf(listContainer.previousSibling.nodeName) > -1) {
                                for (var j = 0; j <= listContainer.childNodes.length; j++) {
                                    listContainer.previousSibling.appendChild(listContainer.childNodes[j]);
                                }
                                DOM.removeNode(listContainer);
                            }
                        } else {
                            DOM.unwrap(listContainer);
                        }
                    } else {
                        while (listContainer.parentNode && listContainer.parentNode !== rootElem && ['LI'].indexOf(listContainer.parentNode.nodeName) < 0) {
                            DOM.insertBefore(listContainer, listContainer.parentNode);
                        }
                    }
                }

                var nestedListItems = rootElem.querySelectorAll('LI > LI');
                for (var _i = nestedListItems.length - 1; _i >= 0; _i--) {
                    var nestedListItem = nestedListItems[_i];
                    DOM.insertAfter(nestedListItem, nestedListItem.parentNode);
                }
            }
        }
    });

    var Template$6 = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            var helper;

            return "<form class='typester-input-form'>\n    <input type='text' name='user-input' class='user-input' value='" + container.escapeExpression((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "value", "hash": {}, "data": data }) : helper)) + "' />\n    <button type='submit'>\n        <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n             viewBox=\"0 180 20 20\" enable-background=\"new 0 180 20 20\" xml:space=\"preserve\" height=\"20px\" width=\"20px\">\n             <polyline class=\"checkmark-2\" fill=\"none\" stroke=\"#FFFFFF\" stroke-width=\"5.3\" stroke-miterlimit=\"10\" points=\"1.9,188.8 7.5,194.4 18.1,183.9 \"/>\n        </svg>\n    </button>\n    <button type='cancel'>\n        <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n             viewBox=\"0 0 20 20\" enable-background=\"new 0 0 20 20\" xml:space=\"preserve\" width=\"20px\" height=\"20px\">\n             <path id=\"XMLID_730_\" d=\"M16.4,19.8c-0.2,0.2-0.5,0.2-0.6,0L10,14l-5.7,5.7c-0.2,0.2-0.5,0.2-0.6,0l-3.4-3.4c-0.2-0.2-0.2-0.5,0-0.6\n            L6,10L0.2,4.3c-0.2-0.2-0.2-0.5,0-0.6l3.4-3.4c0.2-0.2,0.5-0.2,0.6,0L10,6l5.7-5.7c0.2-0.2,0.5-0.2,0.6,0l3.4,3.4\n            c0.2,0.2,0.2,0.5,0,0.6L14,10l5.7,5.7c0.2,0.2,0.2,0.5,0,0.6L16.4,19.8z\"/>\n        </svg>\n    </button>\n</form>\n";
        }, "useData": true
    });
    var inputFormTemplate = function (data, options, asString) {
        var html = Template$6(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var Template$7 = runtime.template({
        "compiler": [7, ">= 4.0.0"], "main": function main(container, depth0, helpers, partials, data) {
            var helper;

            return "<div class='typester-link-display'>\n    <a>" + container.escapeExpression((helper = (helper = helpers.href || (depth0 != null ? depth0.href : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "href", "hash": {}, "data": data }) : helper)) + "</a>\n</div>\n";
        }, "useData": true
    });
    var linkDisplayTemplate = function (data, options, asString) {
        var html = Template$7(data, options);
        return asString || typeof $ === 'undefined' ? html : $(html);
    };

    var inputFormStyles = ".typester-input-form input[type=text] {\n  background: none;\n  border: none;\n  padding: 5px 15px;\n  height: 30px;\n  color: #FFF;\n  width: 250px;\n  outline: none;\n  vertical-align: top; }\n\n.typester-input-form button {\n  height: 40px;\n  width: 40px;\n  line-height: 40px;\n  background: none;\n  border: none;\n  color: #FFF;\n  cursor: pointer;\n  outline: none;\n  text-align: center;\n  padding: 0;\n  margin: 0;\n  vertical-align: top; }\n  .typester-input-form button:hover {\n    background: #00aeef; }\n  .typester-input-form button svg {\n    display: block;\n    height: 16px;\n    width: 16px;\n    margin: 12px;\n    fill: #FFF;\n    stroke: #FFF;\n    text-align: center; }\n\n.typester-link-display a {\n  display: block;\n  cursor: pointer;\n  line-height: 20px;\n  padding: 10px; }\n";

    // jshint strict: false


    /**
     * LinkFormatter -
     * Responsible for handlding the creation, updating, and removal of links
     * @access protected
     * @module modules/LinkFormatter
     *
     * @example
     * mediator.exec('format:link'); // Remove link if already a link, otherwise show link toolbar flyout.
     * mediator.request('format:link:active'); // returns true if selection is in or wraps a link.
     */

    var LinkFormatter = Module({
        name: 'LinkFormatter',
        props: {
            urlRegex: /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/,
            styles: null,
            currentAnchor: null,
            active: false,
            hasMouse: false,
            showing: null,
            hideTimeout: null,
            initialEvent: null,
            targetEl: null,
            hasRendered: null
        },
        dom: {
            'userInput': '.user-input'
        },
        handlers: {
            requests: {
                'format:link:active': 'isActive'
            },
            commands: {
                'format:link': 'formatLink'
            },
            events: {
                'app:destroy': 'destroy',
                'contenteditable:mouseover:anchor': 'showLinkFlyout',
                'contenteditable:mouseout:anchor': 'hideFlyout',
                'selection:update': 'handleSelectionChange',
                'selection:change': 'handleSelectionChange',
                'contenteditable:blur': 'handleContentEditableBlur'
            },
            domEvents: {
                'submit': 'handleSubmit',
                'click': 'handleClick',
                'mouseover': 'handleMouseOver',
                'mouseout': 'handleMouseOut'
            }
        },
        methods: {
            setup: function setup() {
                this.appendStyles();
            },
            appendStyles: function appendStyles() {
                var props = this.props;

                props.styles = DOM.addStyles(inputFormStyles);
            },
            formatLink: function formatLink() {
                if (this.isInLink()) {
                    this.removeLink();
                } else {
                    this.showLinkFormFlyout();
                }
            },
            isInLink: function isInLink() {
                var mediator = this.mediator;

                return mediator.get('selection:in:or:contains', ['A']);
            },
            showLinkFormFlyout: function showLinkFormFlyout(data) {
                var mediator = this.mediator,
                    props = this.props;

                var linkForm = this.compileLinkForm(data);

                props.showing = 'linkForm';
                this.render({ content: linkForm });
                mediator.exec('selection:wrap:pseudo');
                this.focusInput();
                this.bindInput();
            },
            showLinkFlyout: function showLinkFlyout(evnt) {
                var props = this.props,
                    mediator = this.mediator;

                var anchor = DOM.getClosest(evnt.target, 'A');

                if (mediator.get('selection:contains:node', anchor) || props.showing === 'linkForm') {
                    return;
                }

                this.clearHideTimeout();

                var linkDisplay = this.compileLinkDisplay({ href: anchor.href });

                props.initialEvent = evnt;
                props.targetEl = anchor;
                this.render({
                    content: linkDisplay,
                    flyoutPlacement: 'below'
                });
                props.showing = 'linkDisplay';
                props.currentAnchor = anchor;
            },
            hideFlyout: function hideFlyout() {
                var _this = this;

                var props = this.props;

                props.hideTimeout = setTimeout(function () {
                    if (!_this.isActive() && props.hasRendered) {
                        _this.destroy();
                    }
                }, 350);
            },
            clearHideTimeout: function clearHideTimeout() {
                var props = this.props;

                if (props.hideTimeout) {
                    clearTimeout(props.hideTimeout);
                    props.hideTimeout = null;
                }
            },
            compileLinkForm: function compileLinkForm(data) {
                var wrapperEl = document.createElement('div');
                var inputFormHTML = inputFormTemplate(data);

                if (typeof inputFormHTML === 'string') {
                    wrapperEl.innerHTML = inputFormHTML;
                } else {
                    wrapperEl.appendChild(inputFormHTML[0]);
                }

                return wrapperEl.childNodes[0];
            },
            compileLinkDisplay: function compileLinkDisplay(data) {
                var wrapperEl = document.createElement('div');
                var inputFormHTML = linkDisplayTemplate(data);

                if (typeof inputFormHTML === 'string') {
                    wrapperEl.innerHTML = inputFormHTML;
                } else {
                    wrapperEl.appendChild(inputFormHTML[0]);
                }

                return wrapperEl.childNodes[0];
            },
            render: function render(opts) {
                var mediator = this.mediator,
                    props = this.props;


                props.hasMouse = false;
                props.flyout = props.flyout || mediator.get('flyout:new');
                props.flyout.clearContent();
                props.flyout.setPlacement(opts.flyoutPlacement);
                props.flyout.appendContent(opts.content);

                this.positionFlyout(opts);
                this.showFlyout();

                props.hasRendered = true;
                return props.flyout.el;
            },
            positionFlyout: function positionFlyout(opts) {
                var mediator = this.mediator,
                    props = this.props;
                var initialEvent = props.initialEvent,
                    targetEl = props.targetEl;

                var targetBounds = void 0,
                    elStyles = void 0,
                    elLineHeight = void 0,
                    lineCount = void 0,
                    lineStepHeight = void 0;

                if (targetEl) {
                    targetBounds = targetEl.getBoundingClientRect();
                    elStyles = window.getComputedStyle(targetEl);
                    elLineHeight = parseInt(elStyles.getPropertyValue('line-height'), 10);
                    lineCount = Math.ceil(targetBounds.height / elLineHeight);
                    lineStepHeight = targetBounds.height / lineCount;
                } else {
                    targetBounds = mediator.get('selection:bounds');
                }

                if (targetBounds.width > 0) {
                    var scrollOffset = DOM.getScrollOffset();
                    var docRelTop = void 0,
                        docRelCenter = void 0;

                    if (initialEvent) {
                        var topDiff = initialEvent.clientY - targetBounds.top;

                        docRelTop = initialEvent.clientY;
                        docRelCenter = initialEvent.clientX;

                        if (opts.flyoutPlacement === 'below') {
                            docRelTop = targetBounds.top + lineStepHeight * Math.ceil(topDiff / lineStepHeight);
                        } else {
                            docRelTop = targetBounds.top + lineStepHeight * Math.floor(topDiff / lineStepHeight);
                        }
                    } else {
                        docRelTop = opts.flyoutPlacement === 'below' ? targetBounds.bottom : targetBounds.top;
                        docRelCenter = targetBounds.width / 2 + targetBounds.left + scrollOffset.x;
                    }

                    docRelTop += scrollOffset.y;

                    props.flyout.position({
                        left: docRelCenter + 'px',
                        top: docRelTop + 'px'
                    });
                }
            },
            showFlyout: function showFlyout() {
                var mediator = this.mediator,
                    props = this.props;

                props.flyout.show();
                mediator.exec('toolbar:hide');
            },
            focusInput: function focusInput() {
                var dom = this.dom;

                dom.userInput[0].focus();
            },
            bindInput: function bindInput() {
                var dom = this.dom,
                    props = this.props;

                dom.userInput[0].addEventListener('blur', this.handleBlur);
                props.userInputBound = true;
            },
            unbindInput: function unbindInput() {
                var dom = this.dom,
                    props = this.props;

                if (props.userInputBound) {
                    props.userInputBound = false;
                    dom.userInput[0].removeEventListener('blur', this.handleBlur);
                }
            },
            handleSubmit: function handleSubmit(evnt) {
                evnt.preventDefault();
                var formJSON = this.processForm();
                if (formJSON['user-input']) {
                    this.createLink(formJSON);
                } else {
                    this.removeLink({ byPseudo: true });
                }
            },
            handleClick: function handleClick(evnt) {
                var mediator = this.mediator,
                    props = this.props;

                if (evnt.target.nodeName === 'A') {
                    evnt.preventDefault();
                    mediator.exec('selection:wrap:element', props.currentAnchor, { silent: true });
                    this.showLinkFormFlyout({ value: props.currentAnchor.href });
                }
            },
            handleMouseOver: function handleMouseOver() {
                var props = this.props;

                props.hasMouse = true;
            },
            handleMouseOut: function handleMouseOut() {
                var props = this.props;

                props.hasMouse = false;

                if (props.showing === 'linkDisplay') {
                    this.hideFlyout();
                }
            },
            handleBlur: function handleBlur() {
                var _this2 = this;

                var props = this.props;

                if (props.blurTimeout) {
                    clearTimeout(props.blurTimeout);
                }

                props.blurTimeout = setTimeout(function () {
                    _this2.hideFlyout();
                }, 100);
            },
            handleSelectionChange: function handleSelectionChange() {
                if (!this.isActive()) {
                    this.hideFlyout();
                }
            },
            handleContentEditableBlur: function handleContentEditableBlur() {
                this.hideFlyout();
            },
            isActive: function isActive() {
                var props = this.props,
                    dom = this.dom;

                return props.hasMouse || dom && document.activeElement === dom.userInput[0] || props.showingLinkFlyout;
            },
            processForm: function processForm() {
                var dom = this.dom;

                var formInputs = dom.el[0].querySelectorAll('input, select, textarea');
                var formJSON = {};

                for (var i = 0; i < formInputs.length; i++) {
                    var inputEl = formInputs[i];
                    var inputName = inputEl.name;
                    var inputValue = inputEl.value;

                    if (inputName) {
                        formJSON[inputName] = inputValue;
                    }
                }

                return formJSON;
            },
            processLinkInput: function processLinkInput(linkInput) {
                var props = this.props;


                if (props.urlRegex.test(linkInput) && linkInput.indexOf('//') < 0) {
                    linkInput = 'http://' + linkInput;
                }

                return linkInput;
            },
            createLink: function createLink(formJSON) {
                var mediator = this.mediator;


                if (formJSON['user-input']) {
                    var linkURL = this.processLinkInput(formJSON['user-input']);
                    mediator.exec('selection:select:pseudo');
                    commands.exec('unlink');
                    commands.exec('createLink', linkURL);
                }

                this.destroy();
            },
            removeLink: function removeLink() {
                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var mediator = this.mediator;


                if (opts.byPseudo) {
                    mediator.exec('selection:select:pseudo');
                } else {
                    var anchorNode = mediator.get('selection:anchornode');
                    var anchor = DOM.getClosest(anchorNode, 'A');
                    mediator.exec('selection:wrap:element', anchor);
                }

                commands.exec('unlink');
                this.destroy();
            },
            destroy: function destroy() {
                var props = this.props,
                    mediator = this.mediator;

                if (props.flyout) {
                    this.unbindInput();
                    props.flyout.remove();
                }
                props.showing = null;
                props.hasMouse = false;
                props.hasRendered = null;
                mediator.exec('selection:select:remove:pseudo');
            }
        }
    });

    var purify = createCommonjsModule(function (module, exports) {
        (function (global, factory) {
            module.exports = factory();
        }(commonjsGlobal, (function () {
            'use strict';

            var html = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];

            // SVG
            var svg = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern'];

            var svgFilters = ['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence'];

            var mathMl = ['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmuliscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mpspace', 'msqrt', 'mystyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover'];

            var text = ['#text'];

            var html$1 = ['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns'];

            var svg$1 = ['accent-height', 'accumulate', 'additivive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan'];

            var mathMl$1 = ['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns'];

            var xml = ['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink'];

            /* Add properties to a lookup table */
            function addToSet(set, array) {
                var l = array.length;
                while (l--) {
                    if (typeof array[l] === 'string') {
                        array[l] = array[l].toLowerCase();
                    }
                    set[array[l]] = true;
                }
                return set;
            }

            /* Shallow clone an object */
            function clone(object) {
                var newObject = {};
                var property = void 0;
                for (property in object) {
                    if (Object.prototype.hasOwnProperty.call(object, property)) {
                        newObject[property] = object[property];
                    }
                }
                return newObject;
            }

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

            var getGlobal = function getGlobal() {
                return typeof window === 'undefined' ? null : window;
            };

            function createDOMPurify() {
                var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

                var DOMPurify = function DOMPurify(root) {
                    return createDOMPurify(root);
                };

                /**
                    * Version label, exposed for easier checks
                    * if DOMPurify is up to date or not
                    */
                DOMPurify.version = '1.0.2';

                /**
                  * Array of elements that DOMPurify removed during sanitation.
                  * Empty if nothing was removed.
                  */
                DOMPurify.removed = [];

                if (!window || !window.document || window.document.nodeType !== 9) {
                    // Not running in a browser, provide a factory function
                    // so that you can pass your own Window
                    DOMPurify.isSupported = false;

                    return DOMPurify;
                }

                var originalDocument = window.document;
                var useDOMParser = false; // See comment below
                var useXHR = false;

                var document = window.document;
                var DocumentFragment = window.DocumentFragment,
                    HTMLTemplateElement = window.HTMLTemplateElement,
                    Node = window.Node,
                    NodeFilter = window.NodeFilter,
                    _window$NamedNodeMap = window.NamedNodeMap,
                    NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
                    Text = window.Text,
                    Comment = window.Comment,
                    DOMParser = window.DOMParser,
                    _window$XMLHttpReques = window.XMLHttpRequest,
                    XMLHttpRequest = _window$XMLHttpReques === undefined ? window.XMLHttpRequest : _window$XMLHttpReques,
                    _window$encodeURI = window.encodeURI,
                    encodeURI = _window$encodeURI === undefined ? window.encodeURI : _window$encodeURI;

                // As per issue #47, the web-components registry is inherited by a
                // new document created via createHTMLDocument. As per the spec
                // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
                // a new empty registry is used when creating a template contents owner
                // document, so we use that as our parent document to ensure nothing
                // is inherited.

                if (typeof HTMLTemplateElement === 'function') {
                    var template = document.createElement('template');
                    if (template.content && template.content.ownerDocument) {
                        document = template.content.ownerDocument;
                    }
                }

                var _document = document,
                    implementation = _document.implementation,
                    createNodeIterator = _document.createNodeIterator,
                    getElementsByTagName = _document.getElementsByTagName,
                    createDocumentFragment = _document.createDocumentFragment;

                var importNode = originalDocument.importNode;

                var hooks = {};

                /**
                  * Expose whether this browser supports running the full DOMPurify.
                  */
                DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;

                /**
                  * We consider the elements and attributes below to be safe. Ideally
                  * don't add any new ones but feel free to remove unwanted ones.
                  */

                /* allowed element names */
                var ALLOWED_TAGS = null;
                var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));

                /* Allowed attribute names */
                var ALLOWED_ATTR = null;
                var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));

                /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
                var FORBID_TAGS = null;

                /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
                var FORBID_ATTR = null;

                /* Decide if ARIA attributes are okay */
                var ALLOW_ARIA_ATTR = true;

                /* Decide if custom data attributes are okay */
                var ALLOW_DATA_ATTR = true;

                /* Decide if unknown protocols are okay */
                var ALLOW_UNKNOWN_PROTOCOLS = false;

                /* Output should be safe for jQuery's $() factory? */
                var SAFE_FOR_JQUERY = false;

                /* Output should be safe for common template engines.
                 * This means, DOMPurify removes data attributes, mustaches and ERB
                 */
                var SAFE_FOR_TEMPLATES = false;

                /* Specify template detection regex for SAFE_FOR_TEMPLATES mode */
                var MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm;
                var ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm;

                /* Decide if document with <html>... should be returned */
                var WHOLE_DOCUMENT = false;

                /* Track whether config is already set on this instance of DOMPurify. */
                var SET_CONFIG = false;

                /* Decide if all elements (e.g. style, script) must be children of
                 * document.body. By default, browsers might move them to document.head */
                var FORCE_BODY = false;

                /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string.
                 * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
                 */
                var RETURN_DOM = false;

                /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */
                var RETURN_DOM_FRAGMENT = false;

                /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
                 * `Node` is imported into the current `Document`. If this flag is not enabled the
                 * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
                 * DOMPurify. */
                var RETURN_DOM_IMPORT = false;

                /* Output should be free from DOM clobbering attacks? */
                var SANITIZE_DOM = true;

                /* Keep element content when removing element? */
                var KEEP_CONTENT = true;

                /* Allow usage of profiles like html, svg and mathMl */
                var USE_PROFILES = {};

                /* Tags to ignore content of when KEEP_CONTENT is true */
                var FORBID_CONTENTS = addToSet({}, ['audio', 'head', 'math', 'script', 'style', 'template', 'svg', 'video']);

                /* Tags that are safe for data: URIs */
                var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);

                /* Attributes safe for values like "javascript:" */
                var URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

                /* Keep a reference to config to pass to hooks */
                var CONFIG = null;

                /* Ideally, do not touch anything below this line */
                /* ______________________________________________ */

                var formElement = document.createElement('form');

                /**
                * _parseConfig
                *
                * @param  optional config literal
                */
                // eslint-disable-next-line complexity
                var _parseConfig = function _parseConfig(cfg) {
                    /* Shield configuration object from tampering */
                    if ((typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
                        cfg = {};
                    }

                    /* Set configuration parameters */
                    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
                    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
                    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
                    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
                    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
                    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
                    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
                    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
                    SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false
                    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
                    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
                    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
                    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
                    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false
                    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
                    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
                    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

                    if (SAFE_FOR_TEMPLATES) {
                        ALLOW_DATA_ATTR = false;
                    }

                    if (RETURN_DOM_FRAGMENT) {
                        RETURN_DOM = true;
                    }

                    /* Parse profile info */
                    if (USE_PROFILES) {
                        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));
                        ALLOWED_ATTR = [];
                        if (USE_PROFILES.html === true) {
                            addToSet(ALLOWED_TAGS, html);
                            addToSet(ALLOWED_ATTR, html$1);
                        }
                        if (USE_PROFILES.svg === true) {
                            addToSet(ALLOWED_TAGS, svg);
                            addToSet(ALLOWED_ATTR, svg$1);
                            addToSet(ALLOWED_ATTR, xml);
                        }
                        if (USE_PROFILES.svgFilters === true) {
                            addToSet(ALLOWED_TAGS, svgFilters);
                            addToSet(ALLOWED_ATTR, svg$1);
                            addToSet(ALLOWED_ATTR, xml);
                        }
                        if (USE_PROFILES.mathMl === true) {
                            addToSet(ALLOWED_TAGS, mathMl);
                            addToSet(ALLOWED_ATTR, mathMl$1);
                            addToSet(ALLOWED_ATTR, xml);
                        }
                    }

                    /* Merge configuration parameters */
                    if (cfg.ADD_TAGS) {
                        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                            ALLOWED_TAGS = clone(ALLOWED_TAGS);
                        }
                        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
                    }
                    if (cfg.ADD_ATTR) {
                        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                            ALLOWED_ATTR = clone(ALLOWED_ATTR);
                        }
                        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
                    }
                    if (cfg.ADD_URI_SAFE_ATTR) {
                        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
                    }

                    /* Add #text in case KEEP_CONTENT is set to true */
                    if (KEEP_CONTENT) {
                        ALLOWED_TAGS['#text'] = true;
                    }

                    // Prevent further manipulation of configuration.
                    // Not available in IE8, Safari 5, etc.
                    if (Object && 'freeze' in Object) {
                        Object.freeze(cfg);
                    }

                    CONFIG = cfg;
                };

                /**
                * _forceRemove
                *
                * @param  a DOM node
                */
                var _forceRemove = function _forceRemove(node) {
                    DOMPurify.removed.push({ element: node });
                    try {
                        node.parentNode.removeChild(node);
                    } catch (err) {
                        node.outerHTML = '';
                    }
                };

                /**
                * _removeAttribute
                *
                * @param  an Attribute name
                * @param  a DOM node
                */
                var _removeAttribute = function _removeAttribute(name, node) {
                    DOMPurify.removed.push({
                        attribute: node.getAttributeNode(name),
                        from: node
                    });
                    node.removeAttribute(name);
                };

                /**
                * _initDocument
                *
                * @param  a string of dirty markup
                * @return a DOM, filled with the dirty markup
                */
                var _initDocument = function _initDocument(dirty) {
                    /* Create a HTML document */
                    var doc = void 0;
                    var body = void 0;

                    if (FORCE_BODY) {
                        dirty = '<remove></remove>' + dirty;
                    }

                    /* Use XHR if necessary because Safari 10.1 and newer are buggy */
                    if (useXHR) {
                        try {
                            dirty = encodeURI(dirty);
                        } catch (err) { }
                        var xhr = new XMLHttpRequest();
                        xhr.responseType = 'document';
                        xhr.open('GET', 'data:text/html;charset=utf-8,' + dirty, false);
                        xhr.send(null);
                        doc = xhr.response;
                    }

                    /* Use DOMParser to workaround Firefox bug (see comment below) */
                    if (useDOMParser) {
                        try {
                            doc = new DOMParser().parseFromString(dirty, 'text/html');
                        } catch (err) { }
                    }

                    /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
                    Safari (see comment below) */
                    if (!doc || !doc.documentElement) {
                        doc = implementation.createHTMLDocument('');
                        body = doc.body;
                        body.parentNode.removeChild(body.parentNode.firstElementChild);
                        body.outerHTML = dirty;
                    }

                    /* Work on whole document or just its body */
                    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
                };

                // Safari 10.1+ (unfixed as of time of writing) has a catastrophic bug in
                // its implementation of DOMParser such that the following executes the
                // JavaScript:
                //
                // new DOMParser()
                //   .parseFromString('<svg onload=alert(document.domain)>', 'text/html');
                //
                // Later, it was also noticed that even more assumed benign and inert ways
                // of creating a document are now insecure thanks to Safari. So we work
                // around that with a feature test and use XHR to create the document in
                // case we really have to. That one seems safe for now.
                //
                // However, Firefox uses a different parser for innerHTML rather than
                // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)
                // which means that you *must* use DOMParser, otherwise the output may
                // not be safe if used in a document.write context later.
                //
                // So we feature detect the Firefox bug and use the DOMParser if necessary.
                if (DOMPurify.isSupported) {
                    (function () {
                        var doc = _initDocument('<svg><g onload="this.parentNode.remove()"></g></svg>');
                        if (!doc.querySelector('svg')) {
                            useXHR = true;
                        }
                        try {
                            doc = _initDocument('<svg><p><style><img src="</style><img src=x onerror=alert(1)//">');
                            if (doc.querySelector('svg img')) {
                                useDOMParser = true;
                            }
                        } catch (err) { }
                    })();
                }

                /**
                * _createIterator
                *
                * @param  document/fragment to create iterator for
                * @return iterator instance
                */
                var _createIterator = function _createIterator(root) {
                    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
                        return NodeFilter.FILTER_ACCEPT;
                    }, false);
                };

                /**
                * _isClobbered
                *
                * @param  element to check for clobbering attacks
                * @return true if clobbered, false if safe
                */
                var _isClobbered = function _isClobbered(elm) {
                    if (elm instanceof Text || elm instanceof Comment) {
                        return false;
                    }
                    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function') {
                        return true;
                    }
                    return false;
                };

                /**
                * _isNode
                *
                * @param object to check whether it's a DOM node
                * @return true is object is a DOM node
                */
                var _isNode = function _isNode(obj) {
                    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
                };

                /**
                * _executeHook
                * Execute user configurable hooks
                *
                * @param  {String} entryPoint  Name of the hook's entry point
                * @param  {Node} currentNode
                */
                var _executeHook = function _executeHook(entryPoint, currentNode, data) {
                    if (!hooks[entryPoint]) {
                        return;
                    }

                    hooks[entryPoint].forEach(function (hook) {
                        hook.call(DOMPurify, currentNode, data, CONFIG);
                    });
                };

                /**
                * _sanitizeElements
                *
                * @protect nodeName
                * @protect textContent
                * @protect removeChild
                *
                * @param   node to check for permission to exist
                * @return  true if node was killed, false if left alive
                */
                var _sanitizeElements = function _sanitizeElements(currentNode) {
                    var content = void 0;

                    /* Execute a hook if present */
                    _executeHook('beforeSanitizeElements', currentNode, null);

                    /* Check if element is clobbered or can clobber */
                    if (_isClobbered(currentNode)) {
                        _forceRemove(currentNode);
                        return true;
                    }

                    /* Now let's check the element's type and name */
                    var tagName = currentNode.nodeName.toLowerCase();

                    /* Execute a hook if present */
                    _executeHook('uponSanitizeElement', currentNode, {
                        tagName: tagName,
                        allowedTags: ALLOWED_TAGS
                    });

                    /* Remove element if anything forbids its presence */
                    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                        /* Keep content except for black-listed elements */
                        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
                            try {
                                currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML);
                            } catch (err) { }
                        }
                        _forceRemove(currentNode);
                        return true;
                    }

                    /* Convert markup to cover jQuery behavior */
                    if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {
                        DOMPurify.removed.push({ element: currentNode.cloneNode() });
                        currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
                    }

                    /* Sanitize element content to be template-safe */
                    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
                        /* Get the element's text content */
                        content = currentNode.textContent;
                        content = content.replace(MUSTACHE_EXPR, ' ');
                        content = content.replace(ERB_EXPR, ' ');
                        if (currentNode.textContent !== content) {
                            DOMPurify.removed.push({ element: currentNode.cloneNode() });
                            currentNode.textContent = content;
                        }
                    }

                    /* Execute a hook if present */
                    _executeHook('afterSanitizeElements', currentNode, null);

                    return false;
                };

                var DATA_ATTR = /^data-[\-\w.\u00B7-\uFFFF]/; // eslint-disable-line no-useless-escape
                var ARIA_ATTR = /^aria-[\-\w]+$/; // eslint-disable-line no-useless-escape
                var IS_ALLOWED_URI = /^(?:(?:(?:f|ht)tps?|mailto|tel):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape
                var IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
                /* This needs to be extensive thanks to Webkit/Blink's behavior */
                var ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;

                /**
                * _sanitizeAttributes
                *
                * @protect attributes
                * @protect nodeName
                * @protect removeAttribute
                * @protect setAttribute
                *
                * @param   node to sanitize
                * @return  void
                */
                // eslint-disable-next-line complexity
                var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
                    var attr = void 0;
                    var name = void 0;
                    var value = void 0;
                    var lcName = void 0;
                    var idAttr = void 0;
                    var attributes = void 0;
                    var l = void 0;
                    /* Execute a hook if present */
                    _executeHook('beforeSanitizeAttributes', currentNode, null);

                    attributes = currentNode.attributes;

                    /* Check if we have attributes; if not we might have a text node */
                    if (!attributes) {
                        return;
                    }

                    var hookEvent = {
                        attrName: '',
                        attrValue: '',
                        keepAttr: true,
                        allowedAttributes: ALLOWED_ATTR
                    };
                    l = attributes.length;

                    /* Go backwards over all attributes; safely remove bad ones */
                    while (l--) {
                        attr = attributes[l];
                        name = attr.name;
                        value = attr.value.trim();
                        lcName = name.toLowerCase();

                        /* Execute a hook if present */
                        hookEvent.attrName = lcName;
                        hookEvent.attrValue = value;
                        hookEvent.keepAttr = true;
                        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
                        value = hookEvent.attrValue;

                        /* Remove attribute */
                        // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
                        // remove a "name" attribute from an <img> tag that has an "id"
                        // attribute at the time.
                        if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
                            idAttr = attributes.id;
                            attributes = Array.prototype.slice.apply(attributes);
                            _removeAttribute('id', currentNode);
                            _removeAttribute(name, currentNode);
                            if (attributes.indexOf(idAttr) > l) {
                                currentNode.setAttribute('id', idAttr.value);
                            }
                        } else if (
                            // This works around a bug in Safari, where input[type=file]
                            // cannot be dynamically set after type has been removed
                            currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
                            continue;
                        } else {
                            // This avoids a crash in Safari v9.0 with double-ids.
                            // The trick is to first set the id to be empty and then to
                            // remove the attribute
                            if (name === 'id') {
                                currentNode.setAttribute(name, '');
                            }
                            _removeAttribute(name, currentNode);
                        }

                        /* Did the hooks approve of the attribute? */
                        if (!hookEvent.keepAttr) {
                            continue;
                        }

                        /* Make sure attribute cannot clobber */
                        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in window || value in document || value in formElement)) {
                            continue;
                        }

                        /* Sanitize attribute content to be template-safe */
                        if (SAFE_FOR_TEMPLATES) {
                            value = value.replace(MUSTACHE_EXPR, ' ');
                            value = value.replace(ERB_EXPR, ' ');
                        }

                        /* Allow valid data-* attributes: At least one character after "-"
                           (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
                           XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
                           We don't need to check the value; it's always URI safe. */
                        if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) {
                            // This attribute is safe
                        } else if (ALLOW_ARIA_ATTR && ARIA_ATTR.test(lcName)) {
                            // This attribute is safe
                            /* Otherwise, check the name is permitted */
                        } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
                            continue;

                            /* Check value is safe. First, is attr inert? If so, is safe */
                        } else if (URI_SAFE_ATTRIBUTES[lcName]) {
                            // This attribute is safe
                            /* Check no script, data or unknown possibly unsafe URI
                             unless we know URI values are safe for that attribute */
                        } else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE, ''))) {
                            // This attribute is safe
                            /* Keep image data URIs alive if src/xlink:href is allowed */
                        } else if ((lcName === 'src' || lcName === 'xlink:href') && value.indexOf('data:') === 0 && DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]) {
                            // This attribute is safe
                            /* Allow unknown protocols: This provides support for links that
                             are handled by protocol handlers which may be unknown ahead of
                             time, e.g. fb:, spotify: */
                        } else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE, ''))) {
                            // This attribute is safe
                            /* Check for binary attributes */
                            // eslint-disable-next-line no-negated-condition
                        } else if (!value) {
                            // Binary attributes are safe at this point
                            /* Anything else, presume unsafe, do not add it back */
                        } else {
                            continue;
                        }

                        /* Handle invalid data-* attribute set by try-catching it */
                        try {
                            currentNode.setAttribute(name, value);
                            DOMPurify.removed.pop();
                        } catch (err) { }
                    }

                    /* Execute a hook if present */
                    _executeHook('afterSanitizeAttributes', currentNode, null);
                };

                /**
                * _sanitizeShadowDOM
                *
                * @param  fragment to iterate over recursively
                * @return void
                */
                var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
                    var shadowNode = void 0;
                    var shadowIterator = _createIterator(fragment);

                    /* Execute a hook if present */
                    _executeHook('beforeSanitizeShadowDOM', fragment, null);

                    while (shadowNode = shadowIterator.nextNode()) {
                        /* Execute a hook if present */
                        _executeHook('uponSanitizeShadowNode', shadowNode, null);

                        /* Sanitize tags and elements */
                        if (_sanitizeElements(shadowNode)) {
                            continue;
                        }

                        /* Deep shadow DOM detected */
                        if (shadowNode.content instanceof DocumentFragment) {
                            _sanitizeShadowDOM(shadowNode.content);
                        }

                        /* Check attributes, sanitize if necessary */
                        _sanitizeAttributes(shadowNode);
                    }

                    /* Execute a hook if present */
                    _executeHook('afterSanitizeShadowDOM', fragment, null);
                };

                /**
                * Sanitize
                * Public method providing core sanitation functionality
                *
                * @param {String|Node} dirty string or DOM node
                * @param {Object} configuration object
                */
                // eslint-disable-next-line complexity
                DOMPurify.sanitize = function (dirty, cfg) {
                    var body = void 0;
                    var importedNode = void 0;
                    var currentNode = void 0;
                    var oldNode = void 0;
                    var returnNode = void 0;
                    /* Make sure we have a string to sanitize.
                      DO NOT return early, as this will return the wrong type if
                      the user has requested a DOM object rather than a string */
                    if (!dirty) {
                        dirty = '<!-->';
                    }

                    /* Stringify, in case dirty is an object */
                    if (typeof dirty !== 'string' && !_isNode(dirty)) {
                        // eslint-disable-next-line no-negated-condition
                        if (typeof dirty.toString !== 'function') {
                            throw new TypeError('toString is not a function');
                        } else {
                            dirty = dirty.toString();
                        }
                    }

                    /* Check we can run. Otherwise fall back or ignore */
                    if (!DOMPurify.isSupported) {
                        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
                            if (typeof dirty === 'string') {
                                return window.toStaticHTML(dirty);
                            } else if (_isNode(dirty)) {
                                return window.toStaticHTML(dirty.outerHTML);
                            }
                        }
                        return dirty;
                    }

                    /* Assign config vars */
                    if (!SET_CONFIG) {
                        _parseConfig(cfg);
                    }

                    /* Clean up removed elements */
                    DOMPurify.removed = [];

                    if (dirty instanceof Node) {
                        /* If dirty is a DOM element, append to an empty document to avoid
                           elements being stripped by the parser */
                        body = _initDocument('<!-->');
                        importedNode = body.ownerDocument.importNode(dirty, true);
                        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
                            /* Node is already a body, use as is */
                            body = importedNode;
                        } else {
                            body.appendChild(importedNode);
                        }
                    } else {
                        /* Exit directly if we have nothing to do */
                        if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
                            return dirty;
                        }

                        /* Initialize the document to work on */
                        body = _initDocument(dirty);

                        /* Check we have a DOM node from the data */
                        if (!body) {
                            return RETURN_DOM ? null : '';
                        }
                    }

                    /* Remove first element node (ours) if FORCE_BODY is set */
                    if (FORCE_BODY) {
                        _forceRemove(body.firstChild);
                    }

                    /* Get node iterator */
                    var nodeIterator = _createIterator(body);

                    /* Now start iterating over the created document */
                    while (currentNode = nodeIterator.nextNode()) {
                        /* Fix IE's strange behavior with manipulated textNodes #89 */
                        if (currentNode.nodeType === 3 && currentNode === oldNode) {
                            continue;
                        }

                        /* Sanitize tags and elements */
                        if (_sanitizeElements(currentNode)) {
                            continue;
                        }

                        /* Shadow DOM detected, sanitize it */
                        if (currentNode.content instanceof DocumentFragment) {
                            _sanitizeShadowDOM(currentNode.content);
                        }

                        /* Check attributes, sanitize if necessary */
                        _sanitizeAttributes(currentNode);

                        oldNode = currentNode;
                    }

                    /* Return sanitized string or DOM */
                    if (RETURN_DOM) {
                        if (RETURN_DOM_FRAGMENT) {
                            returnNode = createDocumentFragment.call(body.ownerDocument);

                            while (body.firstChild) {
                                returnNode.appendChild(body.firstChild);
                            }
                        } else {
                            returnNode = body;
                        }

                        if (RETURN_DOM_IMPORT) {
                            /* AdoptNode() is not used because internal state is not reset
                                   (e.g. the past names map of a HTMLFormElement), this is safe
                                   in theory but we would rather not risk another attack vector.
                                   The state that is cloned by importNode() is explicitly defined
                                   by the specs. */
                            returnNode = importNode.call(originalDocument, returnNode, true);
                        }

                        return returnNode;
                    }

                    return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
                };

                /**
                * Public method to set the configuration once
                * setConfig
                *
                * @param {Object} configuration object
                * @return void
                */
                DOMPurify.setConfig = function (cfg) {
                    _parseConfig(cfg);
                    SET_CONFIG = true;
                };

                /**
                * Public method to remove the configuration
                * clearConfig
                *
                * @return void
                */
                DOMPurify.clearConfig = function () {
                    CONFIG = null;
                    SET_CONFIG = false;
                };

                /**
                * AddHook
                * Public method to add DOMPurify hooks
                *
                * @param {String} entryPoint
                * @param {Function} hookFunction
                */
                DOMPurify.addHook = function (entryPoint, hookFunction) {
                    if (typeof hookFunction !== 'function') {
                        return;
                    }
                    hooks[entryPoint] = hooks[entryPoint] || [];
                    hooks[entryPoint].push(hookFunction);
                };

                /**
                * RemoveHook
                * Public method to remove a DOMPurify hook at a given entryPoint
                * (pops it from the stack of hooks if more are present)
                *
                * @param {String} entryPoint
                * @return void
                */
                DOMPurify.removeHook = function (entryPoint) {
                    if (hooks[entryPoint]) {
                        hooks[entryPoint].pop();
                    }
                };

                /**
                * RemoveHooks
                * Public method to remove all DOMPurify hooks at a given entryPoint
                *
                * @param  {String} entryPoint
                * @return void
                */
                DOMPurify.removeHooks = function (entryPoint) {
                    if (hooks[entryPoint]) {
                        hooks[entryPoint] = [];
                    }
                };

                /**
                * RemoveAllHooks
                * Public method to remove all DOMPurify hooks
                *
                * @return void
                */
                DOMPurify.removeAllHooks = function () {
                    hooks = {};
                };

                return DOMPurify;
            }

            var purify = createDOMPurify();

            return purify;

        })));

    });

    // jshint strict: false

    // Taken from medium editor: https://github.com/yabwe/medium-editor/blob/master/src/js/extensions/paste.js

    /**
     * pasteUtils -
     * namespaced utility methods for cleaning paste data
     * @access protected
     */
    var pasteUtils = {
        createReplacements: function createReplacements() {
            return [
                // Remove anything but the contents within the BODY element
                [new RegExp(/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/g), ''],

                // cleanup comments added by Chrome when pasting html
                [new RegExp(/<!--StartFragment-->|<!--EndFragment-->/g), ''],

                // Trailing BR elements
                [new RegExp(/<br>$/i), ''],

                // replace two bogus tags that begin pastes from google docs
                [new RegExp(/<[^>]*docs-internal-guid[^>]*>/gi), ''], [new RegExp(/<\/b>(<br[^>]*>)?$/gi), ''],

                // un-html spaces and newlines inserted by OS X
                [new RegExp(/<span class="Apple-converted-space">\s+<\/span>/g), ' '], [new RegExp(/<br class="Apple-interchange-newline">/g), '<br>'],

                // replace google docs italics+bold with a span to be replaced once the html is inserted
                [new RegExp(/<span[^>]*(font-style:italic;font-weight:(bold|700)|font-weight:(bold|700);font-style:italic)[^>]*>/gi), '<span class="replace-with italic bold">'],

                // replace google docs italics with a span to be replaced once the html is inserted
                [new RegExp(/<span[^>]*font-style:italic[^>]*>/gi), '<span class="replace-with italic">'],

                //[replace google docs bolds with a span to be replaced once the html is inserted
                [new RegExp(/<span[^>]*font-weight:(bold|700)[^>]*>/gi), '<span class="replace-with bold">'],

                // replace manually entered b/i/a tags with real ones
                [new RegExp(/&lt;(\/?)(i|b|a)&gt;/gi), '<$1$2>'],

                // replace manually a tags with real ones, converting smart-quotes from google docs
                [new RegExp(/&lt;a(?:(?!href).)+href=(?:&quot;|&rdquo;|&ldquo;|"||)(((?!&quot;|&rdquo;|&ldquo;|"||).)*)(?:&quot;|&rdquo;|&ldquo;|"||)(?:(?!&gt;).)*&gt;/gi), '<a href="$1">'],

                // Newlines between paragraphs in html have no syntactic value,
                // but then have a tendency to accidentally become additional paragraphs down the line
                [new RegExp(/<\/p>\n+/gi), '</p>'], [new RegExp(/\n+<p/gi), '<p'],

                // Microsoft Word makes these odd tags, like <o:p></o:p>
                [new RegExp(/<\/?o:[a-z]*>/gi), ''],

                // Microsoft Word adds some special elements around list items
                [new RegExp(/<!\[if !supportLists\]>(((?!<!).)*)<!\[endif]\>/gi), '$1']];
        }
    };

    // jshint strict: false

    /**
     * Paste -
     * Handle paste event. Capture paste data, clean it and sanitize it in canvas
     * before importing it into the editor.
     * @access protected
     * @module modules/Paste
     */
    var Paste = Module({
        name: 'Paste',
        props: {},
        handlers: {
            commands: {},
            requests: {},
            events: {
                'contenteditable:paste': 'handlePaste'
            }
        },
        methods: {
            init: function init() { },
            handlePaste: function handlePaste(evnt) {
                evnt.preventDefault();

                var mediator = this.mediator;

                var _getClipboardContent = this.getClipboardContent(evnt, window, document),
                    pastedHTML = _getClipboardContent['text/html'],
                    pastedPlain = _getClipboardContent['text/plain'];

                if (!pastedHTML) {
                    pastedHTML = pastedPlain.replace(/(?:\r\n|\r|\n)/g, '<br />');
                }

                pastedHTML = this.cleanPastedHTML(pastedHTML);
                pastedHTML = purify.sanitize(pastedHTML);

                mediator.exec('contenteditable:inserthtml', pastedHTML);
            },
            getClipboardContent: function getClipboardContent(evnt, contextWindow, contextDocument) {
                var dataTransfer = evnt.clipboardData || contextWindow.clipboardData || contextDocument.dataTransfer;
                var data = {
                    pastedHTML: '',
                    pastedPlain: ''
                };

                if (!dataTransfer) {
                    return data;
                }

                if (dataTransfer.getData) {
                    var legacyText = dataTransfer.getData('text');
                    if (legacyText && legacyText.length > 0) {
                        data['text/plain'] = legacyText;
                    }
                }

                if (dataTransfer.types) {
                    for (var i = 0; i < dataTransfer.types.length; i++) {
                        var contentType = dataTransfer.types[i];
                        data[contentType] = dataTransfer.getData(contentType);
                    }
                }

                return data;
            },
            cleanPastedHTML: function cleanPastedHTML(pastedHTML) {
                var mediator = this.mediator;

                var canvasDoc = mediator.get('canvas:document');
                var canvasBody = mediator.get('canvas:body');
                var replacements = pasteUtils.createReplacements();

                for (var i = 0; i < replacements.length; i++) {
                    var replacement = replacements[i];
                    pastedHTML = pastedHTML.replace(replacement[0], replacement[1]);
                }

                canvasBody.innerHTML = '<p>' + pastedHTML.split('<br><br>').join('</p><p>') + '</p>';

                var elList = canvasBody.querySelectorAll('a,p,div,br');
                for (var _i = 0; _i < elList.length; _i++) {
                    var workEl = elList[_i];

                    workEl.innerHTML = workEl.innerHTML.replace(/\n/gi, ' ');
                }

                var pasteBlock = canvasDoc.createDocumentFragment();
                var pasteBlockBody = canvasDoc.createElement('body');
                pasteBlock.appendChild(pasteBlockBody);
                pasteBlockBody.innerHTML = canvasBody.innerHTML;

                this.cleanupSpans(pasteBlockBody);
                this.cleanupDivs(pasteBlockBody);

                elList = pasteBlockBody.querySelectorAll('*');
                for (var _i2 = 0; _i2 < elList.length; _i2++) {
                    var _workEl = elList[_i2];
                    var elAttrs = [];

                    for (var j = 0; j < _workEl.attributes.length; j++) {
                        elAttrs.push(_workEl.attributes[j].name);
                    }

                    for (var k = 0; k < elAttrs.length; k++) {
                        var attrName = elAttrs[k];
                        if (!(_workEl.nodeName === 'A' && attrName === 'href')) {
                            _workEl.removeAttribute(attrName);
                        }
                    }
                }

                canvasBody.innerHTML = pasteBlockBody.innerHTML;
                mediator.exec('format:list:cleanup', canvasBody);
                mediator.exec('format:clean', canvasBody);

                pastedHTML = canvasBody.innerHTML;
                return pastedHTML;
            },
            cleanupSpans: function cleanupSpans(containerEl) {
                var spans = containerEl.querySelectorAll('.replace-with');

                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var replaceBold = span.classList.contains('bold');
                    var replaceItalic = span.classList.contains('italic');
                    var replacement = document.createElement(replaceBold ? 'b' : 'i');

                    if (replaceBold && replaceItalic) {
                        replacement.innerHTML = '<i>' + span.innerHTML + '</i>';
                    } else {
                        replacement.innerHTML = span.innerHTML;
                    }

                    span.parentNode.replaceChild(replacement, span);
                }

                spans = containerEl.querySelectorAll('span');
                for (var _i3 = 0; _i3 < spans.length; _i3++) {
                    var _span = spans[_i3];
                    DOM.unwrap(_span);
                }
            },
            cleanupDivs: function cleanupDivs(containerEl) {
                var divs = containerEl.querySelectorAll('div');
                for (var i = divs.length - 1; i >= 0; i--) {
                    DOM.unwrap(divs[i]);
                }
            }
        }
    });

    // jshint strict: false

    /**
     * FormatterContainer - Initializes and bootstraps all the formatter modules.
     * It requires only a mediator instance to delegate events to.
     *
     * @access protected
     * @module containers/FormatterContainer
     *
     * @requires core/Container
     * @requires modules/BaseFormatter
     * @requires modules/BlockFormatter
     * @requires modules/TextFormatter
     * @requires modules/ListFormatter
     * @requires modules/LinkFormatter
     * @requires modules/Paste
     *
     * @example
     * new FormatterContainer({ mediator: mediatorInstance });
     */
    /**
     * @constructor FormatterContainer
     * @param {object} opts={} - container options
     * @param {mediator} opts.mediator - The mediator to delegate events up to
     * @return {container} CanvasContainer instance
     */
    var FormatterContainer = Container({
        name: 'FormatterContainer',

        /**
         * Child Modules: [{@link modules/BaseFormatter}, {@link modules/BlockFormatter},
         * {@link modules/TextFormatter}, {@link modules/TextFormatter}, {@link modules/LinkFormatter},
         * {@link modules/Paste}]
         * @enum {Array<{class:Module}>} modules
         */
        modules: [{
            class: BaseFormatter
        }, {
            class: BlockFormatter
        }, {
            class: TextFormatter
        }, {
            class: ListFormatter
        }, {
            class: LinkFormatter
        }, {
            class: Paste
        }]
    });

    // jshint strict: false
    /**
     * Selection
     *
     * A module to handle everything that happens with the user's selection and the
     * selection range
     *
     * @access protected
     * @module modules/Selection
     *
     * @example
     * // Available requests / commands:
     *
     * requests: {
     *     'selection:current': 'getCurrentSelection',
     *     'selection:range': 'getCurrentRange',
     *     'selection:anchornode': 'getAnchorNode',
     *     'selection:commonancestor': 'getCommonAncestor',
     *     'selection:closestblock': 'getClosestBlock',
     *     'selection:rootelement': 'getRootElement',
     *     'selection:range:clone': 'getRangeClone',
     *     'selection:bounds': 'getSelectionBounds',
     *     'selection:range:relative:toroot': 'getRangeRelativeToRoot',
     *     'selection:in:or:contains': 'inOrContains',
     *     'selection:range:coordinates': 'rangeCoordinates',
     *     'selection:contains:node': 'containsNode',
     *     'selection:spans:multiple:blocks': 'spansMultipleBlocks'
     * },
     *
     * commands: {
     *     'selection:set:contextWindow': 'setContextWindow',
     *     'selection:set:contextDocument': 'setContextDocument',
     *     'selection:set:el': 'setRootElement',
     *     'selection:expand:toroot': 'expandToRoot',
     *     'selection:update:range': 'updateRange',
     *     'selection:wrap:element': 'wrapElement',
     *     'selection:wrap:content': 'wrapContent',
     *     'selection:wrap:pseudo': 'wrapPseudoSelect',
     *     'selection:select:pseudo': 'selectPseudo',
     *     'selection:select:remove:pseudo': 'removePseudo',
     *     'selection:collapse:tostart': 'collapseToStart',
     *     'selection:reselect': 'reSelect',
     *     'selection:select:contents': 'selectContents',
     *     'selection:collapse:toend': 'collapseToEnd',
     *     'selection:select:all': 'selectAll',
     *     'selection:select:coordinates': 'selectByCoordinates',
     *     'selection:ensure:text:only' : 'ensureTextOnlySelection',
     *     'selection:deselect': 'deSelect'
     * }
     */

    /**
     * Creates a new Selection handler
     * @constructor Selection
     */
    var Selection = Module({
        name: 'Selection',
        props: {
            contextWindow: window,
            contextDocument: document,
            cachedSelection: null,
            cachedRange: null,
            pseudoSelection: null,
            silenceChanges: []
        },
        dom: {
            el: null
        },
        handlers: {
            requests: {
                'selection:current': 'getCurrentSelection',
                'selection:range': 'getCurrentRange',
                'selection:anchornode': 'getAnchorNode',
                'selection:commonancestor': 'getCommonAncestor',
                'selection:closestblock': 'getClosestBlock',
                'selection:rootelement': 'getRootElement',
                'selection:range:clone': 'getRangeClone',
                'selection:bounds': 'getSelectionBounds',
                'selection:range:relative:toroot': 'getRangeRelativeToRoot',
                'selection:in:or:contains': 'inOrContains',
                'selection:range:coordinates': 'rangeCoordinates',
                'selection:contains:node': 'containsNode',
                'selection:spans:multiple:blocks': 'spansMultipleBlocks'
            },

            commands: {
                'selection:set:contextWindow': 'setContextWindow',
                'selection:set:contextDocument': 'setContextDocument',
                'selection:set:el': 'setRootElement',
                'selection:expand:toroot': 'expandToRoot',
                'selection:update:range': 'updateRange',
                'selection:wrap:element': 'wrapElement',
                'selection:wrap:content': 'wrapContent',
                'selection:wrap:pseudo': 'wrapPseudoSelect',
                'selection:select:pseudo': 'selectPseudo',
                'selection:select:remove:pseudo': 'removePseudo',
                'selection:collapse:tostart': 'collapseToStart',
                'selection:reselect': 'reSelect',
                'selection:select:contents': 'selectContents',
                'selection:collapse:toend': 'collapseToEnd',
                'selection:select:all': 'selectAll',
                'selection:select:coordinates': 'selectByCoordinates',
                'selection:ensure:text:only': 'ensureTextOnlySelection',
                'selection:deselect': 'deSelect'
            }
        },
        methods: {
            init: function init() {
                this.bindDocumentEvents();
            },
            bindDocumentEvents: function bindDocumentEvents() {
                var contextDocument = this.props.contextDocument;

                contextDocument.addEventListener('selectstart', this.handleSelectStart);
                contextDocument.addEventListener('selectionchange', this.handleSelectionChange);
            },
            unbindDocumentEvents: function unbindDocumentEvents() {
                var contextDocument = this.props.contextDocument;

                contextDocument.removeEventListener('selectstart', this.handleSelectStart);
                contextDocument.removeEventListener('selectionchange', this.handleSelectionChange);
            },
            setContextWindow: function setContextWindow(contextWindow) {
                var props = this.props;

                props.contextWindow = contextWindow;
            },
            setContextDocument: function setContextDocument(contextDocument) {
                var props = this.props;

                this.unbindDocumentEvents();
                props.contextDocument = contextDocument;
                this.bindDocumentEvents();
            },
            setRootElement: function setRootElement(elem) {
                var dom = this.dom;

                dom.el = [elem];
            },
            handleSelectStart: function handleSelectStart(evnt) {
                var mediator = this.mediator;
                var el = this.dom.el;

                var anchorNode = this.getAnchorNode();

                if (DOM.isChildOf(anchorNode, el)) {
                    mediator.emit('selection:start', evnt);
                }
            },
            handleSelectionChange: function handleSelectionChange(evnt) {
                var mediator = this.mediator,
                    props = this.props;
                var el = this.dom.el;

                var anchorNode = this.getAnchorNode();

                if (DOM.isChildOf(anchorNode, el)) {
                    this.cacheRange();
                    if (!props.silenceChanges.length) {
                        mediator.emit('selection:change', evnt);
                    } else {
                        props.silenceChanges.pop();
                    }
                }
            },
            cacheRange: function cacheRange() {
                var currentRange = this.getCurrentRange();
                this.props.cachedRange = currentRange.cloneRange();
            },
            getCurrentSelection: function getCurrentSelection() {
                var contextWindow = this.props.contextWindow;

                return contextWindow.getSelection();
            },
            validateSelection: function validateSelection(selection) {
                var dom = this.dom;

                return selection.anchorNode && DOM.isChildOf(selection.anchorNode, dom.el);
            },
            getCurrentRange: function getCurrentRange() {
                var props = this.props;

                var currentSelection = this.getCurrentSelection();
                var currentRange = void 0;

                if (this.validateSelection(currentSelection)) {
                    currentRange = currentSelection.getRangeAt(0);
                } else if (props.cachedRange) {
                    currentRange = props.cachedRange;
                } else {
                    currentRange = document.createRange();
                }

                return currentRange;
            },
            getAnchorNode: function getAnchorNode() {
                var currentSelection = this.getCurrentSelection();
                return currentSelection.anchorNode;
            },
            getCommonAncestor: function getCommonAncestor() {
                var currentSelection = this.getCurrentSelection();
                if (currentSelection.rangeCount > 0) {
                    var selectionRange = currentSelection.getRangeAt(0);
                    return selectionRange.commonAncestorContainer;
                }
            },
            getClosestBlock: function getClosestBlock() {
                var commonAncestor = this.getCommonAncestor();
                var closestBlockEl = null;
                var currentNode = commonAncestor;

                while (!closestBlockEl && !this.isContentEditable(currentNode) && currentNode) {
                    if (currentNode.nodeType === Node.ELEMENT_NODE) {
                        var nodeTagName = currentNode.tagName.toLowerCase();
                        if (config.blockElementNames.indexOf(nodeTagName) > -1) {
                            closestBlockEl = currentNode;
                        } else {
                            currentNode = currentNode.parentNode;
                        }
                    } else {
                        currentNode = currentNode.parentNode;
                    }
                }

                return closestBlockEl;
            },
            getRootElement: function getRootElement() {
                var dom = this.dom;

                return dom.el[0];
            },
            getRangeClone: function getRangeClone() {
                var currentRange = this.getCurrentRange();
                return currentRange.cloneRange();
            },
            getRangeRelativeToRoot: function getRangeRelativeToRoot() {
                var _getCurrentRange = this.getCurrentRange(),
                    startContainer = _getCurrentRange.startContainer,
                    startOffset = _getCurrentRange.startOffset,
                    endContainer = _getCurrentRange.endContainer,
                    endOffset = _getCurrentRange.endOffset;

                var startCoordinates = [];
                var endCoordinates = [];
                var startRootChildIndex = 0;

                startCoordinates.unshift(startOffset);
                endCoordinates.unshift(endOffset);

                while (!this.isContentEditable(startContainer)) {
                    if (this.isContentEditable(startContainer.parentNode)) {
                        startRootChildIndex = DOM.childIndex(startContainer);
                        startCoordinates.unshift(0);
                    } else {
                        startCoordinates.unshift(DOM.childIndex(startContainer));
                    }
                    startContainer = startContainer.parentNode;
                }

                while (!this.isContentEditable(endContainer)) {
                    if (this.isContentEditable(endContainer.parentNode)) {
                        endCoordinates.unshift(DOM.childIndex(endContainer) - startRootChildIndex);
                    } else {
                        endCoordinates.unshift(DOM.childIndex(endContainer));
                    }
                    endContainer = endContainer.parentNode;
                }

                return {
                    startCoordinates: startCoordinates,
                    endCoordinates: endCoordinates
                };
            },
            rangeCoordinates: function rangeCoordinates() {
                this.ensureTextOnlySelection();

                var _getCurrentRange2 = this.getCurrentRange(),
                    startContainer = _getCurrentRange2.startContainer,
                    startOffset = _getCurrentRange2.startOffset,
                    endContainer = _getCurrentRange2.endContainer,
                    endOffset = _getCurrentRange2.endOffset;

                var startCoordinates = [];
                var endCoordinates = [];

                startCoordinates.unshift(startOffset);
                endCoordinates.unshift(endOffset);

                while (!this.isContentEditable(startContainer)) {
                    startCoordinates.unshift(DOM.childIndex(startContainer));
                    startContainer = startContainer.parentNode;
                }

                while (!this.isContentEditable(endContainer)) {
                    endCoordinates.unshift(DOM.childIndex(endContainer));
                    endContainer = endContainer.parentNode;
                }

                return {
                    startCoordinates: startCoordinates,
                    endCoordinates: endCoordinates
                };
            },
            inOrContains: function inOrContains(selectors) {
                var dom = this.dom;

                var rootEl = dom.el[0];
                var anchorNode = this.getAnchorNode();

                if (!rootEl.contains(anchorNode)) {
                    return false;
                }

                var isIn = DOM.isIn(anchorNode, selectors, rootEl);

                if (isIn) {
                    return isIn;
                }

                var currentRange = this.getCurrentRange();
                var rangeFrag = currentRange.cloneContents();
                var contains = false;

                if (rangeFrag.childNodes.length) {
                    selectors.forEach(function (selector) {
                        contains = contains || rangeFrag.childNodes[0].nodeName === selector;
                    });
                }

                return contains;
            },
            containsNode: function containsNode(node) {
                var currentSelection = this.getCurrentSelection();
                var anchorNode = currentSelection.anchorNode,
                    focusNode = currentSelection.focusNode;

                var selectionContainsNode = currentSelection.containsNode(node, true);

                if (!currentSelection.rangeCount) {
                    return false;
                }

                if (selectionContainsNode) {
                    return true;
                }

                if (anchorNode.nodeType !== Node.ELEMENT_NODE) {
                    anchorNode = anchorNode.parentNode;
                }
                if (focusNode.nodeType !== Node.ELEMENT_NODE) {
                    focusNode = focusNode.parentNode;
                }

                return anchorNode === node || focusNode === node;
            },
            expandToRoot: function expandToRoot() {
                var _this = this;

                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                var currentRange = opts.range || this.getCurrentRange();
                var startRootNode = currentRange.startContainer;
                var endRootNode = currentRange.endContainer;
                var newRange = document.createRange();
                var startEqualsEnd = startRootNode === endRootNode;

                if (this.isContentEditable(startRootNode)) {
                    return;
                }

                var getRootEl = function getRootEl(node) {
                    var currentNode = node;
                    if (!_this.isContentEditable(currentNode)) {
                        while (currentNode.parentNode && !_this.isContentEditable(currentNode.parentNode)) {
                            currentNode = currentNode.parentNode;
                        }
                    }
                    return currentNode;
                };

                startRootNode = getRootEl(startRootNode);
                endRootNode = startEqualsEnd ? startRootNode : getRootEl(endRootNode);

                if (opts.innerBounds) {
                    newRange.setStartAfter(startRootNode);
                    newRange.setEndBefore(endRootNode);
                } else {
                    newRange.setStart(startRootNode, 0);
                    newRange.setEndAfter(endRootNode);
                }

                this.updateRange(newRange, { silent: true });
            },
            wrapElement: function wrapElement(elem) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                var currentRange = this.getCurrentRange();

                if (elem instanceof Array) {
                    currentRange.setStartBefore(elem[0]);
                    currentRange.setEndAfter(elem[elem.length - 1]);
                } else if (elem.nodeType === Node.ELEMENT_NODE) {
                    currentRange.setStartBefore(elem);
                    currentRange.setEndAfter(elem);
                }

                this.updateRange(currentRange, opts);
            },
            wrapContent: function wrapContent() {
                var currentRange = this.getCurrentRange();
                var selectionRootEl = this.getRootElement();
                currentRange.selectNodeContents(selectionRootEl);
                this.updateRange(currentRange);
            },
            wrapPseudoSelect: function wrapPseudoSelect() {
                var props = this.props;

                var currentRange = this.getCurrentRange();

                var pseudoSelection = document.createElement('span');
                pseudoSelection.classList.add('typester-pseudo-selection');
                pseudoSelection.appendChild(currentRange.extractContents());
                currentRange.insertNode(pseudoSelection);

                props.pseudoSelection = pseudoSelection;
                this.wrapElement(pseudoSelection);
            },
            selectPseudo: function selectPseudo() {
                var dom = this.dom;

                var unwrappedNodes = this.removePseudo();

                if (unwrappedNodes.length) {
                    dom.el[0].focus();
                    this.wrapElement(unwrappedNodes, { silent: true });
                }
            },
            removePseudo: function removePseudo() {
                var props = this.props;

                var unwrappedNodes = [];

                if (props.pseudoSelection && props.pseudoSelection.tagName) {
                    unwrappedNodes = DOM.unwrap(props.pseudoSelection);
                    props.pseudoSelection = null;
                }

                return unwrappedNodes;
            },
            selectContents: function selectContents(node) {
                var newRange = document.createRange();

                if (node.childNodes.length) {
                    newRange.selectNodeContents(node);
                } else {
                    newRange.setStart(node, 0);
                    newRange.collapse(true);
                }

                this.updateRange(newRange);
            },
            updateRange: function updateRange(range) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var mediator = this.mediator,
                    props = this.props;

                var currentSelection = this.getCurrentSelection();

                if (opts.silent) {
                    props.silenceChanges.push(true); // silence removeAllRanges
                    props.silenceChanges.push(true); // silence addRange
                }

                currentSelection.removeAllRanges();
                currentSelection.addRange(range);

                if (!opts.silent) {
                    mediator.emit('selection:update');
                }
            },
            deSelect: function deSelect() {
                var currentSelection = this.getCurrentSelection();
                currentSelection.removeAllRanges();
            },
            isContentEditable: function isContentEditable(node) {
                return node && node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('contenteditable');
            },
            getSelectionBounds: function getSelectionBounds() {
                var currentRange = this.getCurrentRange();
                var rangeRects = currentRange ? currentRange.getClientRects() : [];
                var rangeBoundingClientRect = currentRange ? currentRange.getBoundingClientRect() : null;

                var selectionBounds = {
                    top: null,
                    right: null,
                    bottom: null,
                    left: null,
                    height: null,
                    width: null,
                    initialWidth: null,
                    initialLeft: null
                };

                var setSelectionBoundary = function setSelectionBoundary(rangeRect) {
                    ['top', 'left', 'bottom', 'right', 'height', 'width'].forEach(function (rectKey) {
                        if (!selectionBounds[rectKey]) {
                            selectionBounds[rectKey] = rangeRect[rectKey];
                        } else {
                            switch (rectKey) {
                                case 'top':
                                case 'left':
                                    selectionBounds[rectKey] = Math.min(selectionBounds[rectKey], rangeRect[rectKey]);
                                    break;
                                case 'bottom':
                                case 'right':
                                case 'height':
                                case 'width':
                                    selectionBounds[rectKey] = Math.max(selectionBounds[rectKey], rangeRect[rectKey]);
                                    break;
                            }
                        }
                    });
                };

                var setInitialBoundary = function setInitialBoundary(rangeRect) {
                    if (rangeBoundingClientRect) {
                        selectionBounds.initialLeft = rangeBoundingClientRect.left;
                        selectionBounds.initialWidth = rangeBoundingClientRect.width;
                    } else if (rangeRect.top === selectionBounds.top) {
                        if (selectionBounds.initialLeft === null) {
                            selectionBounds.initialLeft = rangeRect.left;
                        } else {
                            selectionBounds.initialLeft = Math.min(rangeRect.left, selectionBounds.initialLeft);
                        }

                        if (selectionBounds.initialWidth === null) {
                            selectionBounds.initialWidth = rangeRect.width;
                        } else {
                            selectionBounds.initialWidth = Math.max(rangeRect.right - selectionBounds.initialLeft, selectionBounds.initialWidth);
                        }
                    }
                };

                for (var i = 0; i < rangeRects.length; i++) {
                    setSelectionBoundary(rangeRects[i], i);
                }

                for (var _i = 0; _i < rangeRects.length; _i++) {
                    setInitialBoundary(rangeRects[_i], _i);
                }

                return selectionBounds;
            },
            collapseToStart: function collapseToStart() {
                var currentRange = this.getCurrentRange();
                var newRange = document.createRange();

                newRange.setStart(currentRange.startContainer, currentRange.startOffset);
                newRange.setEnd(currentRange.startContainer, currentRange.startOffset);

                this.updateRange(newRange);
            },
            collapseToEnd: function collapseToEnd() {
                var currentSelection = this.getCurrentSelection();
                currentSelection.collapseToEnd();
            },
            reSelect: function reSelect() {
                var props = this.props;

                if (props.cachedRange) {
                    this.updateRange(props.cachedRange, { silent: true });
                }
            },
            selectAll: function selectAll() {
                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var dom = this.dom,
                    props = this.props;
                var contextDocument = props.contextDocument;

                var range = contextDocument.createRange();
                var rootElem = dom.el[0];

                if (opts.selector) {
                    var elems = contextDocument.querySelectorAll(opts.selector);
                    range.setStartBefore(elems[0]);
                    range.setEndAfter(elems[elems.lenght - 1]);
                } else {
                    range.setStart(rootElem, 0);
                    range.setEndAfter(rootElem.lastChild);
                }

                this.updateRange(range);
            },
            selectByCoordinates: function selectByCoordinates(rangeCoordinates) {
                var dom = this.dom,
                    props = this.props;
                var contextDocument = props.contextDocument;

                var newRange = contextDocument.createRange();
                var startCoordinates = rangeCoordinates.startCoordinates.slice(0);
                var endCoordinates = rangeCoordinates.endCoordinates.slice(0);
                var startOffset = startCoordinates.pop();
                var endOffset = endCoordinates.pop();

                var startContainer = dom.el[0];
                var endContainer = dom.el[0];

                while (startCoordinates.length) {
                    var startIndex = startCoordinates.shift();
                    startContainer = startContainer.childNodes[startIndex];
                }

                while (endCoordinates.length) {
                    var endIndex = endCoordinates.shift();
                    endContainer = endContainer.childNodes[endIndex];
                }

                newRange.setStart(startContainer, startOffset);
                newRange.setEnd(endContainer, endOffset);

                this.updateRange(newRange);
            },
            ensureTextOnlySelection: function ensureTextOnlySelection() {
                var contextDocument = this.props.contextDocument;

                var currentRange = this.getCurrentRange();
                var currentSelection = this.getCurrentSelection();
                var startContainer = currentRange.startContainer,
                    endContainer = currentRange.endContainer,
                    commonAncestorContainer = currentRange.commonAncestorContainer;


                if (currentSelection.isCollapsed || startContainer.nodeType === Node.TEXT_NODE && endContainer.nodeType === Node.TEXT_NODE) {
                    return;
                }

                var rangeString = currentRange.toString();

                var newRange = contextDocument.createRange();

                var walker = contextDocument.createTreeWalker(commonAncestorContainer, NodeFilter.SHOW_TEXT, null, false);

                var textNodes = [];
                while (walker.nextNode()) {
                    textNodes.push(walker.currentNode);
                }

                var firstTextNode = textNodes[0];
                var lastTextNode = textNodes[textNodes.length - 1];

                newRange.setStart(firstTextNode, 0);
                newRange.setEnd(lastTextNode, lastTextNode.textContent.length);

                var currentNodeIndex = 0;
                var newStartOffset = 0;
                var currentTextNode = textNodes[currentNodeIndex];

                while (newRange.compareBoundaryPoints(Range.START_TO_START, currentRange) < 0) {
                    newStartOffset += 1;

                    if (newStartOffset > currentTextNode.textContent.length) {
                        currentNodeIndex += 1;
                        newStartOffset = 0;

                        if (currentNodeIndex >= textNodes.length) {
                            break;
                        }
                        currentTextNode = textNodes[currentNodeIndex];
                    }

                    newRange.setStart(currentTextNode, newStartOffset);
                }

                var newEndOffset = newStartOffset;
                newRange.setEnd(currentTextNode, newEndOffset);

                while (newRange.compareBoundaryPoints(Range.END_TO_END, currentRange) < 0) {
                    newEndOffset += 1;
                    if (newEndOffset > currentTextNode.textContent.length) {
                        currentNodeIndex += 1;
                        newEndOffset = 0;

                        if (currentNodeIndex >= textNodes.length) {
                            break;
                        }
                        currentTextNode = textNodes[currentNodeIndex];
                    }

                    newRange.setEnd(currentTextNode, newEndOffset);
                }

                if (newRange.toString() === rangeString) {
                    this.updateRange(newRange, { silent: true });
                }
            }
        },

        spansMultipleBlocks: function spansMultipleBlocks() {
            var _getCurrentSelection = this.getCurrentSelection(),
                anchorNode = _getCurrentSelection.anchorNode,
                focusNode = _getCurrentSelection.focusNode;

            var rootElem = this.getRootElement();
            var blockTagNames = Toolbar$2.getBlockTags();

            var anchorBlock = DOM.getClosestInArray(anchorNode, blockTagNames, rootElem);
            var focusBlock = DOM.getClosestInArray(focusNode, blockTagNames, rootElem);

            return anchorBlock !== focusBlock;
        }
    });

    var canvasStyles = ".typester-canvas {\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 0;\n  width: 0;\n  opacity: 0; }\n";

    // jshint strict: false

    /**
     * Canvas -
     * Provides a canvas and inteface methods to allow for manipulation of the content
     * in a sandbox to avoid contaminating the current editor and the undo/redo history
     *
     * @access protected
     * @module modules/Canvas
     *
     * @example
     * // Available requests and commands
     * requests: {
     *     'canvas:document' : 'getCanvasDocument',
     *     'canvas:window' : 'getCanvasWindow',
     *     'canvas:body' : 'getCanvasBody',
     *     'canvas:formatted:block': 'getFormattedBlock',
     *     'canvas:selection:coordinates' : 'getSelectionCoordinates',
     *     'canvas:selection': 'getSelection',
     *     'canvas:selection:in:or:contains': 'selectionInOrContains'
     * },
     * commands: {
     *     'canvas:content' : 'setContent',
     *     'canvas:insert:range' : 'insertRange',
     *     'canvas:insert:node' : 'insertNode',
     *     'canvas:select:all' : 'selectAll',
     *     'canvas:select:by:coordinates' : 'selectByCoordinates',
     *     'canvas:import:selection' : 'importSelection',
     *     'canvas:export:prep': 'exportPrep',
     *     'canvas:export:all': 'exportAll',
     *     'canvas:cache:selection': 'cacheSelection',
     *     'canvas:select:cachedSelection': 'selectCachedSelection',
     *     'canvas:select:ensure:offsets': 'ensureSelectionOffsets'
     * },
     */
    /**
    * @access protected
    */
    var Canvas = Module({
        name: 'Canvas',
        props: {
            iframe: null,
            relativeRange: null,
            alreadyContainered: false,
            cachedSelection: null
        },
        handlers: {
            requests: {
                'canvas:document': 'getCanvasDocument',
                'canvas:window': 'getCanvasWindow',
                'canvas:body': 'getCanvasBody',
                'canvas:formatted:block': 'getFormattedBlock',
                'canvas:selection:coordinates': 'getSelectionCoordinates',
                'canvas:selection': 'getSelection',
                'canvas:selection:in:or:contains': 'selectionInOrContains'
            },
            commands: {
                'canvas:content': 'setContent',
                'canvas:insert:range': 'insertRange',
                'canvas:insert:node': 'insertNode',
                'canvas:select:all': 'selectAll',
                'canvas:select:by:coordinates': 'selectByCoordinates',
                'canvas:import:selection': 'importSelection',
                'canvas:export:prep': 'exportPrep',
                'canvas:export:all': 'exportAll',
                'canvas:cache:selection': 'cacheSelection',
                'canvas:select:cachedSelection': 'selectCachedSelection',
                'canvas:select:ensure:offsets': 'ensureSelectionOffsets'
            },
            events: {
                'app:destroy': 'destroy'
            }
        },
        methods: {
            init: function init() {
                this.appendStyles();
                this.createIframe();
            },
            appendStyles: function appendStyles() {
                var props = this.props;

                props.styles = DOM.addStyles(canvasStyles);
            },
            createIframe: function createIframe() {
                var _this = this;

                var mediator = this.mediator;

                var iframe = document.createElement('iframe');

                iframe.classList.add('typester-canvas');
                iframe.onload = function () {
                    _this.setCanvasBodyEditable();
                    _this.applyPolyfills();
                    mediator.emit('canvas:created');
                };

                this.props.iframe = iframe;
                document.body.appendChild(iframe);
            },
            clearIframe: function clearIframe() {
                var canvasBody = this.getCanvasBody();
                canvasBody.innerHTML = '';
            },
            reset: function reset() {
                var props = this.props;

                props.relativeRange = null;
                props.alreadyContainered = false;
                props.cachedSelection = null;
                this.clearIframe();
            },
            cacheSelection: function cacheSelection() {
                var props = this.props,
                    mediator = this.mediator;


                mediator.exec('selection:ensure:text:only');

                var _mediator$get = mediator.get('selection:current'),
                    anchorNode = _mediator$get.anchorNode,
                    anchorOffset = _mediator$get.anchorOffset,
                    focusNode = _mediator$get.focusNode,
                    focusOffset = _mediator$get.focusOffset;

                props.cachedSelection = {
                    anchorNode: anchorNode,
                    anchorOffset: anchorOffset,
                    focusNode: focusNode,
                    focusOffset: focusOffset
                };
            },
            selectCachedSelection: function selectCachedSelection() {
                var props = this.props,
                    mediator = this.mediator;
                var _props$cachedSelectio = props.cachedSelection,
                    anchorNode = _props$cachedSelectio.anchorNode,
                    anchorOffset = _props$cachedSelectio.anchorOffset,
                    focusNode = _props$cachedSelectio.focusNode,
                    focusOffset = _props$cachedSelectio.focusOffset;


                var canvasDoc = this.getCanvasDocument();
                var newRange = canvasDoc.createRange();

                newRange.setStart(anchorNode, anchorOffset);
                newRange.setEnd(focusNode, focusOffset);

                mediator.exec('selection:update:range', newRange);
            },
            ensureSelectionOffsets: function ensureSelectionOffsets() {
                var props = this.props,
                    mediator = this.mediator;


                if (!props.cachedSelection) {
                    return;
                }

                var _mediator$get2 = mediator.get('selection:current'),
                    currentAnchorNode = _mediator$get2.anchorNode,
                    currentAnchorOffset = _mediator$get2.anchorOffset,
                    currentFocusNode = _mediator$get2.focusNode,
                    currentFocusOffset = _mediator$get2.focusOffset;

                var _props$cachedSelectio2 = props.cachedSelection,
                    cachedAnchorOffset = _props$cachedSelectio2.anchorOffset,
                    cachedFocusOffset = _props$cachedSelectio2.focusOffset;


                var anchorOffsetMismatch = currentAnchorOffset !== cachedAnchorOffset;
                var focusOffsetMismatch = currentFocusOffset !== cachedFocusOffset;

                if (anchorOffsetMismatch || focusOffsetMismatch) {
                    var canvasDoc = this.getCanvasDocument();
                    var newRange = canvasDoc.createRange();

                    newRange.setStart(currentAnchorNode, cachedAnchorOffset);
                    newRange.setEnd(currentFocusNode, cachedFocusOffset);

                    mediator.exec('selection:update:range', newRange);
                }
            },
            setCanvasBodyEditable: function setCanvasBodyEditable() {
                var props = this.props;

                var canvasBody = props.iframe.contentDocument.body;
                canvasBody.contentEditable = true;
            },
            applyPolyfills: function applyPolyfills() {
                var canvasWindow = this.getCanvasWindow();
                if (canvasWindow.NodeList && !canvasWindow.NodeList.prototype.forEach) {
                    canvasWindow.NodeList.prototype.forEach = function (callback, thisArg) {
                        thisArg = thisArg || canvasWindow;
                        for (var i = 0; i < this.length; i++) {
                            callback.call(thisArg, this[i], i, this);
                        }
                    };
                }
            },


            // Handlers
            getCanvasDocument: function getCanvasDocument() {
                var props = this.props;

                return props.iframe.contentDocument;
            },
            getCanvasWindow: function getCanvasWindow() {
                var props = this.props;

                return props.iframe.contentWindow;
            },
            getCanvasBody: function getCanvasBody() {
                var props = this.props;

                return props.iframe.contentDocument.body;
            },
            setContent: function setContent(html) {
                var canvasDoc = this.getCanvasDocument();

                if (html instanceof Array) {
                    this.reset();
                    html.forEach(function (node) {
                        canvasDoc.body.appendChild(node);
                    });
                } else {
                    canvasDoc.body.innerHTML = html;
                }
            },
            insertRange: function insertRange(range) {
                var rangeDocFrag = range.cloneContents();
                var canvasBody = this.getCanvasBody();

                this.reset();

                for (var i = 0; i < rangeDocFrag.childNodes.length; i++) {
                    var childNode = rangeDocFrag.childNodes[i];
                    if (childNode.nodeType === Node.TEXT_NODE && (!/\w+/.test(childNode.textContent) || zeroWidthSpace.assert(childNode))) {
                        rangeDocFrag.removeChild(childNode);
                    }
                }

                canvasBody.appendChild(rangeDocFrag);
            },
            insertNode: function insertNode(node) {
                var nodeClone = node.cloneNode(true);
                var canvasBody = this.getCanvasBody();
                this.reset();
                canvasBody.appendChild(nodeClone);
            },
            selectAll: function selectAll() {
                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var mediator = this.mediator;

                mediator.exec('selection:select:all', opts);
            },
            selectByCoordinates: function selectByCoordinates(rangeCoordinates) {
                var mediator = this.mediator;

                var canvasBody = this.getCanvasBody();

                mediator.exec('selection:set:el', canvasBody);
                mediator.exec('selection:select:coordinates', rangeCoordinates);
            },
            importSelection: function importSelection() {
                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var mediator = this.mediator;

                var rangeCoordinates = void 0;

                if (opts.toRoot) {
                    rangeCoordinates = mediator.get('selection:range:relative:toroot');
                    mediator.exec('selection:expand:toroot');
                }

                var selectionRange = mediator.get('selection:range');

                this.insertRange(selectionRange);
                if (opts.toRoot) {
                    this.selectByCoordinates(rangeCoordinates);
                } else {
                    this.selectAll();
                }
                this.setCanvasBodyEditable();
            },
            exportPrep: function exportPrep() {
                this.cleanHtml();
            },
            exportAll: function exportAll() {
                var mediator = this.mediator;

                var canvasBody = this.getCanvasBody();
                // this.exportPrep();

                var innerHTML = canvasBody.innerHTML;
                innerHTML = innerHTML.replace(/\s{2,}/g, ' ');
                innerHTML = innerHTML.replace(/\r?\n|\r/g, '');

                mediator.exec('contenteditable:inserthtml', innerHTML);
            },
            getFormattedBlock: function getFormattedBlock() {
                var mediator = this.mediator;

                mediator.exec('selection:expand:toroot');
                var blockRange = mediator.get('selection:range');
                return blockRange.cloneContents();
            },
            cleanHtml: function cleanHtml() {
                var canvasDoc = this.getCanvasDocument();
                var canvasBody = this.getCanvasBody();
                var walker = canvasDoc.createTreeWalker(canvasBody, NodeFilter.SHOW_ALL, null, false);

                var allNodes = [];

                while (walker.nextNode()) {
                    allNodes.push(walker.currentNode);
                }

                for (var i = allNodes.length - 1; i >= 0; i--) {
                    var node = allNodes[i];

                    if (!node.textContent || !node.textContent.trim().length || zeroWidthSpace.assert(node)) {
                        DOM.removeNode(node);
                    } else if (node.classList && node.classList.contains('typester-replace-default')) {
                        var defaultNode = document.createElement('p');
                        DOM.insertAfter(defaultNode, node);
                        defaultNode.appendChild(node);
                        DOM.unwrap(node);
                    } if (node.classList && node.classList.contains('typester-container') || node.nodeName === 'SPAN' && node.hasAttribute('style') || node.nodeName === 'FONT' || node.nodeName === 'DIV') {
                        DOM.unwrap(node);
                    }
                }
            },
            getSelection: function getSelection() {
                var mediator = this.mediator;

                return mediator.get('selection:current');
            },
            getSelectionCoordinates: function getSelectionCoordinates() {
                var mediator = this.mediator;

                return mediator.get('selection:range:coordinates');
            },
            selectionInOrContains: function selectionInOrContains(selectors) {
                var mediator = this.mediator;

                return mediator.get('selection:in:or:contains', selectors);
            },
            destroy: function destroy() {
                var props = this.props;
                var iframe = props.iframe;

                iframe.parentNode.removeChild(iframe);
            }
        }
    });

    // jshint strict: false


    /**
     * CanvasContainer - This container bootstraps the Selection and Canvas modules.
     * It requires only a mediator instance to delegate events to.
     *
     * @access protected
     * @module containers/CanvasContainer
     *
     * @requires core/Container
     * @requires modules/Selection
     * @requires modules/Canvas
     *
     * @example
     * new CanvasContainer({
     *   mediator: mediatorInstance
     * });
     */

    /**
     * @constructor CanvasContainer
     * @param {object} opts={} - instance options
     * @param {object} opts.mediator - The mediator to delegate events up to
     * @return {container} CanvasContainer instance
     */
    var CanvasContainer = Container({
        name: 'CanvasContainer',

        /**
         * Child Modules: [{@link modules/Selection}, {@link modules/Canvas}]
         * @enum {Array<{class:Module}>} modules
         */
        modules: [{ class: Selection }, { class: Canvas }],

        /**
         * @prop {object} mediatorOpts - Container specific mediator options. For the
         * CanvasContainer the mediator is set to conceal, and not propagate, any messages
         * from the selection module. This is to avoid cross contamination with the selection
         * module used on the page.
         */
        mediatorOpts: {
            conceal: [/selection:.*?/]
        },

        /**
         * @prop {object} handlers
         * @prop {object} handlers.events - canvas:created -> handleCanvasCreated
         */
        handlers: {
            events: {
                'canvas:created': 'handleCanvasCreated'
            }
        },
        methods: {
            init: function init() { },


            /**
             * @func handleCanvasCreated
             * @desc Listens for the canvas:create event to do some bootstrapping between
             * the canvas and selection module instances
             * @listens canvas:created
             */
            handleCanvasCreated: function handleCanvasCreated() {
                var mediator = this.mediator;

                var canvasWin = mediator.get('canvas:window');
                var canvasDoc = mediator.get('canvas:document');
                var canvasBody = mediator.get('canvas:body');

                mediator.exec('selection:set:contextWindow', canvasWin);
                mediator.exec('selection:set:contextDocument', canvasDoc);
                mediator.exec('selection:set:el', canvasBody);
            }
        }
    });

    /**
     * keycodes -
     * utility map to make keycode matching more human readable.
     * @access protected
     */
    var keycodes = {
        ENTER: 13,
        BACKSPACE: 8,
        TAB: 9
    };

    var contentEditableStyles = ".typester-content-editable[data-placeholder]:before {\n  content: attr(data-placeholder);\n  display: none;\n  color: #a0a0a0;\n  position: absolute; }\n\n.typester-content-editable[data-placeholder].show-placeholder:before {\n  display: block; }\n";

    // jshint strict: false

    /**
     * ContentEditable
     *
     * A module to handle everything that happens in the primary contenteditable=true dom element
     *
     * @access protected
     * @module modules/ContentEditable
     */

    /**
    * @event contenteditable:focus
    * @desc Emitted by {@link modules/ContentEditable} when focused.
    */

    /**
     * @requires core/Module
     * @requires utils/DOM
     * @requires utils/keycodes
     */
    /**
     * @constructor ContentEditable
     *
     * @param  {object} opts - instance options
     * @param  {object} opts.dom - The dom components used by this module
     * @param  {element} opts.dom.el - The root dom element for this module
     * @param  {mediator} opts.mediator - The mediator this module can use to communicate with
     *
     * @return {container} AppContainer instance
     */
    var ContentEditable = Module({
        name: 'ContentEditable',
        props: {
            styles: null,
            cleanupTimeout: null
        },
        dom: {},
        handlers: {
            requests: {
                'contenteditable:element': 'getContentEditableElement',
                'contenteditable:toolbar:buttons': 'getToolbarButtons'
            },
            commands: {
                'contenteditable:inserthtml': 'insertHTML',
                'contenteditable:refocus': 'reFocus',
                'contenteditable:cleanup': 'cleanup'
            },
            domEvents: {
                'focus': 'handleFocus',
                'keydown': 'handleKeydown',
                'keyup': 'handleKeyup',
                'blur': 'handleBlur',
                'paste': 'handlePaste',
                'mouseover': 'handleMouseOver',
                'mouseout': 'handleMouseOut',
                'click': 'handleClick',
                'input': 'handleInput'
            }
        },
        methods: {
            setup: function setup() {
                this.appendStyles();
            },
            init: function init() {
                this.ensureClass();
                this.ensureEditable();
                this.updatePlaceholderState();
                this.updateValue();
            },
            appendStyles: function appendStyles() {
                var props = this.props;

                props.styles = DOM.addStyles(contentEditableStyles);
            },
            ensureClass: function ensureClass() {
                var dom = this.dom;

                dom.el[0].classList.add('typester-content-editable');
            },
            updatePlaceholderState: function updatePlaceholderState() {
                var dom = this.dom;

                var rootEl = dom.el[0];

                if (rootEl.hasAttribute('data-placeholder')) {
                    if (rootEl.childNodes.length && rootEl.textContent.trim().length) {
                        rootEl.classList.remove('show-placeholder');
                    } else {
                        rootEl.classList.add('show-placeholder');
                    }
                }
            },
            updateValue: function updateValue() {
                var dom = this.dom;

                var rootEl = dom.el[0];

                if (rootEl.innerText.trim().length) {
                    rootEl.value = rootEl.innerHTML;
                } else {
                    rootEl.value = '';
                }
            },
            ensureEditable: function ensureEditable() {
                var dom = this.dom;

                var rootEl = dom.el[0];

                if (!rootEl.hasAttribute('contenteditable')) {
                    rootEl.contentEditable = true;
                }
            },
            ensureDefaultBlock: function ensureDefaultBlock() {
                var dom = this.dom,
                    mediator = this.mediator;

                var rootEl = dom.el[0];

                if (!/\w+/.test(rootEl.textContent)) {
                    rootEl.innerHTML = '<p>&nbsp;</p>';
                    mediator.exec('selection:select:contents', rootEl.childNodes[0]);
                }
            },
            getToolbarButtons: function getToolbarButtons() {
                var dom = this.dom;
                var toolbarButtons = dom.el[0].dataset.toolbarButtons;

                var buttonArray = [];

                if (toolbarButtons) {
                    buttonArray = JSON.parse(toolbarButtons);
                }

                return buttonArray;
            },
            insertHTML: function insertHTML(html) {
                var mediator = this.mediator;


                if (document.queryCommandSupported('insertHTML')) {
                    document.execCommand('insertHTML', null, html);
                } else {
                    var currentSelection = mediator.get('selection:current');
                    var currentRange = mediator.get('selection:range');

                    currentRange.deleteContents();

                    var tmpContainer = document.createElement('container');
                    tmpContainer.innerHTML = html;

                    var docFrag = document.createDocumentFragment();
                    var node = void 0,
                        lastNode = void 0;

                    while (node = tmpContainer.firstChild) {
                        lastNode = docFrag.appendChild(node);
                    }
                    currentRange.insertNode(docFrag);

                    if (lastNode) {
                        currentRange = currentRange.cloneRange();
                        currentRange.setStartAfter(lastNode);
                        currentRange.collapse(true);
                        currentSelection.removeAllRanges();
                        currentSelection.addRange(currentRange);
                    }
                }
            },
            reFocus: function reFocus() {
                var dom = this.dom;

                dom.el[0].focus();
            },
            getContentEditableElement: function getContentEditableElement() {
                var dom = this.dom;

                return dom.el[0];
            },
            cleanup: function cleanup() {
                var dom = this.dom,
                    mediator = this.mediator;

                var rootEl = dom.el[0];
                mediator.exec('format:clean', rootEl);
            },
            setCleanupTimeout: function setCleanupTimeout() {
                var _this = this;

                var props = this.props;

                props.cleanupTimeout = setTimeout(function () {
                    _this.cleanup();
                }, 250);
            },
            clearCleanupTimeout: function clearCleanupTimeout() {
                var props = this.props;

                if (props.cleanupTimeout) {
                    clearTimeout(props.cleanupTimeout);
                    props.cleanupTimeout = null;
                }
            },


            // DOM Event Handlers

            /**
             * On dom focus do some stuff and then let the rest of the app know.
             *
             * @method handleFocus
             * @fires contenteditable:focus
             */
            handleFocus: function handleFocus() {
                var mediator = this.mediator;

                this.clearCleanupTimeout();
                this.ensureDefaultBlock();
                this.updatePlaceholderState();
                mediator.emit('contenteditable:focus');
            },
            handleKeyup: function handleKeyup(evnt) {
                var mediator = this.mediator,
                    dom = this.dom;

                var keyCode = evnt.which || evnt.keyCode;
                var anchorNode = mediator.get('selection:anchornode');

                function CustomEvent(event, params) {
                    var evt;
                    params = params || { bubbles: true, cancelable: true, detail: undefined };
                    evt = document.createEvent('CustomEvent');
                    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                    return evt;
                }

                switch (keyCode) {
                    case keycodes.ENTER:
                        setTimeout(function () {
                            mediator.emit('contenteditable:newline');
                        }, 100);
                        break;
                    case keycodes.BACKSPACE:
                        if (!anchorNode.textContent.trim().length || anchorNode.hasAttribute && anchorNode.hasAttribute('contenteditable')) {
                            mediator.emit('contenteditable:newline');
                        }
                        break;
                    case keycodes.TAB:
                        mediator.emit('contenteditable:tab:up', evnt);
                        break;
                }

                dom.el[0].dispatchEvent(new CustomEvent('change'));

                this.updateValue();
                this.updatePlaceholderState();
            },
            handleKeydown: function handleKeydown(evnt) {
                var _this2 = this;

                var mediator = this.mediator;

                var keyCode = evnt.which || evnt.keyCode;

                setTimeout(function () {
                    _this2.updatePlaceholderState();
                }, 25);

                switch (keyCode) {
                    case keycodes.TAB:
                        mediator.emit('contenteditable:tab:down', evnt);
                        break;
                }
            },
            handleBlur: function handleBlur() {
                var mediator = this.mediator;

                this.updatePlaceholderState();
                this.updateValue();
                this.setCleanupTimeout();
                mediator.emit('contenteditable:blur');
            },
            handlePaste: function handlePaste(evnt) {
                var mediator = this.mediator;

                mediator.emit('contenteditable:paste', evnt);
                this.updateValue();
            },
            handleMouseOver: function handleMouseOver(evnt) {
                var mediator = this.mediator;

                if (evnt.target.nodeName === 'A') {
                    mediator.emit('contenteditable:mouseover:anchor', evnt);
                }
            },
            handleMouseOut: function handleMouseOut(evnt) {
                var mediator = this.mediator;

                if (evnt.target.nodeName === 'A') {
                    mediator.emit('contenteditable:mouseout:anchor', evnt);
                }
            },
            handleClick: function handleClick(evnt) {
                var dom = this.dom;

                var rootEl = dom.el[0];

                if (DOM.isIn(evnt.target, 'A', rootEl)) {
                    evnt.preventDefault();
                    evnt.stopPropagation();
                }
            },
            handleInput: function handleInput() {
                this.updateValue();
            }
        }
    });

    // jshint strict: false

    /**
     * AppContainer - The top most container for the Typester app stack. This
     * container sets up the {@link FormatterContainer}, {@link UIContainer},
     * and {@link CanvasContainer} containers which are treated as singletons.
     *
     * @access protected
     * @module containers/AppContainer
     *
     * @requires core/Container
     * @requires containers/UIContainer
     * @requires containers/FormatterContainer
     * @requires containers/CanvasContainer
     * @requires modules/ContentEditable
     * @requires modules/Selection
     *
     * @example
     * new AppContainer({
     *   dom: {
     *     el: domElement
     *   }
     * });
     */

    var uiContainer = void 0;
    var formatterContainer = void 0;
    var canvasContainer = void 0;

    /**
     * @constructor AppContainer
     * @param  {object} opts={} - instance options
     * @param  {object} opts.dom - The dom components used by Typester
     * @param  {element} opts.dom.el - The dom element to be the canvas for Typester
     * @return {container} AppContainer instance
     */
    var AppContainer = Container({
        name: 'AppContainer',

        /**
         * Child modules: [{@link modules/ContentEditable}, {@link modules/Selection}]
         * @enum {Array<{class:Module}>} modules
         */
        modules: [{
            class: ContentEditable
        }, {
            class: Selection
        }],

        /**
         * @prop {Object} handlers
         * @prop {Object} handlers.events - AppContainer listens to events from {@link ContentEditable}
         */
        handlers: {
            events: {
                'contenteditable:focus': 'handleFocus',
                'contenteditable:blur': 'handleBlur'
            }
        },
        methods: {
            /**
             * @func setup
             * @desc Initializes the {@link FormatterContainer} and provides a mediator
             * to attach to.
             * @protected
             */
            setup: function setup() {
                var mediator = this.mediator;

                formatterContainer = formatterContainer || new FormatterContainer({ mediator: mediator });
                uiContainer = uiContainer || new UIContainer({ mediator: mediator });
                canvasContainer = canvasContainer || new CanvasContainer({ mediator: mediator });
            },

            /**
             * Nothing to see here.
             * @func init
             * @ignore
             */
            init: function init() {
                // Current nothing to init for this container. Method left here for ref.
            },


            /**
             * Because the {@link FormatterContainer}, {@link UIContainer},
             * and {@link CanvasContainer} containers are intended to be singletons
             * they need to communicate through the current active mediator instance.
             *
             * @method handleFocus
             * @listens contenteditable:focus
             */
            handleFocus: function handleFocus() {
                var mediator = this.mediator;

                uiContainer.setMediatorParent(mediator);
                formatterContainer.setMediatorParent(mediator);
                canvasContainer.setMediatorParent(mediator);
            },


            /**
             * Nothing to see here.
             * @func handleBlur
             * @ignore
             */
            handleBlur: function handleBlur() {
                // Should the container require to do anything in particular here
            }
        }
    });

    // jshint strict: false
    /* eslint-disable no-alert, no-console */

    /**
     * Tyester - Public interface to instatiate a Typester instance bound to a
     * dom element
     *
     * @access public
     * @param  {object} opts={} - instance options
     * @param  {object} opts.dom - The dom components used by Typester
     * @param  {element} opts.dom.el - The dom element to be the canvas for Typester
     * @return {appContainer} AppContainer instance
     *
     * @example
     * new Typester({
     *   dom: {
     *     el: domElement
     *   }
     * });
     */
    var Typester = function Typester() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return new AppContainer({ dom: { el: opts.el } });
    };

    return Typester;

})));
//# sourceMappingURL=typester.js.map
;
define('forms/fields/RichContentEditor', [
    'jquery',
    'DOMPurify',
    'Typester',
    'factories/fieldFactory'
], function (
    $,
    DOMPurify,
    Typester,
    fieldFactory
) {
    'use strict';
    /*
        Rich Content Editor
        ===================

        A very thin wrapper for the MediumEditor which uses the fieldFactory to
        bolt on the methods required to plug into the form controller.

        Example:
        <div class='editable-content main-copy' name='rich_content_field'>
            <p>Rich text editor content</p>
        </div>

        var richContentEditor = new RichContentEditor({
            $e: $(el)
        });

        NB:
        - This is initialized by the Form module, so no need to do additional
          initialization for forms controlled by the Form module.
    */
    var RichContentEditor = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = RichContentEditor.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.editable-content'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'RichContentEditor',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            withoutNativeInput: true,
            valMethod: 'html',
            charlimit: null,

            editorIsSetup: null,
            mediumEditor: null,
            mediumEditorOptions: {
                extensions: {
                    'imageDragging': {} // Apparently disables image/file dragging
                },
                toolbar: {
                    buttons: [
                        'bold',
                        'italic',
                        'h1',
                        'h2',
                        {
                            name: 'orderedlist'
                        },
                        {
                            name: 'unorderedlist'
                        },
                        'quote',
                        {
                            name: 'anchor'
                        }
                    ]
                },
                anchor: {
                    formSaveLabel: null,
                    formCloseLabel: null
                },
                placeholder: {
                    text: '',
                    hideOnClick: false
                }
            },

            // Dict of template tags in the HTML required by this module
            templates: {
                richContentEditorIcons: {
                    selector: '!.rich-content-editor-icons'
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'focus': 'internalElFocus'
            }
        };

        // Elements cache
        elements = {};

        // Templates cache
        templates = {};

        // Primary methods
        fn = {
            // Initialize the RichContentEditor and intialize an instance of
            // MediumEditor
            init: function () {
                new Typester({
                    el: internal.$e[0]
                });
                // fn.initEditor();
                // fn.setupEditor();
                fn.cacheCharLimit();
            },

            // Return the HTML as the value
            getVal: function () {
                return fn.purify($.trim(internal.$e.html()));
            },

            purify: function (content) {
                return DOMPurify.sanitize(content);
            },

            // Set the field HTML to the passed in html
            setVal: function (html, options) {
                options = options || {};

                internal.$e.html(html);
                internal.$e[0].value = html;

                if (options.isDefault) {
                    internal.$e.trigger('change:default', html);
                }
            },

            // Make sure that there is some HTML in the field
            isBlank: function () {
                return !$.trim(internal.$e.text()).length;
            },

            // Initialize an instance of Medium Editor
            initEditor: function () {
                // fn.setMediumEditorOptions();
                // fn.setIcons();
                //
                // internal.mediumEditor = new MediumEditor(
                //     internal.$e,
                //     internal.mediumEditorOptions
                // );
                //
                // internal.mediumEditor.subscribe('editableInput', function () {
                //     fn.updateCharLimit();
                //     internal.$e.trigger('change');
                // });
                //
                // internal.mediumEditor.subscribe('blur', function () {
                //     fn.parseLinks();
                // });
                //
                // internal.$e.data('mediumEditor', internal.mediumEditor);
            },

            destroyExistingEditor: function () {
                var existingEditor, attributes, attributeNames, classList;

                existingEditor = internal.$e.data('mediumEditor');
                attributes = internal.$e[0].attributes;
                attributeNames = [];
                classList = internal.$e[0].className.split(' ');

                if (existingEditor) {
                    existingEditor.destroy();
                }

                $.each(attributes, function (i, attr) {
                    if (/medium/gi.test(attr.nodeName)) {
                        attributeNames.push(attr.nodeName);
                    }
                });

                $.each(attributeNames, function (i, attrName) {
                    internal.$e.removeAttr(attrName);
                });

                $.each(classList, function (i, className) {
                    if (/medium/.test(className) || className === m.HAS_VALUE) {
                        internal.$e.removeClass(className);
                    }
                });

                internal.$e.empty();
            },

            setMediumEditorOptions: function () {
                // var toolbarButtons, placeholder;
                //
                // toolbarButtons = internal.$e.data('toolbarButtons');
                // placeholder = internal.$e.data('placeholder');
                //
                // if (toolbarButtons) {
                //     internal.mediumEditorOptions.toolbar.buttons = [];
                //     $.each(toolbarButtons, function (i, buttonName) {
                //         internal.mediumEditorOptions.toolbar.buttons.push({
                //             name: buttonName
                //         });
                //     });
                // }
                //
                // if (placeholder) {
                //     internal.mediumEditorOptions.placeholder.text = placeholder;
                // }
            },

            // Use the SVG from /forms/includes/rich_content_editor_icons.html
            // as custom icons in the Medium Editor toolbar
            setIcons: function () {
                // var svgIcon;
                //
                // $.each(internal.mediumEditorOptions.toolbar.buttons, function (i, buttonDict) {
                //     if (buttonDict.name) {
                //         svgIcon = fn.getSvgIconHtml(buttonDict.name) || false;
                //         if (svgIcon) {
                //             buttonDict.contentDefault = svgIcon;
                //         }
                //     }
                // });
                // internal.mediumEditorOptions.anchor.formSaveLabel = fn.getSvgIconHtml('check');
                // internal.mediumEditorOptions.anchor.formCloseLabel = fn.getSvgIconHtml('close');
            },

            // Filter through the icons and return the SVG content
            getSvgIconHtml: function (iconName) {
                var $svgIcon, svgIconHtml;

                $svgIcon = templates.richContentEditorIcons.filter('.' + iconName + '-icon');

                if ($svgIcon.length) {
                    svgIconHtml = $svgIcon.html();
                }

                return svgIconHtml;
            },

            // Use the Medium Editor destroy method to setup the instance
            setupEditor: function () {
                return;
            },

            // Use the Medium Editor destroy method to tear down the instance
            destroyEditor: function () {
                // if (internal.mediumEditor) {
                //     internal.mediumEditor.destroy();
                // }
                // internal.editorIsSetup = false;
            },

            reset: function () {
                fn.destroyExistingEditor();
                fn.setupEditor();
            },

            parseLinks: function () {
                internal.$e.find('[href]').each(function (i, anchor) {
                    var $anchor, href, qualifiedCheck, internalCheck, hrefParts,
                        mailtoCheck;

                    $anchor = $(anchor);
                    href = $anchor.attr('href');
                    internalCheck = /^\//;
                    qualifiedCheck = /^https?/;
                    mailtoCheck = /^mailto:/;

                    if (internalCheck.test(href) || qualifiedCheck.test(href) || mailtoCheck.test(href)) {
                        return;
                    }

                    hrefParts = href.split('/');

                    if (hrefParts[0].indexOf('.') > -1) {
                        href = 'https://' + href;
                    } else {
                        href = '/' + href;
                    }

                    $anchor.attr('href', href);
                });
            },

            cacheCharLimit: function () {
                internal.charlimit = parseInt(internal.$e.attr('charlimit'), 10);
                elements.charCount = internal.$e.next('.' + m.CHAR_COUNT);
            },

            updateCharLimit: function () {
                var currentCharCount;

                currentCharCount = internal.$e.html().length;
                elements.charCount.html(currentCharCount + '/' + internal.charlimit);
                elements.charCount.toggleClass(m.OVERFLOW, currentCharCount > internal.charlimit);
            },

            beforeDestroy: function () {
                fn.destroyEditor();
            },

            isValid: function () {
                var isValid = internal.validator.isValid();

                if (internal.charlimit) {
                    isValid = isValid && internal.charlimit >= internal.$e.html().length;
                }

                return isValid;
            }
        };

        // Event handlers
        handlers = {
            internalElFocus: function () {
                fn.setupEditor();
            }
        };

        // A map of methods to be exposed on the instance of this module
        api = {
            getVal: fn.getVal,
            setVal: fn.setVal,
            isBlank: fn.isBlank,
            focus: fn.focus,
            reset: fn.reset,
            parseLinks: fn.parseLinks
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    // Module markup
    RichContentEditor.markup = {
        CHAR_COUNT: 'char-count',
        OVERFLOW: 'state-overflow'
    };

    return RichContentEditor;
});

define('utils/handlebarsUtils', [
    'jquery',
    'handlebars'
], function (
    $,
    handlebars
) {
    'use strict';

    handlebars.registerHelper('toJSON', function (object) {
        if ($.isArray(object) && object.length === 1 && $.isArray(object[0])) {
            object = object[0];
        }
        return JSON.stringify(object);
    });

    handlebars.registerHelper('ifCond', function (v1, operator, v2, options) {
        switch (operator) {
            case '===':
                return (v1 === v2) ? options.fn(this) : options.inverse(this);
            case '!==':
                return (v1 !== v2) ? options.fn(this) : options.inverse(this);
            case '<':
                return (v1 < v2) ? options.fn(this) : options.inverse(this);
            case '<=':
                return (v1 <= v2) ? options.fn(this) : options.inverse(this);
            case '>':
                return (v1 > v2) ? options.fn(this) : options.inverse(this);
            case '>=':
                return (v1 >= v2) ? options.fn(this) : options.inverse(this);
            case '&&':
                return (v1 && v2) ? options.fn(this) : options.inverse(this);
            case '||':
                return (v1 || v2) ? options.fn(this) : options.inverse(this);
            default:
                return options.inverse(this);
        }
    });

    handlebars.registerHelper('encodeURI', function (uri) {
        return encodeURI(uri);
    });

    handlebars.registerHelper('capitalize', function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    });

    handlebars.registerHelper('ccToString', function (str) {
        var ccLicenseComponents, strParts, licenseCopy;

        if (str.indexOf('cc-') !== 0) {
            return str;
        }

        ccLicenseComponents = {
            by: 'Attribution',
            nd: 'NoDerivatives',
            sa: 'ShareAlike',
            nc: 'NonCommercial',
            suffix: '4.0 International'
        };

        licenseCopy = [];
        str = str.replace('cc-', '');
        strParts = str.split('-');

        strParts.forEach(function (part) {
            licenseCopy.push(ccLicenseComponents[part]);
        });

        return licenseCopy.join('-') + ' ' + ccLicenseComponents.suffix;
    });

    handlebars.registerHelper('ccClasses', function (str) {
        var classNames;

        classNames = [];

        str.split('-').forEach(function (ccPart) {
            classNames.push('state-show-' + ccPart);
        });

        return classNames.join(' ');
    });
});

define('forms/fields/JsonField', [
    'jquery',
    'factories/fieldFactory',
    'utils/handlebarsUtils'
], function (
    $,
    fieldFactory
) {
    'use strict';
    /*
        JsonField
        =========
    */
    var JsonField = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = JsonField.markup;

        o = $.extend({
            $e: null,
            selector: '.json-field'
        }, options);

        internal = {
            name: 'JsonField',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            withoutNativeInput: true,
            components: {
                jsonItem: {
                    selector: '.json-item'
                }
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                if (internal.$e.data('initialVal')) {
                    fn.setInitialVal();
                }

                if (elements.jsonItem) {
                    fn.setJsonItems();
                }
            },

            setInitialVal: function () {
                var initialVal = internal.$e.data('initialVal'),
                    initialValKey = internal.$e.data('initialValKey');

                if (initialValKey) {
                    fn.setDefaultVal(initialVal[initialValKey]);
                } else {
                    fn.setDefaultVal(initialVal);
                }
            },

            setJsonItems: function () {
                var itemsArr = [];

                elements.jsonItem.each(function (i, item) {
                    itemsArr.push($(item).data('value'));
                });

                fn.setDefaultVal(itemsArr);

                // elements.jsonItem.remove();
            },
            getDefaults: function () {
                return internal.$e.data('defaults') || {};
            },
            getName: function () {
                var fieldName = internal.$e.attr('name');

                if (/\[.*?\]/.test(fieldName) && $.isArray(fn.getVal())) {
                    fieldName = fieldName.replace(/\[.*?\]/, '');
                }

                return fieldName || '';
            },
            getVal: function () {
                var val, defaults, returnVal, fieldName, namedArray, valueKey,
                    itemObjVal;

                fieldName = internal.$e.attr('name');
                valueKey = internal.$e.data('valueKey');
                namedArray = /\[.*?\]/.test(fieldName);
                val = internal.$e.data('value');

                if (!val || $.isEmptyObject(val)) {
                    val = namedArray ? [] : {};
                }

                if ($.isArray(val)) {
                    returnVal = [];

                    $.each(val, function (i, item) {
                        if ($.isPlainObject(item)) {
                            defaults = $.extend({}, fn.getDefaults());
                            itemObjVal = $.extend(defaults, item);
                            if (valueKey) {
                                returnVal.push(itemObjVal[valueKey]);
                            } else {
                                returnVal.push(itemObjVal);
                            }
                        } else {
                            returnVal.push(item);
                        }
                    });
                } else {
                    defaults = $.extend({}, fn.getDefaults());
                    returnVal = $.extend(defaults, val);

                    if (valueKey) {
                        returnVal = returnVal[valueKey];
                    }
                }

                if (namedArray && !$.isArray(returnVal)) {
                    returnVal = [returnVal];
                }

                return returnVal;
            },

            getFullVal: function () {
                return internal.$e.data('value');
            },

            setVal: function (value, options) {
                options = options || {};

                if (internal.$e.data('noSet')) {
                    return;
                }

                internal.$e.data('value', value);

                if (options.isDefault) {
                    internal.$e.trigger('change:default', value);
                }
            }
        };

        handlers = {};

        api = {
            getName: fn.getName,
            getVal: fn.getVal,
            getFullVal: fn.getFullVal,
            setVal: fn.setVal
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    JsonField.markup = {};

    return JsonField;
});

define('forms/fields/FileDrop', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';

    var FileDrop = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = FileDrop.markup;

        o = $.extend({
            $e: null,
            selector: '.file-drop'
        }, options);

        internal = {
            name: 'FileDrop',
            $e: o.$e || $(o.selector),

            withoutNativeInput: true,
            files: [],

            uploadType: 'image',
            imageMeta: {
                height: '',
                width: ''
            },

            templates: {
                filePreview: {
                    selector: '!.file-preview-template'
                },
                imagePreview: {
                    selector: '!.image-preview-template'
                }
            },

            components: {
                dropArea: {
                    selector: '.drop-area'
                },
                dropLabel: {
                    selector: '.drop-label'
                },
                fileInput: {
                    selector: '.file-input'
                },
                filePreview: {
                    selector: '.file-preview'
                },
                fileName: {
                    selector: '.file-meta .filename'
                },
                fileSize: {
                    selector: '.file-meta .filesize'
                },
                removeFile: {
                    selector: '.remove-file'
                },
                validationMessage: {
                    selector: '.validation-message'
                },
                focalPoint: {
                    selector: '.focal-point'
                },
                previewArea: {
                    selector: '.preview-area'
                },
                previewContent: {
                    selector: '.preview-content'
                }
            },

            events: {
                'change': 'internalElChange',
                'dragover @dropArea': 'dropAreaDragover',
                'dragenter @dropArea': 'dropAreaDragover',
                'dragleave @dropArea': 'dropAreaDragout',
                'dragend @dropArea': 'dropAreaDragout',
                'drop @dropArea': 'dropAreaDrop',
                'click @dropArea': 'dropAreaClick',
                'change @fileInput': 'fileInputChange',
                'click @removeFile': 'removeFileClick'
            },

            validationMessages: {
                imageTooSmall: 'Image should be a minimum of {{minWidth}} px wide, and {{minHeight}} px tall'
            },

            errorMessages: []
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                fn.getUploadType();
                fn.getInitialData();
                fn.updateState();

                internal.$e.on('drag dragstart dragover dragenter dragleave dragend drop', handlers.interceptDragEvents);
            },

            getInitialData: function () {
                var initialFiles;

                internal.data = internal.$e.data('initialData');
                internal.$e.removeAttr('data-initial-data');

                if (internal.data) {
                    initialFiles = internal.data.image || internal.data.file || [];

                    if (initialFiles.length) {
                        fn.updateFiles(initialFiles, { silent: true });
                    }
                }
            },

            getUploadType: function () {
                internal.uploadType = internal.$e.data('uploadType') || internal.uploadType;
                return internal.uploadType;
            },

            setUploadType: function (uploadType) {
                internal.uploadType = uploadType;
                internal.$e.data('uploadType', uploadType);
                internal.$e.attr('name', uploadType);
                internal.$e.trigger('uploadtypechange', uploadType);
            },

            clearPreview: function () {
                elements.previewContent.empty();
                elements.previewArea.hide();
                elements.dropLabel.show();
                fn.clearFileMeta();
                fn.showDropArea();
            },

            showPreview: function () {
                var firstFile, templateHTML;

                firstFile = internal.files[0] || false;

                if (firstFile) {
                    if ((firstFile.isImage || internal.uploadType === 'image') && firstFile.url) {
                        templateHTML = templates.imagePreview({
                            imageSrc: firstFile.data || firstFile.url
                        });
                    } else if (firstFile.file || firstFile.url) {
                        templateHTML = templates.filePreview({
                            fileName: firstFile.file ? firstFile.file.name : firstFile.name
                        });
                    }

                    if (templateHTML) {
                        elements.previewContent.html(templateHTML);
                        elements.previewArea.show();
                        if (firstFile.file) {
                            fn.showFileMeta(firstFile);
                        }
                        elements.dropLabel.hide();
                        fn.hideDropArea();
                    }
                }

            },

            clearFileMeta: function () {
                elements.fileName.empty();
                elements.fileSize.empty();
            },

            showFileMeta: function (file) {
                elements.fileName.html(file.file.name);
                elements.fileSize.html(fn.getFileSize(file));
            },

            showDropArea: function () {
                elements.dropArea.show();
            },

            hideDropArea: function () {
                elements.dropArea.hide();
            },

            showFocalPoint: function () {
                if (fn.getUploadType() === 'image') {
                    elements.focalPoint.show();
                } else {
                    fn.hideFocalPoint();
                }
            },

            hideFocalPoint: function () {
                elements.focalPoint.hide();
            },

            setProcessing: function () {
                internal.$e.addClass(m.PROCESSING);
            },

            clearProcessing: function () {
                internal.$e.removeClass(m.PROCESSING);
            },

            isMultiSelect: function () {
                return elements.fileInput[0].hasAttribute('multiple');
            },

            handleFileDrop: function (files) {
                var reader, readNextFile, processedFiles, fileIndex, maxFiles;

                reader = new FileReader();
                processedFiles = [];
                fileIndex = -1;
                maxFiles = fn.isMultiSelect() ? files.length : 1;

                readNextFile = function () {
                    var processedFile, file;

                    processedFile = {};
                    fileIndex += 1;

                    if (fileIndex < maxFiles) {
                        file = files[fileIndex];

                        if (fn.acceptableFile(file)) {
                            processedFile.file = file;
                            processedFiles[fileIndex] = processedFile;
                            processedFile.isImage = /image(?!.*(svg))/.test(processedFile.file.type);

                            if (internal.uploadType === 'auto') {
                                fn.setUploadType(processedFile.isImage ? 'image' : 'file');
                            }

                            if (processedFile.isImage) {
                                processedFile.url = URL.createObjectURL(processedFile.file);
                            }
                        }

                        readNextFile();
                    } else {
                        fn.updateFiles(processedFiles);
                        fn.clearProcessing();
                        internal.$e.trigger('change');
                    }
                };

                reader.onload = function (evnt) {
                    var processedFile = processedFiles[fileIndex];
                    processedFile.data = evnt.target.result;
                    readNextFile();
                };

                readNextFile();
            },

            acceptableFile: function (file) {
                return (
                    (internal.uploadType === 'auto') ||
                    (internal.uploadType === 'file') ||
                    (internal.uploadType === 'image' && /image/.test(file.type))
                );
            },

            updateFiles: function (files, options) {
                var filesProcessor, uploadType;

                options = options || {};
                uploadType = fn.getUploadType();
                filesProcessor = internal.$e.data('filesProcessor');

                if (!$.isArray(files)) {
                    files = [files];
                }

                if (filesProcessor) {
                    files = filesProcessor(files);
                }

                internal.files = files;
                fn.updateState();

                if (uploadType === 'auto' && internal.files.length === 1) {
                    fn.setUploadType(internal.files[0].isImage ? 'image' : 'file');
                }

                if (!options.silent) {
                    internal.$e.trigger('filesupdated');
                }
            },

            updateState: function () {
                var isFilled;

                isFilled = internal.files.length > 0;
                internal.$e.toggleClass(m.FILLED, isFilled);

                if (isFilled) {
                    fn.showPreview();
                    fn.showFocalPoint();
                } else {
                    fn.clearPreview();
                    fn.hideFocalPoint();
                }
            },

            getVal: function () {
                return internal.files;
            },

            getFileSize: function (file) {
                if (file.isImage) {
                    return fn.getImageSize(file);
                } else {
                    return fn.getFileDataSize(file);
                }
            },

            setVal: function (files, options) {
                fn.updateFiles(files, options);
            },

            getFileDataSize: function (file) {
                var fileByteSize, fileKbSize, fileMbSize, fileGbSize, returnSize, sizeSuffix;

                fileByteSize = file.file.size;
                fileKbSize = fileByteSize / 1024;
                fileMbSize = fileKbSize / 1024;
                fileGbSize = fileMbSize / 1024;

                returnSize = fileKbSize;
                sizeSuffix = 'KB';

                if (fileKbSize > 1) {
                    returnSize = fileMbSize;
                    sizeSuffix = 'MB';
                }

                if (fileGbSize > 1) {
                    returnSize = fileGbSize;
                    sizeSuffix = 'GB';
                }

                returnSize = Math.round(returnSize * 100) / 100;

                return returnSize + ' ' + sizeSuffix;
            },

            getImageSize: function (file) {
                var tmpImg;
                tmpImg = new Image();

                tmpImg.onload = function () {
                    elements.fileSize.html(this.width + ' x ' + this.height);
                    internal.imageMeta.width = this.width;
                    internal.imageMeta.height = this.height;
                };
                tmpImg.src = file.url;

                return file.file.size;
            },

            validImageDimensions: function () {
                var minHeight, minWidth, tooSmall;

                minHeight = parseInt(internal.$e.data('minHeight') || 0, 10);
                minWidth = parseInt(internal.$e.data('minWidth') || 0, 10);

                tooSmall = (internal.imageMeta.width < minWidth || internal.imageMeta.height < minHeight);

                if (tooSmall) {
                    internal.errorMessages.push(fn.buildErrorMsg('imageTooSmall', { minWidth: minWidth, minHeight: minHeight }));
                }

                return !tooSmall;
            },

            removeFile: function () {
                elements.fileInput.val('');
                fn.updateFiles([]);
                internal.$e.trigger('change');
            },

            buildErrorMsg: function (msgKey, msgData) {
                var errorMsg = internal.validationMessages[msgKey];

                $.each(msgData, function (key, value) {
                    var regex = new RegExp('{{' + key + '}}', 'g');
                    errorMsg = errorMsg.replace(regex, value);
                });

                return errorMsg;
            },

            isValid: function () {
                var isValid = true;

                isValid = !!internal.files.length;

                return isValid;
            },

            validate: function () {
                internal.errorMessages = [];

                if (
                    !fn.isValid() ||
                    internal.uploadType === 'image' && !fn.validImageDimensions()
                ) {
                    fn.renderErrorMessages();
                    self.setInvalid();
                } else {
                    self.setValid();
                }
            },

            isBlank: function () {
                return !internal.files.length;
            },

            renderErrorMessages: function () {
                var errorMessagesHtml = '';

                $.each(internal.errorMessages, function (i, errorMessage) {
                    errorMessagesHtml += '<p>' + errorMessage + '</p>';
                });

                elements.validationMessage.html(errorMessagesHtml);
            },

            beforeDestroy: function () {
                internal.$e.off('drag dragstart dragover dragenter dragleave dragend drop');
            }
        };

        handlers = {
            internalElChange: function () {
                fn.validate();
            },

            interceptDragEvents: function (evnt) {
                evnt.preventDefault();
                evnt.stopPropagation();
            },

            dropAreaDragover: function () {
                internal.$e.addClass(m.DRAG_OVER);
            },

            dropAreaDragout: function () {
                internal.$e.removeClass(m.DRAG_OVER);
            },

            dropAreaDrop: function (evnt) {
                handlers.dropAreaDragout();
                fn.setProcessing();
                fn.handleFileDrop(evnt.originalEvent.dataTransfer.files);
            },

            dropAreaClick: function () {
                if (fn.isBlank()) {
                    elements.fileInput.click();
                }
            },

            fileInputChange: function (evnt) {
                fn.setProcessing();
                fn.handleFileDrop(evnt.target.files);
            },

            removeFileClick: function () {
                fn.removeFile();
            }
        };

        api = {
            getVal: fn.getVal,
            setVal: fn.setVal,
            isValid: fn.isValid,
            isBlank: fn.isBlank,
            hasImagePreview: fn.hasImagePreview,
            getUploadType: fn.getUploadType
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    FileDrop.markup = {
        DRAG_OVER: 'state-drag-over',
        FILLED: 'state-filled'
    };

    return FileDrop;
});

!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define('moment', t) : e.moment = t() }(this, function () { "use strict"; var H; function f() { return H.apply(null, arguments) } function a(e) { return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e) } function F(e) { return null != e && "[object Object]" === Object.prototype.toString.call(e) } function c(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function L(e) { if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length; for (var t in e) if (c(e, t)) return; return 1 } function o(e) { return void 0 === e } function u(e) { return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e) } function V(e) { return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e) } function G(e, t) { for (var n = [], s = e.length, i = 0; i < s; ++i)n.push(t(e[i], i)); return n } function E(e, t) { for (var n in t) c(t, n) && (e[n] = t[n]); return c(t, "toString") && (e.toString = t.toString), c(t, "valueOf") && (e.valueOf = t.valueOf), e } function l(e, t, n, s) { return Pt(e, t, n, s, !0).utc() } function m(e) { return null == e._pf && (e._pf = { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidEra: null, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], era: null, meridiem: null, rfc2822: !1, weekdayMismatch: !1 }), e._pf } function A(e) { if (null == e._isValid) { var t = m(e), n = j.call(t.parsedDateParts, function (e) { return null != e }), n = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n); if (e._strict && (n = n && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return n; e._isValid = n } return e._isValid } function I(e) { var t = l(NaN); return null != e ? E(m(t), e) : m(t).userInvalidated = !0, t } var j = Array.prototype.some || function (e) { for (var t = Object(this), n = t.length >>> 0, s = 0; s < n; s++)if (s in t && e.call(this, t[s], s, t)) return !0; return !1 }, Z = f.momentProperties = [], z = !1; function $(e, t) { var n, s, i, r = Z.length; if (o(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), o(t._i) || (e._i = t._i), o(t._f) || (e._f = t._f), o(t._l) || (e._l = t._l), o(t._strict) || (e._strict = t._strict), o(t._tzm) || (e._tzm = t._tzm), o(t._isUTC) || (e._isUTC = t._isUTC), o(t._offset) || (e._offset = t._offset), o(t._pf) || (e._pf = m(t)), o(t._locale) || (e._locale = t._locale), 0 < r) for (n = 0; n < r; n++)o(i = t[s = Z[n]]) || (e[s] = i); return e } function q(e) { $(this, e), this._d = new Date(null != e._d ? e._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === z && (z = !0, f.updateOffset(this), z = !1) } function h(e) { return e instanceof q || null != e && null != e._isAMomentObject } function B(e) { !1 === f.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e) } function e(r, a) { var o = !0; return E(function () { if (null != f.deprecationHandler && f.deprecationHandler(null, r), o) { for (var e, t, n = [], s = arguments.length, i = 0; i < s; i++) { if (e = "", "object" == typeof arguments[i]) { for (t in e += "\n[" + i + "] ", arguments[0]) c(arguments[0], t) && (e += t + ": " + arguments[0][t] + ", "); e = e.slice(0, -2) } else e = arguments[i]; n.push(e) } B(r + "\nArguments: " + Array.prototype.slice.call(n).join("") + "\n" + (new Error).stack), o = !1 } return a.apply(this, arguments) }, a) } var J = {}; function Q(e, t) { null != f.deprecationHandler && f.deprecationHandler(e, t), J[e] || (B(t), J[e] = !0) } function d(e) { return "undefined" != typeof Function && e instanceof Function || "[object Function]" === Object.prototype.toString.call(e) } function X(e, t) { var n, s = E({}, e); for (n in t) c(t, n) && (F(e[n]) && F(t[n]) ? (s[n] = {}, E(s[n], e[n]), E(s[n], t[n])) : null != t[n] ? s[n] = t[n] : delete s[n]); for (n in e) c(e, n) && !c(t, n) && F(e[n]) && (s[n] = E({}, s[n])); return s } function K(e) { null != e && this.set(e) } f.suppressDeprecationWarnings = !1, f.deprecationHandler = null; var ee = Object.keys || function (e) { var t, n = []; for (t in e) c(e, t) && n.push(t); return n }; function r(e, t, n) { var s = "" + Math.abs(e); return (0 <= e ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, t - s.length)).toString().substr(1) + s } var te = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, ne = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, se = {}, ie = {}; function s(e, t, n, s) { var i = "string" == typeof s ? function () { return this[s]() } : s; e && (ie[e] = i), t && (ie[t[0]] = function () { return r(i.apply(this, arguments), t[1], t[2]) }), n && (ie[n] = function () { return this.localeData().ordinal(i.apply(this, arguments), e) }) } function re(e, t) { return e.isValid() ? (t = ae(t, e.localeData()), se[t] = se[t] || function (s) { for (var e, i = s.match(te), t = 0, r = i.length; t < r; t++)ie[i[t]] ? i[t] = ie[i[t]] : i[t] = (e = i[t]).match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, ""); return function (e) { for (var t = "", n = 0; n < r; n++)t += d(i[n]) ? i[n].call(e, s) : i[n]; return t } }(t), se[t](e)) : e.localeData().invalidDate() } function ae(e, t) { var n = 5; function s(e) { return t.longDateFormat(e) || e } for (ne.lastIndex = 0; 0 <= n && ne.test(e);)e = e.replace(ne, s), ne.lastIndex = 0, --n; return e } var oe = {}; function t(e, t) { var n = e.toLowerCase(); oe[n] = oe[n + "s"] = oe[t] = e } function _(e) { return "string" == typeof e ? oe[e] || oe[e.toLowerCase()] : void 0 } function ue(e) { var t, n, s = {}; for (n in e) c(e, n) && (t = _(n)) && (s[t] = e[n]); return s } var le = {}; function n(e, t) { le[e] = t } function he(e) { return e % 4 == 0 && e % 100 != 0 || e % 400 == 0 } function y(e) { return e < 0 ? Math.ceil(e) || 0 : Math.floor(e) } function g(e) { var e = +e, t = 0; return t = 0 != e && isFinite(e) ? y(e) : t } function de(t, n) { return function (e) { return null != e ? (fe(this, t, e), f.updateOffset(this, n), this) : ce(this, t) } } function ce(e, t) { return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN } function fe(e, t, n) { e.isValid() && !isNaN(n) && ("FullYear" === t && he(e.year()) && 1 === e.month() && 29 === e.date() ? (n = g(n), e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), We(n, e.month()))) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n)) } var i = /\d/, w = /\d\d/, me = /\d{3}/, _e = /\d{4}/, ye = /[+-]?\d{6}/, p = /\d\d?/, ge = /\d\d\d\d?/, we = /\d\d\d\d\d\d?/, pe = /\d{1,3}/, ke = /\d{1,4}/, ve = /[+-]?\d{1,6}/, Me = /\d+/, De = /[+-]?\d+/, Se = /Z|[+-]\d\d:?\d\d/gi, Ye = /Z|[+-]\d\d(?::?\d\d)?/gi, k = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i; function v(e, n, s) { be[e] = d(n) ? n : function (e, t) { return e && s ? s : n } } function Oe(e, t) { return c(be, e) ? be[e](t._strict, t._locale) : new RegExp(M(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (e, t, n, s, i) { return t || n || s || i }))) } function M(e) { return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") } var be = {}, xe = {}; function D(e, n) { var t, s, i = n; for ("string" == typeof e && (e = [e]), u(n) && (i = function (e, t) { t[n] = g(e) }), s = e.length, t = 0; t < s; t++)xe[e[t]] = i } function Te(e, i) { D(e, function (e, t, n, s) { n._w = n._w || {}, i(e, n._w, n, s) }) } var S, Y = 0, O = 1, b = 2, x = 3, T = 4, N = 5, Ne = 6, Pe = 7, Re = 8; function We(e, t) { if (isNaN(e) || isNaN(t)) return NaN; var n = (t % (n = 12) + n) % n; return e += (t - n) / 12, 1 == n ? he(e) ? 29 : 28 : 31 - n % 7 % 2 } S = Array.prototype.indexOf || function (e) { for (var t = 0; t < this.length; ++t)if (this[t] === e) return t; return -1 }, s("M", ["MM", 2], "Mo", function () { return this.month() + 1 }), s("MMM", 0, 0, function (e) { return this.localeData().monthsShort(this, e) }), s("MMMM", 0, 0, function (e) { return this.localeData().months(this, e) }), t("month", "M"), n("month", 8), v("M", p), v("MM", p, w), v("MMM", function (e, t) { return t.monthsShortRegex(e) }), v("MMMM", function (e, t) { return t.monthsRegex(e) }), D(["M", "MM"], function (e, t) { t[O] = g(e) - 1 }), D(["MMM", "MMMM"], function (e, t, n, s) { s = n._locale.monthsParse(e, s, n._strict); null != s ? t[O] = s : m(n).invalidMonth = e }); var Ce = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Ue = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), He = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Fe = k, Le = k; function Ve(e, t) { var n; if (e.isValid()) { if ("string" == typeof t) if (/^\d+$/.test(t)) t = g(t); else if (!u(t = e.localeData().monthsParse(t))) return; n = Math.min(e.date(), We(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n) } } function Ge(e) { return null != e ? (Ve(this, e), f.updateOffset(this, !0), this) : ce(this, "Month") } function Ee() { function e(e, t) { return t.length - e.length } for (var t, n = [], s = [], i = [], r = 0; r < 12; r++)t = l([2e3, r]), n.push(this.monthsShort(t, "")), s.push(this.months(t, "")), i.push(this.months(t, "")), i.push(this.monthsShort(t, "")); for (n.sort(e), s.sort(e), i.sort(e), r = 0; r < 12; r++)n[r] = M(n[r]), s[r] = M(s[r]); for (r = 0; r < 24; r++)i[r] = M(i[r]); this._monthsRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i") } function Ae(e) { return he(e) ? 366 : 365 } s("Y", 0, 0, function () { var e = this.year(); return e <= 9999 ? r(e, 4) : "+" + e }), s(0, ["YY", 2], 0, function () { return this.year() % 100 }), s(0, ["YYYY", 4], 0, "year"), s(0, ["YYYYY", 5], 0, "year"), s(0, ["YYYYYY", 6, !0], 0, "year"), t("year", "y"), n("year", 1), v("Y", De), v("YY", p, w), v("YYYY", ke, _e), v("YYYYY", ve, ye), v("YYYYYY", ve, ye), D(["YYYYY", "YYYYYY"], Y), D("YYYY", function (e, t) { t[Y] = 2 === e.length ? f.parseTwoDigitYear(e) : g(e) }), D("YY", function (e, t) { t[Y] = f.parseTwoDigitYear(e) }), D("Y", function (e, t) { t[Y] = parseInt(e, 10) }), f.parseTwoDigitYear = function (e) { return g(e) + (68 < g(e) ? 1900 : 2e3) }; var Ie = de("FullYear", !0); function je(e, t, n, s, i, r, a) { var o; return e < 100 && 0 <= e ? (o = new Date(e + 400, t, n, s, i, r, a), isFinite(o.getFullYear()) && o.setFullYear(e)) : o = new Date(e, t, n, s, i, r, a), o } function Ze(e) { var t; return e < 100 && 0 <= e ? ((t = Array.prototype.slice.call(arguments))[0] = e + 400, t = new Date(Date.UTC.apply(null, t)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t } function ze(e, t, n) { n = 7 + t - n; return n - (7 + Ze(e, 0, n).getUTCDay() - t) % 7 - 1 } function $e(e, t, n, s, i) { var r, t = 1 + 7 * (t - 1) + (7 + n - s) % 7 + ze(e, s, i), n = t <= 0 ? Ae(r = e - 1) + t : t > Ae(e) ? (r = e + 1, t - Ae(e)) : (r = e, t); return { year: r, dayOfYear: n } } function qe(e, t, n) { var s, i, r = ze(e.year(), t, n), r = Math.floor((e.dayOfYear() - r - 1) / 7) + 1; return r < 1 ? s = r + P(i = e.year() - 1, t, n) : r > P(e.year(), t, n) ? (s = r - P(e.year(), t, n), i = e.year() + 1) : (i = e.year(), s = r), { week: s, year: i } } function P(e, t, n) { var s = ze(e, t, n), t = ze(e + 1, t, n); return (Ae(e) - s + t) / 7 } s("w", ["ww", 2], "wo", "week"), s("W", ["WW", 2], "Wo", "isoWeek"), t("week", "w"), t("isoWeek", "W"), n("week", 5), n("isoWeek", 5), v("w", p), v("ww", p, w), v("W", p), v("WW", p, w), Te(["w", "ww", "W", "WW"], function (e, t, n, s) { t[s.substr(0, 1)] = g(e) }); function Be(e, t) { return e.slice(t, 7).concat(e.slice(0, t)) } s("d", 0, "do", "day"), s("dd", 0, 0, function (e) { return this.localeData().weekdaysMin(this, e) }), s("ddd", 0, 0, function (e) { return this.localeData().weekdaysShort(this, e) }), s("dddd", 0, 0, function (e) { return this.localeData().weekdays(this, e) }), s("e", 0, 0, "weekday"), s("E", 0, 0, "isoWeekday"), t("day", "d"), t("weekday", "e"), t("isoWeekday", "E"), n("day", 11), n("weekday", 11), n("isoWeekday", 11), v("d", p), v("e", p), v("E", p), v("dd", function (e, t) { return t.weekdaysMinRegex(e) }), v("ddd", function (e, t) { return t.weekdaysShortRegex(e) }), v("dddd", function (e, t) { return t.weekdaysRegex(e) }), Te(["dd", "ddd", "dddd"], function (e, t, n, s) { s = n._locale.weekdaysParse(e, s, n._strict); null != s ? t.d = s : m(n).invalidWeekday = e }), Te(["d", "e", "E"], function (e, t, n, s) { t[s] = g(e) }); var Je = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), Qe = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Xe = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ke = k, et = k, tt = k; function nt() { function e(e, t) { return t.length - e.length } for (var t, n, s, i = [], r = [], a = [], o = [], u = 0; u < 7; u++)s = l([2e3, 1]).day(u), t = M(this.weekdaysMin(s, "")), n = M(this.weekdaysShort(s, "")), s = M(this.weekdays(s, "")), i.push(t), r.push(n), a.push(s), o.push(t), o.push(n), o.push(s); i.sort(e), r.sort(e), a.sort(e), o.sort(e), this._weekdaysRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + i.join("|") + ")", "i") } function st() { return this.hours() % 12 || 12 } function it(e, t) { s(e, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), t) }) } function rt(e, t) { return t._meridiemParse } s("H", ["HH", 2], 0, "hour"), s("h", ["hh", 2], 0, st), s("k", ["kk", 2], 0, function () { return this.hours() || 24 }), s("hmm", 0, 0, function () { return "" + st.apply(this) + r(this.minutes(), 2) }), s("hmmss", 0, 0, function () { return "" + st.apply(this) + r(this.minutes(), 2) + r(this.seconds(), 2) }), s("Hmm", 0, 0, function () { return "" + this.hours() + r(this.minutes(), 2) }), s("Hmmss", 0, 0, function () { return "" + this.hours() + r(this.minutes(), 2) + r(this.seconds(), 2) }), it("a", !0), it("A", !1), t("hour", "h"), n("hour", 13), v("a", rt), v("A", rt), v("H", p), v("h", p), v("k", p), v("HH", p, w), v("hh", p, w), v("kk", p, w), v("hmm", ge), v("hmmss", we), v("Hmm", ge), v("Hmmss", we), D(["H", "HH"], x), D(["k", "kk"], function (e, t, n) { e = g(e); t[x] = 24 === e ? 0 : e }), D(["a", "A"], function (e, t, n) { n._isPm = n._locale.isPM(e), n._meridiem = e }), D(["h", "hh"], function (e, t, n) { t[x] = g(e), m(n).bigHour = !0 }), D("hmm", function (e, t, n) { var s = e.length - 2; t[x] = g(e.substr(0, s)), t[T] = g(e.substr(s)), m(n).bigHour = !0 }), D("hmmss", function (e, t, n) { var s = e.length - 4, i = e.length - 2; t[x] = g(e.substr(0, s)), t[T] = g(e.substr(s, 2)), t[N] = g(e.substr(i)), m(n).bigHour = !0 }), D("Hmm", function (e, t, n) { var s = e.length - 2; t[x] = g(e.substr(0, s)), t[T] = g(e.substr(s)) }), D("Hmmss", function (e, t, n) { var s = e.length - 4, i = e.length - 2; t[x] = g(e.substr(0, s)), t[T] = g(e.substr(s, 2)), t[N] = g(e.substr(i)) }); k = de("Hours", !0); var at, ot = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: Ce, monthsShort: Ue, week: { dow: 0, doy: 6 }, weekdays: Je, weekdaysMin: Xe, weekdaysShort: Qe, meridiemParse: /[ap]\.?m?\.?/i }, R = {}, ut = {}; function lt(e) { return e && e.toLowerCase().replace("_", "-") } function ht(e) { for (var t, n, s, i, r = 0; r < e.length;) { for (t = (i = lt(e[r]).split("-")).length, n = (n = lt(e[r + 1])) ? n.split("-") : null; 0 < t;) { if (s = dt(i.slice(0, t).join("-"))) return s; if (n && n.length >= t && function (e, t) { for (var n = Math.min(e.length, t.length), s = 0; s < n; s += 1)if (e[s] !== t[s]) return s; return n }(i, n) >= t - 1) break; t-- } r++ } return at } function dt(t) { var e; if (void 0 === R[t] && "undefined" != typeof module && module && module.exports && null != t.match("^[^/\\\\]*$")) try { e = at._abbr, require("./locale/" + t), ct(e) } catch (e) { R[t] = null } return R[t] } function ct(e, t) { return e && ((t = o(t) ? mt(e) : ft(e, t)) ? at = t : "undefined" != typeof console && console.warn && console.warn("Locale " + e + " not found. Did you forget to load it?")), at._abbr } function ft(e, t) { if (null === t) return delete R[e], null; var n, s = ot; if (t.abbr = e, null != R[e]) Q("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), s = R[e]._config; else if (null != t.parentLocale) if (null != R[t.parentLocale]) s = R[t.parentLocale]._config; else { if (null == (n = dt(t.parentLocale))) return ut[t.parentLocale] || (ut[t.parentLocale] = []), ut[t.parentLocale].push({ name: e, config: t }), null; s = n._config } return R[e] = new K(X(s, t)), ut[e] && ut[e].forEach(function (e) { ft(e.name, e.config) }), ct(e), R[e] } function mt(e) { var t; if (!(e = e && e._locale && e._locale._abbr ? e._locale._abbr : e)) return at; if (!a(e)) { if (t = dt(e)) return t; e = [e] } return ht(e) } function _t(e) { var t = e._a; return t && -2 === m(e).overflow && (t = t[O] < 0 || 11 < t[O] ? O : t[b] < 1 || t[b] > We(t[Y], t[O]) ? b : t[x] < 0 || 24 < t[x] || 24 === t[x] && (0 !== t[T] || 0 !== t[N] || 0 !== t[Ne]) ? x : t[T] < 0 || 59 < t[T] ? T : t[N] < 0 || 59 < t[N] ? N : t[Ne] < 0 || 999 < t[Ne] ? Ne : -1, m(e)._overflowDayOfYear && (t < Y || b < t) && (t = b), m(e)._overflowWeeks && -1 === t && (t = Pe), m(e)._overflowWeekday && -1 === t && (t = Re), m(e).overflow = t), e } var yt = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, gt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, wt = /Z|[+-]\d\d(?::?\d\d)?/, pt = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]], kt = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], vt = /^\/?Date\((-?\d+)/i, Mt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Dt = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 }; function St(e) { var t, n, s, i, r, a, o = e._i, u = yt.exec(o) || gt.exec(o), o = pt.length, l = kt.length; if (u) { for (m(e).iso = !0, t = 0, n = o; t < n; t++)if (pt[t][1].exec(u[1])) { i = pt[t][0], s = !1 !== pt[t][2]; break } if (null == i) e._isValid = !1; else { if (u[3]) { for (t = 0, n = l; t < n; t++)if (kt[t][1].exec(u[3])) { r = (u[2] || " ") + kt[t][0]; break } if (null == r) return void (e._isValid = !1) } if (s || null == r) { if (u[4]) { if (!wt.exec(u[4])) return void (e._isValid = !1); a = "Z" } e._f = i + (r || "") + (a || ""), Tt(e) } else e._isValid = !1 } } else e._isValid = !1 } function Yt(e, t, n, s, i, r) { e = [function (e) { e = parseInt(e, 10); { if (e <= 49) return 2e3 + e; if (e <= 999) return 1900 + e } return e }(e), Ue.indexOf(t), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10)]; return r && e.push(parseInt(r, 10)), e } function Ot(e) { var t, n, s, i, r = Mt.exec(e._i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")); r ? (t = Yt(r[4], r[3], r[2], r[5], r[6], r[7]), n = r[1], s = t, i = e, n && Qe.indexOf(n) !== new Date(s[0], s[1], s[2]).getDay() ? (m(i).weekdayMismatch = !0, i._isValid = !1) : (e._a = t, e._tzm = (n = r[8], s = r[9], i = r[10], n ? Dt[n] : s ? 0 : 60 * (((n = parseInt(i, 10)) - (s = n % 100)) / 100) + s), e._d = Ze.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), m(e).rfc2822 = !0)) : e._isValid = !1 } function bt(e, t, n) { return null != e ? e : null != t ? t : n } function xt(e) { var t, n, s, i, r, a, o, u, l, h, d, c = []; if (!e._d) { for (s = e, i = new Date(f.now()), n = s._useUTC ? [i.getUTCFullYear(), i.getUTCMonth(), i.getUTCDate()] : [i.getFullYear(), i.getMonth(), i.getDate()], e._w && null == e._a[b] && null == e._a[O] && (null != (i = (s = e)._w).GG || null != i.W || null != i.E ? (u = 1, l = 4, r = bt(i.GG, s._a[Y], qe(W(), 1, 4).year), a = bt(i.W, 1), ((o = bt(i.E, 1)) < 1 || 7 < o) && (h = !0)) : (u = s._locale._week.dow, l = s._locale._week.doy, d = qe(W(), u, l), r = bt(i.gg, s._a[Y], d.year), a = bt(i.w, d.week), null != i.d ? ((o = i.d) < 0 || 6 < o) && (h = !0) : null != i.e ? (o = i.e + u, (i.e < 0 || 6 < i.e) && (h = !0)) : o = u), a < 1 || a > P(r, u, l) ? m(s)._overflowWeeks = !0 : null != h ? m(s)._overflowWeekday = !0 : (d = $e(r, a, o, u, l), s._a[Y] = d.year, s._dayOfYear = d.dayOfYear)), null != e._dayOfYear && (i = bt(e._a[Y], n[Y]), (e._dayOfYear > Ae(i) || 0 === e._dayOfYear) && (m(e)._overflowDayOfYear = !0), h = Ze(i, 0, e._dayOfYear), e._a[O] = h.getUTCMonth(), e._a[b] = h.getUTCDate()), t = 0; t < 3 && null == e._a[t]; ++t)e._a[t] = c[t] = n[t]; for (; t < 7; t++)e._a[t] = c[t] = null == e._a[t] ? 2 === t ? 1 : 0 : e._a[t]; 24 === e._a[x] && 0 === e._a[T] && 0 === e._a[N] && 0 === e._a[Ne] && (e._nextDay = !0, e._a[x] = 0), e._d = (e._useUTC ? Ze : je).apply(null, c), r = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[x] = 24), e._w && void 0 !== e._w.d && e._w.d !== r && (m(e).weekdayMismatch = !0) } } function Tt(e) { if (e._f === f.ISO_8601) St(e); else if (e._f === f.RFC_2822) Ot(e); else { e._a = [], m(e).empty = !0; for (var t, n, s, i, r, a = "" + e._i, o = a.length, u = 0, l = ae(e._f, e._locale).match(te) || [], h = l.length, d = 0; d < h; d++)n = l[d], (t = (a.match(Oe(n, e)) || [])[0]) && (0 < (s = a.substr(0, a.indexOf(t))).length && m(e).unusedInput.push(s), a = a.slice(a.indexOf(t) + t.length), u += t.length), ie[n] ? (t ? m(e).empty = !1 : m(e).unusedTokens.push(n), s = n, r = e, null != (i = t) && c(xe, s) && xe[s](i, r._a, r, s)) : e._strict && !t && m(e).unusedTokens.push(n); m(e).charsLeftOver = o - u, 0 < a.length && m(e).unusedInput.push(a), e._a[x] <= 12 && !0 === m(e).bigHour && 0 < e._a[x] && (m(e).bigHour = void 0), m(e).parsedDateParts = e._a.slice(0), m(e).meridiem = e._meridiem, e._a[x] = function (e, t, n) { if (null == n) return t; return null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? ((e = e.isPM(n)) && t < 12 && (t += 12), t = e || 12 !== t ? t : 0) : t }(e._locale, e._a[x], e._meridiem), null !== (o = m(e).era) && (e._a[Y] = e._locale.erasConvertYear(o, e._a[Y])), xt(e), _t(e) } } function Nt(e) { var t, n, s, i = e._i, r = e._f; if (e._locale = e._locale || mt(e._l), null === i || void 0 === r && "" === i) return I({ nullInput: !0 }); if ("string" == typeof i && (e._i = i = e._locale.preparse(i)), h(i)) return new q(_t(i)); if (V(i)) e._d = i; else if (a(r)) !function (e) { var t, n, s, i, r, a, o = !1, u = e._f.length; if (0 === u) return m(e).invalidFormat = !0, e._d = new Date(NaN); for (i = 0; i < u; i++)r = 0, a = !1, t = $({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], Tt(t), A(t) && (a = !0), r = (r += m(t).charsLeftOver) + 10 * m(t).unusedTokens.length, m(t).score = r, o ? r < s && (s = r, n = t) : (null == s || r < s || a) && (s = r, n = t, a && (o = !0)); E(e, n || t) }(e); else if (r) Tt(e); else if (o(r = (i = e)._i)) i._d = new Date(f.now()); else V(r) ? i._d = new Date(r.valueOf()) : "string" == typeof r ? (n = i, null !== (t = vt.exec(n._i)) ? n._d = new Date(+t[1]) : (St(n), !1 === n._isValid && (delete n._isValid, Ot(n), !1 === n._isValid && (delete n._isValid, n._strict ? n._isValid = !1 : f.createFromInputFallback(n))))) : a(r) ? (i._a = G(r.slice(0), function (e) { return parseInt(e, 10) }), xt(i)) : F(r) ? (t = i)._d || (s = void 0 === (n = ue(t._i)).day ? n.date : n.day, t._a = G([n.year, n.month, s, n.hour, n.minute, n.second, n.millisecond], function (e) { return e && parseInt(e, 10) }), xt(t)) : u(r) ? i._d = new Date(r) : f.createFromInputFallback(i); return A(e) || (e._d = null), e } function Pt(e, t, n, s, i) { var r = {}; return !0 !== t && !1 !== t || (s = t, t = void 0), !0 !== n && !1 !== n || (s = n, n = void 0), (F(e) && L(e) || a(e) && 0 === e.length) && (e = void 0), r._isAMomentObject = !0, r._useUTC = r._isUTC = i, r._l = n, r._i = e, r._f = t, r._strict = s, (i = new q(_t(Nt(i = r))))._nextDay && (i.add(1, "d"), i._nextDay = void 0), i } function W(e, t, n, s) { return Pt(e, t, n, s, !1) } f.createFromInputFallback = e("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (e) { e._d = new Date(e._i + (e._useUTC ? " UTC" : "")) }), f.ISO_8601 = function () { }, f.RFC_2822 = function () { }; ge = e("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () { var e = W.apply(null, arguments); return this.isValid() && e.isValid() ? e < this ? this : e : I() }), we = e("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () { var e = W.apply(null, arguments); return this.isValid() && e.isValid() ? this < e ? this : e : I() }); function Rt(e, t) { var n, s; if (!(t = 1 === t.length && a(t[0]) ? t[0] : t).length) return W(); for (n = t[0], s = 1; s < t.length; ++s)t[s].isValid() && !t[s][e](n) || (n = t[s]); return n } var Wt = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"]; function Ct(e) { var e = ue(e), t = e.year || 0, n = e.quarter || 0, s = e.month || 0, i = e.week || e.isoWeek || 0, r = e.day || 0, a = e.hour || 0, o = e.minute || 0, u = e.second || 0, l = e.millisecond || 0; this._isValid = function (e) { var t, n, s = !1, i = Wt.length; for (t in e) if (c(e, t) && (-1 === S.call(Wt, t) || null != e[t] && isNaN(e[t]))) return !1; for (n = 0; n < i; ++n)if (e[Wt[n]]) { if (s) return !1; parseFloat(e[Wt[n]]) !== g(e[Wt[n]]) && (s = !0) } return !0 }(e), this._milliseconds = +l + 1e3 * u + 6e4 * o + 1e3 * a * 60 * 60, this._days = +r + 7 * i, this._months = +s + 3 * n + 12 * t, this._data = {}, this._locale = mt(), this._bubble() } function Ut(e) { return e instanceof Ct } function Ht(e) { return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e) } function Ft(e, n) { s(e, 0, 0, function () { var e = this.utcOffset(), t = "+"; return e < 0 && (e = -e, t = "-"), t + r(~~(e / 60), 2) + n + r(~~e % 60, 2) }) } Ft("Z", ":"), Ft("ZZ", ""), v("Z", Ye), v("ZZ", Ye), D(["Z", "ZZ"], function (e, t, n) { n._useUTC = !0, n._tzm = Vt(Ye, e) }); var Lt = /([\+\-]|\d\d)/gi; function Vt(e, t) { var t = (t || "").match(e); return null === t ? null : 0 === (t = 60 * (e = ((t[t.length - 1] || []) + "").match(Lt) || ["-", 0, 0])[1] + g(e[2])) ? 0 : "+" === e[0] ? t : -t } function Gt(e, t) { var n; return t._isUTC ? (t = t.clone(), n = (h(e) || V(e) ? e : W(e)).valueOf() - t.valueOf(), t._d.setTime(t._d.valueOf() + n), f.updateOffset(t, !1), t) : W(e).local() } function Et(e) { return -Math.round(e._d.getTimezoneOffset()) } function At() { return !!this.isValid() && (this._isUTC && 0 === this._offset) } f.updateOffset = function () { }; var It = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, jt = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/; function C(e, t) { var n, s = e, i = null; return Ut(e) ? s = { ms: e._milliseconds, d: e._days, M: e._months } : u(e) || !isNaN(+e) ? (s = {}, t ? s[t] = +e : s.milliseconds = +e) : (i = It.exec(e)) ? (n = "-" === i[1] ? -1 : 1, s = { y: 0, d: g(i[b]) * n, h: g(i[x]) * n, m: g(i[T]) * n, s: g(i[N]) * n, ms: g(Ht(1e3 * i[Ne])) * n }) : (i = jt.exec(e)) ? (n = "-" === i[1] ? -1 : 1, s = { y: Zt(i[2], n), M: Zt(i[3], n), w: Zt(i[4], n), d: Zt(i[5], n), h: Zt(i[6], n), m: Zt(i[7], n), s: Zt(i[8], n) }) : null == s ? s = {} : "object" == typeof s && ("from" in s || "to" in s) && (t = function (e, t) { var n; if (!e.isValid() || !t.isValid()) return { milliseconds: 0, months: 0 }; t = Gt(t, e), e.isBefore(t) ? n = zt(e, t) : ((n = zt(t, e)).milliseconds = -n.milliseconds, n.months = -n.months); return n }(W(s.from), W(s.to)), (s = {}).ms = t.milliseconds, s.M = t.months), i = new Ct(s), Ut(e) && c(e, "_locale") && (i._locale = e._locale), Ut(e) && c(e, "_isValid") && (i._isValid = e._isValid), i } function Zt(e, t) { e = e && parseFloat(e.replace(",", ".")); return (isNaN(e) ? 0 : e) * t } function zt(e, t) { var n = {}; return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n } function $t(s, i) { return function (e, t) { var n; return null === t || isNaN(+t) || (Q(i, "moment()." + i + "(period, number) is deprecated. Please use moment()." + i + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), n = e, e = t, t = n), qt(this, C(e, t), s), this } } function qt(e, t, n, s) { var i = t._milliseconds, r = Ht(t._days), t = Ht(t._months); e.isValid() && (s = null == s || s, t && Ve(e, ce(e, "Month") + t * n), r && fe(e, "Date", ce(e, "Date") + r * n), i && e._d.setTime(e._d.valueOf() + i * n), s && f.updateOffset(e, r || t)) } C.fn = Ct.prototype, C.invalid = function () { return C(NaN) }; Ce = $t(1, "add"), Je = $t(-1, "subtract"); function Bt(e) { return "string" == typeof e || e instanceof String } function Jt(e) { return h(e) || V(e) || Bt(e) || u(e) || function (t) { var e = a(t), n = !1; e && (n = 0 === t.filter(function (e) { return !u(e) && Bt(t) }).length); return e && n }(e) || function (e) { var t, n, s = F(e) && !L(e), i = !1, r = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], a = r.length; for (t = 0; t < a; t += 1)n = r[t], i = i || c(e, n); return s && i }(e) || null == e } function Qt(e, t) { if (e.date() < t.date()) return -Qt(t, e); var n = 12 * (t.year() - e.year()) + (t.month() - e.month()), s = e.clone().add(n, "months"), t = t - s < 0 ? (t - s) / (s - e.clone().add(n - 1, "months")) : (t - s) / (e.clone().add(1 + n, "months") - s); return -(n + t) || 0 } function Xt(e) { return void 0 === e ? this._locale._abbr : (null != (e = mt(e)) && (this._locale = e), this) } f.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", f.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]"; Xe = e("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (e) { return void 0 === e ? this.localeData() : this.locale(e) }); function Kt() { return this._locale } var en = 126227808e5; function tn(e, t) { return (e % t + t) % t } function nn(e, t, n) { return e < 100 && 0 <= e ? new Date(e + 400, t, n) - en : new Date(e, t, n).valueOf() } function sn(e, t, n) { return e < 100 && 0 <= e ? Date.UTC(e + 400, t, n) - en : Date.UTC(e, t, n) } function rn(e, t) { return t.erasAbbrRegex(e) } function an() { for (var e = [], t = [], n = [], s = [], i = this.eras(), r = 0, a = i.length; r < a; ++r)t.push(M(i[r].name)), e.push(M(i[r].abbr)), n.push(M(i[r].narrow)), s.push(M(i[r].name)), s.push(M(i[r].abbr)), s.push(M(i[r].narrow)); this._erasRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + n.join("|") + ")", "i") } function on(e, t) { s(0, [e, e.length], 0, t) } function un(e, t, n, s, i) { var r; return null == e ? qe(this, s, i).year : (r = P(e, s, i), function (e, t, n, s, i) { e = $e(e, t, n, s, i), t = Ze(e.year, 0, e.dayOfYear); return this.year(t.getUTCFullYear()), this.month(t.getUTCMonth()), this.date(t.getUTCDate()), this }.call(this, e, t = r < t ? r : t, n, s, i)) } s("N", 0, 0, "eraAbbr"), s("NN", 0, 0, "eraAbbr"), s("NNN", 0, 0, "eraAbbr"), s("NNNN", 0, 0, "eraName"), s("NNNNN", 0, 0, "eraNarrow"), s("y", ["y", 1], "yo", "eraYear"), s("y", ["yy", 2], 0, "eraYear"), s("y", ["yyy", 3], 0, "eraYear"), s("y", ["yyyy", 4], 0, "eraYear"), v("N", rn), v("NN", rn), v("NNN", rn), v("NNNN", function (e, t) { return t.erasNameRegex(e) }), v("NNNNN", function (e, t) { return t.erasNarrowRegex(e) }), D(["N", "NN", "NNN", "NNNN", "NNNNN"], function (e, t, n, s) { s = n._locale.erasParse(e, s, n._strict); s ? m(n).era = s : m(n).invalidEra = e }), v("y", Me), v("yy", Me), v("yyy", Me), v("yyyy", Me), v("yo", function (e, t) { return t._eraYearOrdinalRegex || Me }), D(["y", "yy", "yyy", "yyyy"], Y), D(["yo"], function (e, t, n, s) { var i; n._locale._eraYearOrdinalRegex && (i = e.match(n._locale._eraYearOrdinalRegex)), n._locale.eraYearOrdinalParse ? t[Y] = n._locale.eraYearOrdinalParse(e, i) : t[Y] = parseInt(e, 10) }), s(0, ["gg", 2], 0, function () { return this.weekYear() % 100 }), s(0, ["GG", 2], 0, function () { return this.isoWeekYear() % 100 }), on("gggg", "weekYear"), on("ggggg", "weekYear"), on("GGGG", "isoWeekYear"), on("GGGGG", "isoWeekYear"), t("weekYear", "gg"), t("isoWeekYear", "GG"), n("weekYear", 1), n("isoWeekYear", 1), v("G", De), v("g", De), v("GG", p, w), v("gg", p, w), v("GGGG", ke, _e), v("gggg", ke, _e), v("GGGGG", ve, ye), v("ggggg", ve, ye), Te(["gggg", "ggggg", "GGGG", "GGGGG"], function (e, t, n, s) { t[s.substr(0, 2)] = g(e) }), Te(["gg", "GG"], function (e, t, n, s) { t[s] = f.parseTwoDigitYear(e) }), s("Q", 0, "Qo", "quarter"), t("quarter", "Q"), n("quarter", 7), v("Q", i), D("Q", function (e, t) { t[O] = 3 * (g(e) - 1) }), s("D", ["DD", 2], "Do", "date"), t("date", "D"), n("date", 9), v("D", p), v("DD", p, w), v("Do", function (e, t) { return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient }), D(["D", "DD"], b), D("Do", function (e, t) { t[b] = g(e.match(p)[0]) }); ke = de("Date", !0); s("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), t("dayOfYear", "DDD"), n("dayOfYear", 4), v("DDD", pe), v("DDDD", me), D(["DDD", "DDDD"], function (e, t, n) { n._dayOfYear = g(e) }), s("m", ["mm", 2], 0, "minute"), t("minute", "m"), n("minute", 14), v("m", p), v("mm", p, w), D(["m", "mm"], T); var ln, _e = de("Minutes", !1), ve = (s("s", ["ss", 2], 0, "second"), t("second", "s"), n("second", 15), v("s", p), v("ss", p, w), D(["s", "ss"], N), de("Seconds", !1)); for (s("S", 0, 0, function () { return ~~(this.millisecond() / 100) }), s(0, ["SS", 2], 0, function () { return ~~(this.millisecond() / 10) }), s(0, ["SSS", 3], 0, "millisecond"), s(0, ["SSSS", 4], 0, function () { return 10 * this.millisecond() }), s(0, ["SSSSS", 5], 0, function () { return 100 * this.millisecond() }), s(0, ["SSSSSS", 6], 0, function () { return 1e3 * this.millisecond() }), s(0, ["SSSSSSS", 7], 0, function () { return 1e4 * this.millisecond() }), s(0, ["SSSSSSSS", 8], 0, function () { return 1e5 * this.millisecond() }), s(0, ["SSSSSSSSS", 9], 0, function () { return 1e6 * this.millisecond() }), t("millisecond", "ms"), n("millisecond", 16), v("S", pe, i), v("SS", pe, w), v("SSS", pe, me), ln = "SSSS"; ln.length <= 9; ln += "S")v(ln, Me); function hn(e, t) { t[Ne] = g(1e3 * ("0." + e)) } for (ln = "S"; ln.length <= 9; ln += "S")D(ln, hn); ye = de("Milliseconds", !1), s("z", 0, 0, "zoneAbbr"), s("zz", 0, 0, "zoneName"); i = q.prototype; function dn(e) { return e } i.add = Ce, i.calendar = function (e, t) { 1 === arguments.length && (arguments[0] ? Jt(arguments[0]) ? (e = arguments[0], t = void 0) : function (e) { for (var t = F(e) && !L(e), n = !1, s = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], i = 0; i < s.length; i += 1)n = n || c(e, s[i]); return t && n }(arguments[0]) && (t = arguments[0], e = void 0) : t = e = void 0); var e = e || W(), n = Gt(e, this).startOf("day"), n = f.calendarFormat(this, n) || "sameElse", t = t && (d(t[n]) ? t[n].call(this, e) : t[n]); return this.format(t || this.localeData().calendar(n, this, W(e))) }, i.clone = function () { return new q(this) }, i.diff = function (e, t, n) { var s, i, r; if (!this.isValid()) return NaN; if (!(s = Gt(e, this)).isValid()) return NaN; switch (i = 6e4 * (s.utcOffset() - this.utcOffset()), t = _(t)) { case "year": r = Qt(this, s) / 12; break; case "month": r = Qt(this, s); break; case "quarter": r = Qt(this, s) / 3; break; case "second": r = (this - s) / 1e3; break; case "minute": r = (this - s) / 6e4; break; case "hour": r = (this - s) / 36e5; break; case "day": r = (this - s - i) / 864e5; break; case "week": r = (this - s - i) / 6048e5; break; default: r = this - s }return n ? r : y(r) }, i.endOf = function (e) { var t, n; if (void 0 === (e = _(e)) || "millisecond" === e || !this.isValid()) return this; switch (n = this._isUTC ? sn : nn, e) { case "year": t = n(this.year() + 1, 0, 1) - 1; break; case "quarter": t = n(this.year(), this.month() - this.month() % 3 + 3, 1) - 1; break; case "month": t = n(this.year(), this.month() + 1, 1) - 1; break; case "week": t = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1; break; case "isoWeek": t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1; break; case "day": case "date": t = n(this.year(), this.month(), this.date() + 1) - 1; break; case "hour": t = this._d.valueOf(), t += 36e5 - tn(t + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1; break; case "minute": t = this._d.valueOf(), t += 6e4 - tn(t, 6e4) - 1; break; case "second": t = this._d.valueOf(), t += 1e3 - tn(t, 1e3) - 1; break }return this._d.setTime(t), f.updateOffset(this, !0), this }, i.format = function (e) { return e = e || (this.isUtc() ? f.defaultFormatUtc : f.defaultFormat), e = re(this, e), this.localeData().postformat(e) }, i.from = function (e, t) { return this.isValid() && (h(e) && e.isValid() || W(e).isValid()) ? C({ to: this, from: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate() }, i.fromNow = function (e) { return this.from(W(), e) }, i.to = function (e, t) { return this.isValid() && (h(e) && e.isValid() || W(e).isValid()) ? C({ from: this, to: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate() }, i.toNow = function (e) { return this.to(W(), e) }, i.get = function (e) { return d(this[e = _(e)]) ? this[e]() : this }, i.invalidAt = function () { return m(this).overflow }, i.isAfter = function (e, t) { return e = h(e) ? e : W(e), !(!this.isValid() || !e.isValid()) && ("millisecond" === (t = _(t) || "millisecond") ? this.valueOf() > e.valueOf() : e.valueOf() < this.clone().startOf(t).valueOf()) }, i.isBefore = function (e, t) { return e = h(e) ? e : W(e), !(!this.isValid() || !e.isValid()) && ("millisecond" === (t = _(t) || "millisecond") ? this.valueOf() < e.valueOf() : this.clone().endOf(t).valueOf() < e.valueOf()) }, i.isBetween = function (e, t, n, s) { return e = h(e) ? e : W(e), t = h(t) ? t : W(t), !!(this.isValid() && e.isValid() && t.isValid()) && (("(" === (s = s || "()")[0] ? this.isAfter(e, n) : !this.isBefore(e, n)) && (")" === s[1] ? this.isBefore(t, n) : !this.isAfter(t, n))) }, i.isSame = function (e, t) { var e = h(e) ? e : W(e); return !(!this.isValid() || !e.isValid()) && ("millisecond" === (t = _(t) || "millisecond") ? this.valueOf() === e.valueOf() : (e = e.valueOf(), this.clone().startOf(t).valueOf() <= e && e <= this.clone().endOf(t).valueOf())) }, i.isSameOrAfter = function (e, t) { return this.isSame(e, t) || this.isAfter(e, t) }, i.isSameOrBefore = function (e, t) { return this.isSame(e, t) || this.isBefore(e, t) }, i.isValid = function () { return A(this) }, i.lang = Xe, i.locale = Xt, i.localeData = Kt, i.max = we, i.min = ge, i.parsingFlags = function () { return E({}, m(this)) }, i.set = function (e, t) { if ("object" == typeof e) for (var n = function (e) { var t, n = []; for (t in e) c(e, t) && n.push({ unit: t, priority: le[t] }); return n.sort(function (e, t) { return e.priority - t.priority }), n }(e = ue(e)), s = n.length, i = 0; i < s; i++)this[n[i].unit](e[n[i].unit]); else if (d(this[e = _(e)])) return this[e](t); return this }, i.startOf = function (e) { var t, n; if (void 0 === (e = _(e)) || "millisecond" === e || !this.isValid()) return this; switch (n = this._isUTC ? sn : nn, e) { case "year": t = n(this.year(), 0, 1); break; case "quarter": t = n(this.year(), this.month() - this.month() % 3, 1); break; case "month": t = n(this.year(), this.month(), 1); break; case "week": t = n(this.year(), this.month(), this.date() - this.weekday()); break; case "isoWeek": t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1)); break; case "day": case "date": t = n(this.year(), this.month(), this.date()); break; case "hour": t = this._d.valueOf(), t -= tn(t + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5); break; case "minute": t = this._d.valueOf(), t -= tn(t, 6e4); break; case "second": t = this._d.valueOf(), t -= tn(t, 1e3); break }return this._d.setTime(t), f.updateOffset(this, !0), this }, i.subtract = Je, i.toArray = function () { var e = this; return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()] }, i.toObject = function () { var e = this; return { years: e.year(), months: e.month(), date: e.date(), hours: e.hours(), minutes: e.minutes(), seconds: e.seconds(), milliseconds: e.milliseconds() } }, i.toDate = function () { return new Date(this.valueOf()) }, i.toISOString = function (e) { if (!this.isValid()) return null; var t = (e = !0 !== e) ? this.clone().utc() : this; return t.year() < 0 || 9999 < t.year() ? re(t, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : d(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", re(t, "Z")) : re(t, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ") }, i.inspect = function () { if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)"; var e, t = "moment", n = ""; return this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", n = "Z"), t = "[" + t + '("]', e = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", this.format(t + e + "-MM-DD[T]HH:mm:ss.SSS" + (n + '[")]')) }, "undefined" != typeof Symbol && null != Symbol.for && (i[Symbol.for("nodejs.util.inspect.custom")] = function () { return "Moment<" + this.format() + ">" }), i.toJSON = function () { return this.isValid() ? this.toISOString() : null }, i.toString = function () { return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ") }, i.unix = function () { return Math.floor(this.valueOf() / 1e3) }, i.valueOf = function () { return this._d.valueOf() - 6e4 * (this._offset || 0) }, i.creationData = function () { return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict } }, i.eraName = function () { for (var e, t = this.localeData().eras(), n = 0, s = t.length; n < s; ++n) { if (e = this.clone().startOf("day").valueOf(), t[n].since <= e && e <= t[n].until) return t[n].name; if (t[n].until <= e && e <= t[n].since) return t[n].name } return "" }, i.eraNarrow = function () { for (var e, t = this.localeData().eras(), n = 0, s = t.length; n < s; ++n) { if (e = this.clone().startOf("day").valueOf(), t[n].since <= e && e <= t[n].until) return t[n].narrow; if (t[n].until <= e && e <= t[n].since) return t[n].narrow } return "" }, i.eraAbbr = function () { for (var e, t = this.localeData().eras(), n = 0, s = t.length; n < s; ++n) { if (e = this.clone().startOf("day").valueOf(), t[n].since <= e && e <= t[n].until) return t[n].abbr; if (t[n].until <= e && e <= t[n].since) return t[n].abbr } return "" }, i.eraYear = function () { for (var e, t, n = this.localeData().eras(), s = 0, i = n.length; s < i; ++s)if (e = n[s].since <= n[s].until ? 1 : -1, t = this.clone().startOf("day").valueOf(), n[s].since <= t && t <= n[s].until || n[s].until <= t && t <= n[s].since) return (this.year() - f(n[s].since).year()) * e + n[s].offset; return this.year() }, i.year = Ie, i.isLeapYear = function () { return he(this.year()) }, i.weekYear = function (e) { return un.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy) }, i.isoWeekYear = function (e) { return un.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4) }, i.quarter = i.quarters = function (e) { return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3) }, i.month = Ge, i.daysInMonth = function () { return We(this.year(), this.month()) }, i.week = i.weeks = function (e) { var t = this.localeData().week(this); return null == e ? t : this.add(7 * (e - t), "d") }, i.isoWeek = i.isoWeeks = function (e) { var t = qe(this, 1, 4).week; return null == e ? t : this.add(7 * (e - t), "d") }, i.weeksInYear = function () { var e = this.localeData()._week; return P(this.year(), e.dow, e.doy) }, i.weeksInWeekYear = function () { var e = this.localeData()._week; return P(this.weekYear(), e.dow, e.doy) }, i.isoWeeksInYear = function () { return P(this.year(), 1, 4) }, i.isoWeeksInISOWeekYear = function () { return P(this.isoWeekYear(), 1, 4) }, i.date = ke, i.day = i.days = function (e) { if (!this.isValid()) return null != e ? this : NaN; var t, n, s = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return null != e ? (t = e, n = this.localeData(), e = "string" != typeof t ? t : isNaN(t) ? "number" == typeof (t = n.weekdaysParse(t)) ? t : null : parseInt(t, 10), this.add(e - s, "d")) : s }, i.weekday = function (e) { if (!this.isValid()) return null != e ? this : NaN; var t = (this.day() + 7 - this.localeData()._week.dow) % 7; return null == e ? t : this.add(e - t, "d") }, i.isoWeekday = function (e) { return this.isValid() ? null != e ? (t = e, n = this.localeData(), n = "string" == typeof t ? n.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t, this.day(this.day() % 7 ? n : n - 7)) : this.day() || 7 : null != e ? this : NaN; var t, n }, i.dayOfYear = function (e) { var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1; return null == e ? t : this.add(e - t, "d") }, i.hour = i.hours = k, i.minute = i.minutes = _e, i.second = i.seconds = ve, i.millisecond = i.milliseconds = ye, i.utcOffset = function (e, t, n) { var s, i = this._offset || 0; if (!this.isValid()) return null != e ? this : NaN; if (null == e) return this._isUTC ? i : Et(this); if ("string" == typeof e) { if (null === (e = Vt(Ye, e))) return this } else Math.abs(e) < 16 && !n && (e *= 60); return !this._isUTC && t && (s = Et(this)), this._offset = e, this._isUTC = !0, null != s && this.add(s, "m"), i !== e && (!t || this._changeInProgress ? qt(this, C(e - i, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, f.updateOffset(this, !0), this._changeInProgress = null)), this }, i.utc = function (e) { return this.utcOffset(0, e) }, i.local = function (e) { return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Et(this), "m")), this }, i.parseZone = function () { var e; return null != this._tzm ? this.utcOffset(this._tzm, !1, !0) : "string" == typeof this._i && (null != (e = Vt(Se, this._i)) ? this.utcOffset(e) : this.utcOffset(0, !0)), this }, i.hasAlignedHourOffset = function (e) { return !!this.isValid() && (e = e ? W(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0) }, i.isDST = function () { return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset() }, i.isLocal = function () { return !!this.isValid() && !this._isUTC }, i.isUtcOffset = function () { return !!this.isValid() && this._isUTC }, i.isUtc = At, i.isUTC = At, i.zoneAbbr = function () { return this._isUTC ? "UTC" : "" }, i.zoneName = function () { return this._isUTC ? "Coordinated Universal Time" : "" }, i.dates = e("dates accessor is deprecated. Use date instead.", ke), i.months = e("months accessor is deprecated. Use month instead", Ge), i.years = e("years accessor is deprecated. Use year instead", Ie), i.zone = e("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (e, t) { return null != e ? (this.utcOffset(e = "string" != typeof e ? -e : e, t), this) : -this.utcOffset() }), i.isDSTShifted = e("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () { if (!o(this._isDSTShifted)) return this._isDSTShifted; var e, t = {}; return $(t, this), (t = Nt(t))._a ? (e = (t._isUTC ? l : W)(t._a), this._isDSTShifted = this.isValid() && 0 < function (e, t, n) { for (var s = Math.min(e.length, t.length), i = Math.abs(e.length - t.length), r = 0, a = 0; a < s; a++)(n && e[a] !== t[a] || !n && g(e[a]) !== g(t[a])) && r++; return r + i }(t._a, e.toArray())) : this._isDSTShifted = !1, this._isDSTShifted }); w = K.prototype; function cn(e, t, n, s) { var i = mt(), s = l().set(s, t); return i[n](s, e) } function fn(e, t, n) { if (u(e) && (t = e, e = void 0), e = e || "", null != t) return cn(e, t, n, "month"); for (var s = [], i = 0; i < 12; i++)s[i] = cn(e, i, n, "month"); return s } function mn(e, t, n, s) { t = ("boolean" == typeof e ? u(t) && (n = t, t = void 0) : (t = e, e = !1, u(n = t) && (n = t, t = void 0)), t || ""); var i, r = mt(), a = e ? r._week.dow : 0, o = []; if (null != n) return cn(t, (n + a) % 7, s, "day"); for (i = 0; i < 7; i++)o[i] = cn(t, (i + a) % 7, s, "day"); return o } w.calendar = function (e, t, n) { return d(e = this._calendar[e] || this._calendar.sameElse) ? e.call(t, n) : e }, w.longDateFormat = function (e) { var t = this._longDateFormat[e], n = this._longDateFormat[e.toUpperCase()]; return t || !n ? t : (this._longDateFormat[e] = n.match(te).map(function (e) { return "MMMM" === e || "MM" === e || "DD" === e || "dddd" === e ? e.slice(1) : e }).join(""), this._longDateFormat[e]) }, w.invalidDate = function () { return this._invalidDate }, w.ordinal = function (e) { return this._ordinal.replace("%d", e) }, w.preparse = dn, w.postformat = dn, w.relativeTime = function (e, t, n, s) { var i = this._relativeTime[n]; return d(i) ? i(e, t, n, s) : i.replace(/%d/i, e) }, w.pastFuture = function (e, t) { return d(e = this._relativeTime[0 < e ? "future" : "past"]) ? e(t) : e.replace(/%s/i, t) }, w.set = function (e) { var t, n; for (n in e) c(e, n) && (d(t = e[n]) ? this[n] = t : this["_" + n] = t); this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source) }, w.eras = function (e, t) { for (var n, s = this._eras || mt("en")._eras, i = 0, r = s.length; i < r; ++i) { switch (typeof s[i].since) { case "string": n = f(s[i].since).startOf("day"), s[i].since = n.valueOf(); break }switch (typeof s[i].until) { case "undefined": s[i].until = 1 / 0; break; case "string": n = f(s[i].until).startOf("day").valueOf(), s[i].until = n.valueOf(); break } } return s }, w.erasParse = function (e, t, n) { var s, i, r, a, o, u = this.eras(); for (e = e.toUpperCase(), s = 0, i = u.length; s < i; ++s)if (r = u[s].name.toUpperCase(), a = u[s].abbr.toUpperCase(), o = u[s].narrow.toUpperCase(), n) switch (t) { case "N": case "NN": case "NNN": if (a === e) return u[s]; break; case "NNNN": if (r === e) return u[s]; break; case "NNNNN": if (o === e) return u[s]; break } else if (0 <= [r, a, o].indexOf(e)) return u[s] }, w.erasConvertYear = function (e, t) { var n = e.since <= e.until ? 1 : -1; return void 0 === t ? f(e.since).year() : f(e.since).year() + (t - e.offset) * n }, w.erasAbbrRegex = function (e) { return c(this, "_erasAbbrRegex") || an.call(this), e ? this._erasAbbrRegex : this._erasRegex }, w.erasNameRegex = function (e) { return c(this, "_erasNameRegex") || an.call(this), e ? this._erasNameRegex : this._erasRegex }, w.erasNarrowRegex = function (e) { return c(this, "_erasNarrowRegex") || an.call(this), e ? this._erasNarrowRegex : this._erasRegex }, w.months = function (e, t) { return e ? (a(this._months) ? this._months : this._months[(this._months.isFormat || He).test(t) ? "format" : "standalone"])[e.month()] : a(this._months) ? this._months : this._months.standalone }, w.monthsShort = function (e, t) { return e ? (a(this._monthsShort) ? this._monthsShort : this._monthsShort[He.test(t) ? "format" : "standalone"])[e.month()] : a(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone }, w.monthsParse = function (e, t, n) { var s, i; if (this._monthsParseExact) return function (e, t, n) { var s, i, r, e = e.toLocaleLowerCase(); if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s)r = l([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[s] = this.months(r, "").toLocaleLowerCase(); return n ? "MMM" === t ? -1 !== (i = S.call(this._shortMonthsParse, e)) ? i : null : -1 !== (i = S.call(this._longMonthsParse, e)) ? i : null : "MMM" === t ? -1 !== (i = S.call(this._shortMonthsParse, e)) || -1 !== (i = S.call(this._longMonthsParse, e)) ? i : null : -1 !== (i = S.call(this._longMonthsParse, e)) || -1 !== (i = S.call(this._shortMonthsParse, e)) ? i : null }.call(this, e, t, n); for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) { if (i = l([2e3, s]), n && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[s] || (i = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[s] = new RegExp(i.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[s].test(e)) return s; if (n && "MMM" === t && this._shortMonthsParse[s].test(e)) return s; if (!n && this._monthsParse[s].test(e)) return s } }, w.monthsRegex = function (e) { return this._monthsParseExact ? (c(this, "_monthsRegex") || Ee.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (c(this, "_monthsRegex") || (this._monthsRegex = Le), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex) }, w.monthsShortRegex = function (e) { return this._monthsParseExact ? (c(this, "_monthsRegex") || Ee.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (c(this, "_monthsShortRegex") || (this._monthsShortRegex = Fe), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex) }, w.week = function (e) { return qe(e, this._week.dow, this._week.doy).week }, w.firstDayOfYear = function () { return this._week.doy }, w.firstDayOfWeek = function () { return this._week.dow }, w.weekdays = function (e, t) { return t = a(this._weekdays) ? this._weekdays : this._weekdays[e && !0 !== e && this._weekdays.isFormat.test(t) ? "format" : "standalone"], !0 === e ? Be(t, this._week.dow) : e ? t[e.day()] : t }, w.weekdaysMin = function (e) { return !0 === e ? Be(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin }, w.weekdaysShort = function (e) { return !0 === e ? Be(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort }, w.weekdaysParse = function (e, t, n) { var s, i; if (this._weekdaysParseExact) return function (e, t, n) { var s, i, r, e = e.toLocaleLowerCase(); if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s)r = l([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(r, "").toLocaleLowerCase(); return n ? "dddd" === t ? -1 !== (i = S.call(this._weekdaysParse, e)) ? i : null : "ddd" === t ? -1 !== (i = S.call(this._shortWeekdaysParse, e)) ? i : null : -1 !== (i = S.call(this._minWeekdaysParse, e)) ? i : null : "dddd" === t ? -1 !== (i = S.call(this._weekdaysParse, e)) || -1 !== (i = S.call(this._shortWeekdaysParse, e)) || -1 !== (i = S.call(this._minWeekdaysParse, e)) ? i : null : "ddd" === t ? -1 !== (i = S.call(this._shortWeekdaysParse, e)) || -1 !== (i = S.call(this._weekdaysParse, e)) || -1 !== (i = S.call(this._minWeekdaysParse, e)) ? i : null : -1 !== (i = S.call(this._minWeekdaysParse, e)) || -1 !== (i = S.call(this._weekdaysParse, e)) || -1 !== (i = S.call(this._shortWeekdaysParse, e)) ? i : null }.call(this, e, t, n); for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) { if (i = l([2e3, 1]).day(s), n && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp("^" + this.weekdays(i, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[s] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[s] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[s] || (i = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[s] = new RegExp(i.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[s].test(e)) return s; if (n && "ddd" === t && this._shortWeekdaysParse[s].test(e)) return s; if (n && "dd" === t && this._minWeekdaysParse[s].test(e)) return s; if (!n && this._weekdaysParse[s].test(e)) return s } }, w.weekdaysRegex = function (e) { return this._weekdaysParseExact ? (c(this, "_weekdaysRegex") || nt.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (c(this, "_weekdaysRegex") || (this._weekdaysRegex = Ke), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex) }, w.weekdaysShortRegex = function (e) { return this._weekdaysParseExact ? (c(this, "_weekdaysRegex") || nt.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (c(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = et), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) }, w.weekdaysMinRegex = function (e) { return this._weekdaysParseExact ? (c(this, "_weekdaysRegex") || nt.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (c(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = tt), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) }, w.isPM = function (e) { return "p" === (e + "").toLowerCase().charAt(0) }, w.meridiem = function (e, t, n) { return 11 < e ? n ? "pm" : "PM" : n ? "am" : "AM" }, ct("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (e) { var t = e % 10; return e + (1 === g(e % 100 / 10) ? "th" : 1 == t ? "st" : 2 == t ? "nd" : 3 == t ? "rd" : "th") } }), f.lang = e("moment.lang is deprecated. Use moment.locale instead.", ct), f.langData = e("moment.langData is deprecated. Use moment.localeData instead.", mt); var _n = Math.abs; function yn(e, t, n, s) { t = C(t, n); return e._milliseconds += s * t._milliseconds, e._days += s * t._days, e._months += s * t._months, e._bubble() } function gn(e) { return e < 0 ? Math.floor(e) : Math.ceil(e) } function wn(e) { return 4800 * e / 146097 } function pn(e) { return 146097 * e / 4800 } function kn(e) { return function () { return this.as(e) } } pe = kn("ms"), me = kn("s"), Ce = kn("m"), we = kn("h"), ge = kn("d"), Je = kn("w"), k = kn("M"), _e = kn("Q"), ve = kn("y"); function vn(e) { return function () { return this.isValid() ? this._data[e] : NaN } } var ye = vn("milliseconds"), ke = vn("seconds"), Ie = vn("minutes"), w = vn("hours"), Mn = vn("days"), Dn = vn("months"), Sn = vn("years"); var Yn = Math.round, On = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 }; function bn(e, t, n, s) { var i = C(e).abs(), r = Yn(i.as("s")), a = Yn(i.as("m")), o = Yn(i.as("h")), u = Yn(i.as("d")), l = Yn(i.as("M")), h = Yn(i.as("w")), i = Yn(i.as("y")), r = (r <= n.ss ? ["s", r] : r < n.s && ["ss", r]) || a <= 1 && ["m"] || a < n.m && ["mm", a] || o <= 1 && ["h"] || o < n.h && ["hh", o] || u <= 1 && ["d"] || u < n.d && ["dd", u]; return (r = (r = null != n.w ? r || h <= 1 && ["w"] || h < n.w && ["ww", h] : r) || l <= 1 && ["M"] || l < n.M && ["MM", l] || i <= 1 && ["y"] || ["yy", i])[2] = t, r[3] = 0 < +e, r[4] = s, function (e, t, n, s, i) { return i.relativeTime(t || 1, !!n, e, s) }.apply(null, r) } var xn = Math.abs; function Tn(e) { return (0 < e) - (e < 0) || +e } function Nn() { if (!this.isValid()) return this.localeData().invalidDate(); var e, t, n, s, i, r, a, o = xn(this._milliseconds) / 1e3, u = xn(this._days), l = xn(this._months), h = this.asSeconds(); return h ? (e = y(o / 60), t = y(e / 60), o %= 60, e %= 60, n = y(l / 12), l %= 12, s = o ? o.toFixed(3).replace(/\.?0+$/, "") : "", i = Tn(this._months) !== Tn(h) ? "-" : "", r = Tn(this._days) !== Tn(h) ? "-" : "", a = Tn(this._milliseconds) !== Tn(h) ? "-" : "", (h < 0 ? "-" : "") + "P" + (n ? i + n + "Y" : "") + (l ? i + l + "M" : "") + (u ? r + u + "D" : "") + (t || e || o ? "T" : "") + (t ? a + t + "H" : "") + (e ? a + e + "M" : "") + (o ? a + s + "S" : "")) : "P0D" } var U = Ct.prototype; return U.isValid = function () { return this._isValid }, U.abs = function () { var e = this._data; return this._milliseconds = _n(this._milliseconds), this._days = _n(this._days), this._months = _n(this._months), e.milliseconds = _n(e.milliseconds), e.seconds = _n(e.seconds), e.minutes = _n(e.minutes), e.hours = _n(e.hours), e.months = _n(e.months), e.years = _n(e.years), this }, U.add = function (e, t) { return yn(this, e, t, 1) }, U.subtract = function (e, t) { return yn(this, e, t, -1) }, U.as = function (e) { if (!this.isValid()) return NaN; var t, n, s = this._milliseconds; if ("month" === (e = _(e)) || "quarter" === e || "year" === e) switch (t = this._days + s / 864e5, n = this._months + wn(t), e) { case "month": return n; case "quarter": return n / 3; case "year": return n / 12 } else switch (t = this._days + Math.round(pn(this._months)), e) { case "week": return t / 7 + s / 6048e5; case "day": return t + s / 864e5; case "hour": return 24 * t + s / 36e5; case "minute": return 1440 * t + s / 6e4; case "second": return 86400 * t + s / 1e3; case "millisecond": return Math.floor(864e5 * t) + s; default: throw new Error("Unknown unit " + e) } }, U.asMilliseconds = pe, U.asSeconds = me, U.asMinutes = Ce, U.asHours = we, U.asDays = ge, U.asWeeks = Je, U.asMonths = k, U.asQuarters = _e, U.asYears = ve, U.valueOf = function () { return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g(this._months / 12) : NaN }, U._bubble = function () { var e = this._milliseconds, t = this._days, n = this._months, s = this._data; return 0 <= e && 0 <= t && 0 <= n || e <= 0 && t <= 0 && n <= 0 || (e += 864e5 * gn(pn(n) + t), n = t = 0), s.milliseconds = e % 1e3, e = y(e / 1e3), s.seconds = e % 60, e = y(e / 60), s.minutes = e % 60, e = y(e / 60), s.hours = e % 24, t += y(e / 24), n += e = y(wn(t)), t -= gn(pn(e)), e = y(n / 12), n %= 12, s.days = t, s.months = n, s.years = e, this }, U.clone = function () { return C(this) }, U.get = function (e) { return e = _(e), this.isValid() ? this[e + "s"]() : NaN }, U.milliseconds = ye, U.seconds = ke, U.minutes = Ie, U.hours = w, U.days = Mn, U.weeks = function () { return y(this.days() / 7) }, U.months = Dn, U.years = Sn, U.humanize = function (e, t) { if (!this.isValid()) return this.localeData().invalidDate(); var n = !1, s = On; return "object" == typeof e && (t = e, e = !1), "boolean" == typeof e && (n = e), "object" == typeof t && (s = Object.assign({}, On, t), null != t.s && null == t.ss && (s.ss = t.s - 1)), e = this.localeData(), t = bn(this, !n, s, e), n && (t = e.pastFuture(+this, t)), e.postformat(t) }, U.toISOString = Nn, U.toString = Nn, U.toJSON = Nn, U.locale = Xt, U.localeData = Kt, U.toIsoString = e("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Nn), U.lang = Xe, s("X", 0, 0, "unix"), s("x", 0, 0, "valueOf"), v("x", De), v("X", /[+-]?\d+(\.\d{1,3})?/), D("X", function (e, t, n) { n._d = new Date(1e3 * parseFloat(e)) }), D("x", function (e, t, n) { n._d = new Date(g(e)) }), f.version = "2.29.4", H = W, f.fn = i, f.min = function () { return Rt("isBefore", [].slice.call(arguments, 0)) }, f.max = function () { return Rt("isAfter", [].slice.call(arguments, 0)) }, f.now = function () { return Date.now ? Date.now() : +new Date }, f.utc = l, f.unix = function (e) { return W(1e3 * e) }, f.months = function (e, t) { return fn(e, t, "months") }, f.isDate = V, f.locale = ct, f.invalid = I, f.duration = C, f.isMoment = h, f.weekdays = function (e, t, n) { return mn(e, t, n, "weekdays") }, f.parseZone = function () { return W.apply(null, arguments).parseZone() }, f.localeData = mt, f.isDuration = Ut, f.monthsShort = function (e, t) { return fn(e, t, "monthsShort") }, f.weekdaysMin = function (e, t, n) { return mn(e, t, n, "weekdaysMin") }, f.defineLocale = ft, f.updateLocale = function (e, t) { var n, s; return null != t ? (s = ot, null != R[e] && null != R[e].parentLocale ? R[e].set(X(R[e]._config, t)) : (t = X(s = null != (n = dt(e)) ? n._config : s, t), null == n && (t.abbr = e), (s = new K(t)).parentLocale = R[e], R[e] = s), ct(e)) : null != R[e] && (null != R[e].parentLocale ? (R[e] = R[e].parentLocale, e === ct() && ct(e)) : null != R[e] && delete R[e]), R[e] }, f.locales = function () { return ee(R) }, f.weekdaysShort = function (e, t, n) { return mn(e, t, n, "weekdaysShort") }, f.normalizeUnits = _, f.relativeTimeRounding = function (e) { return void 0 === e ? Yn : "function" == typeof e && (Yn = e, !0) }, f.relativeTimeThreshold = function (e, t) { return void 0 !== On[e] && (void 0 === t ? On[e] : (On[e] = t, "s" === e && (On.ss = t - 1), !0)) }, f.calendarFormat = function (e, t) { return (e = e.diff(t, "days", !0)) < -6 ? "sameElse" : e < -1 ? "lastWeek" : e < 0 ? "lastDay" : e < 1 ? "sameDay" : e < 2 ? "nextDay" : e < 7 ? "nextWeek" : "sameElse" }, f.prototype = i, f.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, f });
//# sourceMappingURL=moment.min.js.map;
/*!
 * Pikaday
 *
 * Copyright  2014 David Bushell | BSD & mit license | https://github.com/Pikaday/Pikaday
 */

(function (root, factory) {
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try { moment = require('moment'); } catch (e) { }
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('Pikaday', ['require'], function (req) {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try { moment = req(id); } catch (e) { }
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function (moment) {
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

        hasEventListeners = !!window.addEventListener,

        document = window.document,

        sto = window.setTimeout,

        addEvent = function (el, e, callback, capture) {
            if (hasEventListeners) {
                el.addEventListener(e, callback, !!capture);
            } else {
                el.attachEvent('on' + e, callback);
            }
        },

        removeEvent = function (el, e, callback, capture) {
            if (hasEventListeners) {
                el.removeEventListener(e, callback, !!capture);
            } else {
                el.detachEvent('on' + e, callback);
            }
        },

        trim = function (str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        },

        hasClass = function (el, cn) {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass = function (el, cn) {
            if (!hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass = function (el, cn) {
            el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
        },

        isArray = function (obj) {
            return (/Array/).test(Object.prototype.toString.call(obj));
        },

        isDate = function (obj) {
            return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
        },

        isWeekend = function (date) {
            var day = date.getDay();
            return day === 0 || day === 6;
        },

        isLeapYear = function (year) {
            // solution lifted from date.js (mit license): https://github.com/datejs/Datejs
            return ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
        },

        getDaysInMonth = function (year, month) {
            return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
        },

        setToStartOfDay = function (date) {
            if (isDate(date)) date.setHours(0, 0, 0, 0);
        },

        compareDates = function (a, b) {
            // weak date comparison (use setToStartOfDay(date) to ensure correct result)
            return a.getTime() === b.getTime();
        },

        extend = function (to, from, overwrite) {
            var prop, hasProp;
            for (prop in from) {
                hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                    if (isDate(from[prop])) {
                        if (overwrite) {
                            to[prop] = new Date(from[prop].getTime());
                        }
                    }
                    else if (isArray(from[prop])) {
                        if (overwrite) {
                            to[prop] = from[prop].slice(0);
                        }
                    } else {
                        to[prop] = extend({}, from[prop], overwrite);
                    }
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
            return to;
        },

        fireEvent = function (el, eventName, data) {
            var ev;

            if (document.createEvent) {
                ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, true, false);
                ev = extend(ev, data);
                el.dispatchEvent(ev);
            } else if (document.createEventObject) {
                ev = document.createEventObject();
                ev = extend(ev, data);
                el.fireEvent('on' + eventName, ev);
            }
        },

        adjustCalendar = function (calendar) {
            if (calendar.month < 0) {
                calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
                calendar.month += 12;
            }
            if (calendar.month > 11) {
                calendar.year += Math.floor(Math.abs(calendar.month) / 12);
                calendar.month -= 12;
            }
            return calendar;
        },

        /**
         * defaults and localisation
         */
        defaults = {

            // bind the picker to a form field
            field: null,

            // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
            bound: undefined,

            // data-attribute on the input field with an aria assistance text (only applied when `bound` is set)
            ariaLabel: 'Use the arrow keys to pick a date',

            // position of the datepicker, relative to the field (default to bottom & left)
            // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
            position: 'bottom left',

            // automatically fit in the viewport even if it means repositioning from the position option
            reposition: true,

            // the default output format for `.toString()` and `field` value
            format: 'YYYY-MM-DD',

            // the toString function which gets passed a current date object and format
            // and returns a string
            toString: null,

            // used to create date object from current input string
            parse: null,

            // the initial date to view when first opened
            defaultDate: null,

            // make the `defaultDate` the initial selected value
            setDefaultDate: false,

            // first day of week (0: Sunday, 1: Monday etc)
            firstDay: 0,

            // minimum number of days in the week that gets week number one
            // default ISO 8601, week 01 is the week with the first Thursday (4)
            firstWeekOfYearMinDays: 4,

            // the default flag for moment's strict date parsing
            formatStrict: false,

            // the minimum/earliest date that can be selected
            minDate: null,
            // the maximum/latest date that can be selected
            maxDate: null,

            // number of years either side, or array of upper/lower range
            yearRange: 10,

            // show week numbers at head of row
            showWeekNumber: false,

            // Week picker mode
            pickWholeWeek: false,

            // used internally (don't config outside)
            minYear: 0,
            maxYear: 9999,
            minMonth: undefined,
            maxMonth: undefined,

            startRange: null,
            endRange: null,

            isRTL: false,

            // Additional text to append to the year in the calendar title
            yearSuffix: '',

            // Render the month after year in the calendar title
            showMonthAfterYear: false,

            // Render days of the calendar grid that fall in the next or previous month
            showDaysInNextAndPreviousMonths: false,

            // Allows user to select days that fall in the next or previous month
            enableSelectionDaysInNextAndPreviousMonths: false,

            // how many months are visible
            numberOfMonths: 1,

            // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
            // only used for the first display or when a selected date is not visible
            mainCalendar: 'left',

            // Specify a DOM element to render the calendar in
            container: undefined,

            // Blur field when date is selected
            blurFieldOnSelect: true,

            // internationalization
            i18n: {
                previousMonth: 'Previous Month',
                nextMonth: 'Next Month',
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
            },

            // Theme Classname
            theme: null,

            // events array
            events: [],

            // callback function
            onSelect: null,
            onOpen: null,
            onClose: null,
            onDraw: null,

            // Enable keyboard input
            keyboardInput: true
        },


        /**
         * templating functions to abstract HTML rendering
         */
        renderDayName = function (opts, day, abbr) {
            day += opts.firstDay;
            while (day >= 7) {
                day -= 7;
            }
            return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
        },

        renderDay = function (opts) {
            var arr = [];
            var ariaSelected = 'false';
            if (opts.isEmpty) {
                if (opts.showDaysInNextAndPreviousMonths) {
                    arr.push('is-outside-current-month');

                    if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
                        arr.push('is-selection-disabled');
                    }

                } else {
                    return '<td class="is-empty"></td>';
                }
            }
            if (opts.isDisabled) {
                arr.push('is-disabled');
            }
            if (opts.isToday) {
                arr.push('is-today');
            }
            if (opts.isSelected) {
                arr.push('is-selected');
                ariaSelected = 'true';
            }
            if (opts.hasEvent) {
                arr.push('has-event');
            }
            if (opts.isInRange) {
                arr.push('is-inrange');
            }
            if (opts.isStartRange) {
                arr.push('is-startrange');
            }
            if (opts.isEndRange) {
                arr.push('is-endrange');
            }
            return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                '<button class="pika-button pika-day" type="button" ' +
                'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                opts.day +
                '</button>' +
                '</td>';
        },

        isoWeek = function (date, firstWeekOfYearMinDays) {
            // Ensure we're at the start of the day.
            date.setHours(0, 0, 0, 0);

            // Thursday in current week decides the year because January 4th
            // is always in the first week according to ISO8601.
            var yearDay = date.getDate(),
                weekDay = date.getDay(),
                dayInFirstWeek = firstWeekOfYearMinDays,
                dayShift = dayInFirstWeek - 1, // counting starts at 0
                daysPerWeek = 7,
                prevWeekDay = function (day) { return (day + daysPerWeek - 1) % daysPerWeek; };

            // Adjust to Thursday in week 1 and count number of weeks from date to week 1.
            date.setDate(yearDay + dayShift - prevWeekDay(weekDay));

            var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek),
                msPerDay = 24 * 60 * 60 * 1000,
                daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay,
                weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);

            return weekNum;
        },

        renderWeek = function (d, m, y, firstWeekOfYearMinDays) {
            var date = new Date(y, m, d),
                week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);

            return '<td class="pika-week">' + week + '</td>';
        },

        renderRow = function (days, isRTL, pickWholeWeek, isRowSelected) {
            return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
        },

        renderBody = function (rows) {
            return '<tbody>' + rows.join('') + '</tbody>';
        },

        renderHead = function (opts) {
            var i, arr = [];
            if (opts.showWeekNumber) {
                arr.push('<th></th>');
            }
            for (i = 0; i < 7; i++) {
                arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
            }
            return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
        },

        renderTitle = function (instance, c, year, month, refYear, randId) {
            var i, j, arr,
                opts = instance._o,
                isMinYear = year === opts.minYear,
                isMaxYear = year === opts.maxYear,
                html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
                monthHtml,
                yearHtml,
                prev = true,
                next = true;

            for (arr = [], i = 0; i < 12; i++) {
                arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                    (i === month ? ' selected="selected"' : '') +
                    ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? ' disabled="disabled"' : '') + '>' +
                    opts.i18n.months[i] + '</option>');
            }

            monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

            if (isArray(opts.yearRange)) {
                i = opts.yearRange[0];
                j = opts.yearRange[1] + 1;
            } else {
                i = year - opts.yearRange;
                j = 1 + year + opts.yearRange;
            }

            for (arr = []; i < j && i <= opts.maxYear; i++) {
                if (i >= opts.minYear) {
                    arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : '') + '>' + (i) + '</option>');
                }
            }
            yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

            if (opts.showMonthAfterYear) {
                html += yearHtml + monthHtml;
            } else {
                html += monthHtml + yearHtml;
            }

            if (isMinYear && (month === 0 || opts.minMonth >= month)) {
                prev = false;
            }

            if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
                next = false;
            }

            if (c === 0) {
                html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
            }
            if (c === (instance._o.numberOfMonths - 1)) {
                html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
            }

            return html += '</div>';
        },

        renderTable = function (opts, data, randId) {
            return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
        },


        /**
         * Pikaday constructor
         */
        Pikaday = function (options) {
            var self = this,
                opts = self.config(options);

            self._onMouseDown = function (e) {
                if (!self._v) {
                    return;
                }
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }

                if (!hasClass(target, 'is-disabled')) {
                    if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                        self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                        if (opts.bound) {
                            sto(function () {
                                self.hide();
                                if (opts.blurFieldOnSelect && opts.field) {
                                    opts.field.blur();
                                }
                            }, 100);
                        }
                    }
                    else if (hasClass(target, 'pika-prev')) {
                        self.prevMonth();
                    }
                    else if (hasClass(target, 'pika-next')) {
                        self.nextMonth();
                    }
                }
                if (!hasClass(target, 'pika-select')) {
                    // if this is touch event prevent mouse events emulation
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                        return false;
                    }
                } else {
                    self._c = true;
                }
            };

            self._onChange = function (e) {
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }
                if (hasClass(target, 'pika-select-month')) {
                    self.gotoMonth(target.value);
                }
                else if (hasClass(target, 'pika-select-year')) {
                    self.gotoYear(target.value);
                }
            };

            self._onKeyChange = function (e) {
                e = e || window.event;

                if (self.isVisible()) {

                    switch (e.keyCode) {
                        case 13:
                        case 27:
                            if (opts.field) {
                                opts.field.blur();
                            }
                            break;
                        case 37:
                            self.adjustDate('subtract', 1);
                            break;
                        case 38:
                            self.adjustDate('subtract', 7);
                            break;
                        case 39:
                            self.adjustDate('add', 1);
                            break;
                        case 40:
                            self.adjustDate('add', 7);
                            break;
                        case 8:
                        case 46:
                            self.setDate(null);
                            break;
                    }
                }
            };

            self._parseFieldValue = function () {
                if (opts.parse) {
                    return opts.parse(opts.field.value, opts.format);
                } else if (hasMoment) {
                    var date = moment(opts.field.value, opts.format, opts.formatStrict);
                    return (date && date.isValid()) ? date.toDate() : null;
                } else {
                    return new Date(Date.parse(opts.field.value));
                }
            };

            self._onInputChange = function (e) {
                var date;

                if (e.firedBy === self) {
                    return;
                }
                date = self._parseFieldValue();
                if (isDate(date)) {
                    self.setDate(date);
                }
                if (!self._v) {
                    self.show();
                }
            };

            self._onInputFocus = function () {
                self.show();
            };

            self._onInputClick = function () {
                self.show();
            };

            self._onInputBlur = function () {
                // IE allows pika div to gain focus; catch blur the input field
                var pEl = document.activeElement;
                do {
                    if (hasClass(pEl, 'pika-single')) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));

                if (!self._c) {
                    self._b = sto(function () {
                        self.hide();
                    }, 50);
                }
                self._c = false;
            };

            self._onClick = function (e) {
                e = e || window.event;
                var target = e.target || e.srcElement,
                    pEl = target;
                if (!target) {
                    return;
                }
                if (!hasEventListeners && hasClass(target, 'pika-select')) {
                    if (!target.onchange) {
                        target.setAttribute('onchange', 'return;');
                        addEvent(target, 'change', self._onChange);
                    }
                }
                do {
                    if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));
                if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                    self.hide();
                }
            };

            self.el = document.createElement('div');
            self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

            addEvent(self.el, 'mousedown', self._onMouseDown, true);
            addEvent(self.el, 'touchend', self._onMouseDown, true);
            addEvent(self.el, 'change', self._onChange);

            if (opts.keyboardInput) {
                addEvent(document, 'keydown', self._onKeyChange);
            }

            if (opts.field) {
                if (opts.container) {
                    opts.container.appendChild(self.el);
                } else if (opts.bound) {
                    document.body.appendChild(self.el);
                } else {
                    opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
                }
                addEvent(opts.field, 'change', self._onInputChange);

                if (!opts.defaultDate) {
                    opts.defaultDate = self._parseFieldValue();
                    opts.setDefaultDate = true;
                }
            }

            var defDate = opts.defaultDate;

            if (isDate(defDate)) {
                if (opts.setDefaultDate) {
                    self.setDate(defDate, true);
                } else {
                    self.gotoDate(defDate);
                }
            } else {
                self.gotoDate(new Date());
            }

            if (opts.bound) {
                this.hide();
                self.el.className += ' is-bound';
                addEvent(opts.trigger, 'click', self._onInputClick);
                addEvent(opts.trigger, 'focus', self._onInputFocus);
                addEvent(opts.trigger, 'blur', self._onInputBlur);
            } else {
                this.show();
            }
        };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function (options) {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                this.setMaxDate(opts.maxDate);
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function (format) {
            format = format || this._o.format;
            if (!isDate(this._d)) {
                return '';
            }
            if (this._o.toString) {
                return this._o.toString(this._d, format);
            }
            if (hasMoment) {
                return moment(this._d).format(format);
            }
            return this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function () {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function (date, preventOnSelect) {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function () {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function (date, preventOnSelect) {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', { firedBy: this });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * clear and reset the date
         */
        clear: function () {
            this.setDate(null);
        },

        /**
         * change view to a specific date
         */
        gotoDate: function (date) {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
                lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustDate: function (sign, days) {

            var day = this.getDate() || new Date();
            var difference = parseInt(days) * 24 * 60 * 60 * 1000;

            var newDay;

            if (sign === 'add') {
                newDay = new Date(day.valueOf() + difference);
            } else if (sign === 'subtract') {
                newDay = new Date(day.valueOf() - difference);
            }

            this.setDate(newDay);
        },

        adjustCalendars: function () {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function () {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function (month) {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function () {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function () {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function (year) {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function (value) {
            if (value instanceof Date) {
                setToStartOfDay(value);
                this._o.minDate = value;
                this._o.minYear = value.getFullYear();
                this._o.minMonth = value.getMonth();
            } else {
                this._o.minDate = defaults.minDate;
                this._o.minYear = defaults.minYear;
                this._o.minMonth = defaults.minMonth;
                this._o.startRange = defaults.startRange;
            }

            this.draw();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function (value) {
            if (value instanceof Date) {
                setToStartOfDay(value);
                this._o.maxDate = value;
                this._o.maxYear = value.getFullYear();
                this._o.maxMonth = value.getMonth();
            } else {
                this._o.maxDate = defaults.maxDate;
                this._o.maxYear = defaults.maxYear;
                this._o.maxMonth = defaults.maxMonth;
                this._o.endRange = defaults.endRange;
            }

            this.draw();
        },

        setStartRange: function (value) {
            this._o.startRange = value;
        },

        setEndRange: function (value) {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function (force) {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '',
                randId;

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            for (var c = 0; c < opts.numberOfMonths; c++) {
                randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if (opts.field.type !== 'hidden') {
                    sto(function () {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                this._o.onDraw(this);
            }

            if (opts.bound) {
                // let the screen reader user know to use arrow keys
                opts.field.setAttribute('aria-label', opts.ariaLabel);
            }
        },

        adjustPosition: function () {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;

            if (this._o.container) return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
            leftAligned = true;
            bottomAligned = true;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top = pEl.offsetTop + pEl.offsetHeight;
                while ((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
                leftAligned = false;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
                bottomAligned = false;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';

            addClass(this.el, leftAligned ? 'left-aligned' : 'right-aligned');
            addClass(this.el, bottomAligned ? 'bottom-aligned' : 'top-aligned');
            removeClass(this.el, !leftAligned ? 'left-aligned' : 'right-aligned');
            removeClass(this.el, !bottomAligned ? 'bottom-aligned' : 'top-aligned');
        },

        /**
         * render HTML for a particular month
         */
        render: function (year, month, randId) {
            var opts = this._o,
                now = new Date(),
                days = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data = [],
                row = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var previousMonth = month === 0 ? 11 : month - 1,
                nextMonth = month === 11 ? 0 : month + 1,
                yearOfPreviousMonth = month === 0 ? year - 1 : year,
                yearOfNextMonth = month === 11 ? year + 1 : year,
                daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
            var cells = days + before,
                after = cells;
            while (after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            var isWeekSelected = false;
            for (var i = 0, r = 0; i < cells; i++) {
                var day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                    isEmpty = i < before || i >= (days + before),
                    dayNumber = 1 + (i - before),
                    monthNumber = month,
                    yearNumber = year,
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                        (opts.maxDate && day > opts.maxDate) ||
                        (opts.disableWeekends && isWeekend(day)) ||
                        (opts.disableDayFn && opts.disableDayFn(day));

                if (isEmpty) {
                    if (i < before) {
                        dayNumber = daysInPreviousMonth + dayNumber;
                        monthNumber = previousMonth;
                        yearNumber = yearOfPreviousMonth;
                    } else {
                        dayNumber = dayNumber - days;
                        monthNumber = nextMonth;
                        yearNumber = yearOfNextMonth;
                    }
                }

                var dayConfig = {
                    day: dayNumber,
                    month: monthNumber,
                    year: yearNumber,
                    hasEvent: hasEvent,
                    isSelected: isSelected,
                    isToday: isToday,
                    isDisabled: isDisabled,
                    isEmpty: isEmpty,
                    isStartRange: isStartRange,
                    isEndRange: isEndRange,
                    isInRange: isInRange,
                    showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                    enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                };

                if (opts.pickWholeWeek && isSelected) {
                    isWeekSelected = true;
                }

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays));
                    }
                    data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                    row = [];
                    r = 0;
                    isWeekSelected = false;
                }
            }
            return renderTable(opts, data, randId);
        },

        isVisible: function () {
            return this._v;
        },

        show: function () {
            if (!this.isVisible()) {
                this._v = true;
                this.draw();
                removeClass(this.el, 'is-hidden');
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function () {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }

                if (!this._o.container) {
                    this.el.style.position = 'static'; // reset
                    this.el.style.left = 'auto';
                    this.el.style.top = 'auto';
                }
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function () {
            var opts = this._o;

            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'touchend', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            if (opts.keyboardInput) {
                removeEvent(document, 'keydown', this._onKeyChange);
            }
            if (opts.field) {
                removeEvent(opts.field, 'change', this._onInputChange);
                if (opts.bound) {
                    removeEvent(opts.trigger, 'click', this._onInputClick);
                    removeEvent(opts.trigger, 'focus', this._onInputFocus);
                    removeEvent(opts.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;
}));

define('forms/fields/DatePicker', [
    'jquery',
    'moment',
    'Pikaday',
    'factories/fieldFactory'
], function (
    $,
    moment,
    Pikaday,
    fieldFactory
) {
    'use strict';
    /*
        DatePicker
        =========
    */
    var DatePicker = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = DatePicker.markup;

        o = $.extend({
            $e: null,
            selector: '.date-picker'
        }, options);

        internal = {
            name: 'DatePicker',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            picker: null,
            format: 'MM/DD/YYYY',
            initialVal: null,

            components: {
                nativeInput: {
                    selector: '.picker'
                },
                picker: {
                    selector: '.picker'
                }
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                fn.getFormat();
                fn.initPicker();
                fn.getInitialVal();
            },

            getFormat: function () {
                internal.format = elements.picker.data('format') || internal.format;
            },

            initPicker: function () {
                internal.picker = new Pikaday({
                    field: elements.picker[0],
                    format: internal.format,
                    setDefaultDate: internal.initialVal ? moment(internal.initialVal).format(internal.format) : ''
                });
            },

            getInitialVal: function () {
                internal.initialVal = elements.picker.val();

                if (!fn.isBlank()) {
                    fn.setDefaultVal(moment(internal.initialVal).format(internal.format));
                }
            },

            setDisplayDate: function (displayDate) {
                elements.picker.val(displayDate);
            },

            getVal: function () {
                var inputVal = elements.picker.val();

                if (!inputVal) {
                    // skip date formatting if input is empty
                    return '';
                }

                return internal.picker ? internal.picker.getMoment().format('YYYY-MM-DD') : inputVal;
            },

            getRawVal: function () {
                return internal.picker ? internal.picker.getMoment().format() : '';
            },

            setVal: function (date, options) {
                var formattedDate = date ? moment(date).format(internal.format) : '';

                options = options || {};

                if (internal.picker) {
                    internal.picker.setDate(formattedDate);
                } else {
                    elements.picker.val(formattedDate);
                }

                if (options.isDefault) {
                    elements.picker.trigger('change:default', formattedDate);
                }
            }
        };

        handlers = {};

        api = {
            getVal: fn.getVal,
            getRawVal: fn.getRawVal,
            setVal: fn.setVal
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    DatePicker.markup = {};

    return DatePicker;
});

define('forms/fields/Time', [
    'jquery',
    'factories/fieldFactory',
    'forms/widgets/DropMenu'
], function (
    $,
    fieldFactory,
    DropMenu
) {
    'use strict';
    /*
        Time
        =========
    */
    var Time = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = Time.markup;

        o = $.extend({
            $e: null,
            selector: '.time'
        }, options);

        internal = {
            name: 'Time',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            dropMenus: [],
            twelveTimeRegex: /^([0-9]|1[0-2]):[0-5][0-9](am|pm)$/,
            zuluTimeRegex: /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/,

            components: {
                nativeInput: {
                    selector: '.time-control'
                },
                timeDropMenu: {
                    selector: '.time-drop-menu'
                }
            },

            events: {
                'blur @nativeInput': 'nativeInputBlur'
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                elements.timeDropMenu.each(function (i, dropMenu) {
                    internal.dropMenus.push(
                        new DropMenu({
                            $e: $(dropMenu),
                            onSelect: function ($timeItem) {
                                fn.setVal($timeItem.data('value'));
                            },
                            selfToggle: true
                        })
                    );
                });
            },

            setVal: function (time, options) {
                options = options || {};

                elements.nativeInput.val(fn.convertTo12hTime(time));
                elements.nativeInput.trigger('change');

                if (options.isDefault) {
                    elements.nativeInput.trigger('change:default', time);
                }
            },

            getVal: function () {
                return self.isValid() ? fn.convertToISOTime($.trim(elements.nativeInput.val())) : '';
            },

            convertTo12hTime: function (time) {
                var timeSplit, hours, minutes, timeSuffix;

                if (!time) {
                    return '';
                }

                if (internal.twelveTimeRegex.test(time)) {
                    return time;
                } else if (internal.zuluTimeRegex.test(time)) {
                    timeSplit = time.split(':');
                    hours = parseInt(timeSplit[0]);
                    minutes = timeSplit[1];

                    if (hours >= 12) {
                        hours = hours - 12;
                        timeSuffix = 'pm';
                    } else {
                        timeSuffix = 'am';
                    }

                    if (hours === 0) {
                        hours = 12;
                    }

                    return hours + ':' + minutes + timeSuffix;
                }
            },

            convertToISOTime: function (time) {
                var timeSplit, hours, minutes, isoTime;

                if (!time || !self.isValid()) {
                    return '';
                }

                if (internal.twelveTimeRegex.test(time)) {
                    timeSplit = time.replace(/am|pm/, '').split(':');
                } else if (internal.zuluTimeRegex.test(time)) {
                    timeSplit = time.split(':');
                }

                hours = parseInt(timeSplit[0]);
                minutes = timeSplit[1];

                if (/pm/.test(time) && hours !== 12) {
                    hours = hours + 12;
                } else if (/am/.test(time) && hours === 12) {
                    hours = 0;
                }

                if (hours < 10) {
                    hours = '0' + hours;
                }

                isoTime = hours + ':' + minutes + ':00';

                return isoTime;
            }
        };

        handlers = {
            nativeInputBlur: function () {
                internal.dropMenus.forEach(function (dropMenu) {
                    dropMenu.close();
                });
            }
        };

        api = {
            setVal: fn.setVal,
            getVal: fn.getVal
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    Time.markup = {};

    return Time;
});

define('forms/fields/HtmlField', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';
    /*
        HtmlField
        =========
    */
    var HtmlField = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = HtmlField.markup;

        o = $.extend({
            $e: null,
            selector: '.html-field'
        }, options);

        internal = {
            name: 'HtmlField',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            withoutNativeInput: true,
            components: {}
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
            },
            getName: function () {
                return internal.$e.attr('name');
            },
            getVal: function () {
                return internal.$e.html();
            },
            setVal: function (value, options) {
                options = options || {};

                internal.$e.html(value);

                if (options.isDefault) {
                    internal.$e.trigger('change:default', value);
                }
            }
        };

        handlers = {};

        api = {
            getName: fn.getName,
            getVal: fn.getVal,
            setVal: fn.setVal
        };

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    HtmlField.markup = {};

    return HtmlField;
});

define('forms/widgets/FocalPoint', [
    'jquery',
    'factories/fieldFactory'
], function (
    $,
    fieldFactory
) {
    'use strict';

    var FocalPoint = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = FocalPoint.markup;

        o = $.extend({
            $e: null,
            selector: '.focal-point'
        }, options);

        internal = {
            name: 'FocalPoint',
            $e: o.$e || $(o.selector),

            withoutNativeInput: true,
            wrapperBounds: {},
            fieldset: {},

            tooltipTimeout: null,
            tooltipDelay: 1000,

            components: {
                focalPointControl: {
                    selector: '.focal-point-control'
                }
            },

            events: {
                'mousedown': 'mouseDown',
                'mousemove': 'mouseMove',
                'mouseup': 'mouseUp',
                'mouseenter': 'mouseEnter'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.fieldset = internal.$e.data('fieldsetInstance');

                if (internal.fieldset.isReady()) {
                    fn.setInitialFocalPoint();
                } else {
                    internal.$e.one('initCustomFieldsComplete', fn.setInitialFocalPoint);
                }
            },

            setInitialFocalPoint: function () {
                var initialCoords;

                initialCoords = internal.fieldset.getVals(['focus_x', 'focus_y']);

                if (!initialCoords.focus_x || !initialCoords.focus_y) {
                    fn.showTooltip();
                } else {
                    fn.hideTooltip();
                }

                initialCoords.focus_x = initialCoords.focus_x ? parseFloat(initialCoords.focus_x) : 0.5;
                initialCoords.focus_y = initialCoords.focus_y ? parseFloat(initialCoords.focus_y) : 0.5;

                internal.fieldset.setVals(initialCoords, null, { silent: true });
                fn.updateFocalPoint();
            },

            cacheWrapperBounds: function () {
                internal.wrapperBounds = internal.$e[0].getBoundingClientRect();
            },

            startFocalPointDrag: function () {
                internal.focalPointDragging = true;
            },

            stopFocalPointDrag: function () {
                internal.focalPointDragging = false;
            },

            setFocalPoint: function (clientX, clientY) {
                var xFloat, yFloat;

                xFloat = (clientX - internal.wrapperBounds.left) / internal.wrapperBounds.width;
                yFloat = (clientY - internal.wrapperBounds.top) / internal.wrapperBounds.height;

                xFloat = Math.max(0, Math.min(1, xFloat));
                yFloat = Math.max(0, Math.min(1, yFloat));

                internal.fieldset.setVals({
                    focus_x: xFloat,
                    focus_y: yFloat
                });

                fn.updateFocalPoint();
            },

            updateFocalPoint: function () {
                var coords;

                coords = internal.fieldset.getVals(['focus_x', 'focus_y']);

                elements.focalPointControl.css({
                    left: (parseFloat(coords.focus_x) * 100) + '%',
                    top: (parseFloat(coords.focus_y) * 100) + '%'
                });
            },

            showTooltip: function () {
                if (!internal.tooltipTimeout) {
                    internal.tooltipTimeout = setTimeout(function () {
                        fn.showTooltip();
                    }, internal.tooltipDelay);
                    return;
                }

                elements.focalPointControl.addClass(m.SHOW_TOOLTIP);
            },

            hideTooltip: function () {
                elements.focalPointControl.removeClass(m.SHOW_TOOLTIP);
                clearTimeout(internal.tooltipTimeout);
                internal.tooltipTimeout = null;
            }
        };

        handlers = {
            mouseDown: function (evnt) {
                fn.cacheWrapperBounds();
                fn.startFocalPointDrag();
                fn.setFocalPoint(evnt.clientX, evnt.clientY);
                fn.hideTooltip();
            },

            mouseMove: function (evnt) {
                if (internal.focalPointDragging) {
                    evnt.preventDefault();
                    fn.setFocalPoint(evnt.clientX, evnt.clientY);
                }
            },

            mouseUp: function () {
                fn.stopFocalPointDrag();
            },

            mouseEnter: function () {
                fn.showTooltip();
            }
        };

        api = {};

        fieldFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    FocalPoint.markup = {
        SHOW_TOOLTIP: 'state-show-tooltip'
    };

    return FocalPoint;
});

define('managers/TagSearchManager', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var TagSearchManager = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = TagSearchManager.markup;

        o = $.extend({
            $e: null,
            selector: '.autocomplate.variant-tag-search-input',
            autocomplete: null
        }, options);

        internal = {
            name: 'TagSearchManager',
            $e: o.$e || $(o.selector),

            defaultTags: [],
            currentTagIndex: -1,
            rotateDelay: 3500,
            transitionDelay: 300 + 50, // default CSS transition time + some buffer,
            restartDelay: 1000,
            rotateTimeout: null,
            restartTimeout: null,
            controlFocused: false,
            controlMouseover: false,
            firstClick: false,
            startTag: false,

            components: {
                heroSearch: {
                    selector: '^#hero-search'
                },

                autocompleteDropMenu: {
                    selector: '.autocomplete-drop-menu'
                },

                autocompleteControl: {
                    selector: '.autocomplete-control'
                }
            },

            events: {
                'mouseenter @autocompleteControl': 'autocompleteControlMouseenter',
                'mouseleave @autocompleteControl': 'autocompleteControlMouseleave',
                'focus @autocompleteControl': 'autocompleteControlFocus',
                'blur @autocompleteControl': 'autocompleteControlBlur',
                'click @autocompleteControl': 'autocompleteControlClick',
                'clearinput': 'autocompleteClearInput',
                'autocompleteSelect': 'autocompleteSelect'
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                fn.cacheDefaultTags();
                fn.ensureTagTitle();

                if (!fn.acControlHasVal()) {
                    fn.rotateTags();
                } else {
                    fn.setControlState();
                    internal.startTag = true;
                }

                internal.globalSearchManager = elements.heroSearch.data('globalSearchManagerInstance');
            },

            cacheDefaultTags: function () {
                var $acResults;

                $acResults = o.autocomplete.getResults();

                $acResults.each(function (i, resultEl) {
                    var $result, resultJson;

                    $result = $(resultEl);
                    resultJson = $result.data('result');
                    internal.defaultTags.push({
                        $e: $result,
                        json: resultJson
                    });
                });
            },

            ensureTagTitle: function () {
                var currentTag;
                currentTag = fn.getCurrentTag();
                if (currentTag) {
                    o.autocomplete.setInputVal(currentTag.json.title);
                }
            },

            acControlHasVal: function () {
                var acControlVal;
                acControlVal = o.autocomplete.getControlVal();
                return acControlVal.length > 0;
            },

            rotateTags: function () {
                var nextTagIndex, nextTag;

                if (internal.defaultTags.length) {
                    nextTagIndex = internal.currentTagIndex + 1;
                    if (nextTagIndex >= internal.defaultTags.length) {
                        nextTagIndex = 0;
                    }

                    nextTag = internal.defaultTags[nextTagIndex];
                    fn.fadeInValue(nextTag.json);
                    internal.rotateTimeout = setTimeout(fn.rotateTags, internal.rotateDelay);
                    internal.currentTagIndex = nextTagIndex;
                }
            },

            restartRotator: function () {
                var currentTag;
                currentTag = fn.getCurrentTag();

                if (currentTag || !fn.acControlHasVal()) {
                    internal.restartTimeout = setTimeout(function () {
                        fn.rotateTags();
                    }, internal.restartDelay);
                }
            },

            getCurrentTag: function () {
                var acControlVal, valRegEx, currentTag;
                acControlVal = o.autocomplete.getControlVal();
                valRegEx = new RegExp('^' + acControlVal + '$', 'i');
                currentTag = null;

                internal.defaultTags.forEach(function (tagObj) {
                    var tag = tagObj.json;

                    if (valRegEx.test(tag.slug) || valRegEx.test(tag.title)) {
                        currentTag = tagObj;
                        return false;
                    }
                });

                return currentTag;
            },

            triggerAutoCompleteSelect: function () {
                var currentTag;
                currentTag = fn.getCurrentTag();

                if (currentTag) {
                    o.autocomplete.setValByEl(currentTag.$e);
                }
            },

            setControlState: function () {
                var controlHasValue;
                controlHasValue = fn.acControlHasVal();
                internal.$e.toggleClass(m.TAG_SELECTED, controlHasValue);
            },

            fadeInValue: function (result) {
                elements.autocompleteControl
                    .css('color', 'rgba(255,255,255,0)')
                    .delay(internal.transitionDelay).queue(function (next) {
                        elements.autocompleteControl
                            .val(result.title)
                            .css('color', 'rgba(255,255,255,1)');
                        next();
                    });
            },

            stopRotator: function () {
                clearTimeout(internal.rotateTimeout);
                clearTimeout(internal.restartTimeout);
            }
        };

        handlers = {
            autocompleteControlMouseenter: function () {
                internal.controlMouseover = true;
                fn.stopRotator();
            },

            autocompleteControlMouseleave: function () {
                internal.controlMouseover = false;
                if (!internal.controlFocused && !internal.$e.hasClass(m.TAG_SELECTED)) {
                    fn.restartRotator();
                }
            },

            autocompleteControlFocus: function () {
                internal.controlFocused = true;
                fn.stopRotator();
            },

            autocompleteControlBlur: function () {
                internal.controlFocused = false;
                internal.firstClick = false;
                if (!internal.controlMouseover && !internal.$e.hasClass(m.TAG_SELECTED)) {

                    if (internal.startTag) {
                        internal.globalSearchManager.reset({ removeParam: 'tag' });
                    } else {
                        fn.restartRotator();
                    }
                }
            },

            autocompleteControlClick: function () {
                if (internal.firstClick) {
                    fn.triggerAutoCompleteSelect();
                } else {
                    internal.firstClick = true;
                }
            },

            autocompleteClearInput: function () {
                if (internal.startTag) {
                    internal.globalSearchManager.reset({ removeParam: 'tag' });
                } else {
                    internal.controlFocused = false;
                    internal.firstClick = false;
                    internal.controlMouseover = false;
                    fn.rotateTags();
                }
            },

            autocompleteSelect: function () {
                fn.stopRotator();
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    TagSearchManager.markup = {
        TAG_SELECTED: 'state-tag-selected'
    };

    return TagSearchManager;
});

define('forms/widgets/Autocomplete', [
    'jquery',
    'factories/moduleFactory',
    'forms/widgets/DropMenu',
    'services/Xhr',
    'utils/keycodes',
    'utils/functionUtil',
    'managers/TagSearchManager'
], function (
    $,
    moduleFactory,
    DropMenu,
    Xhr,
    kc,
    functionUtil,
    TagSearchManager
) {
    'use strict';

    var Autocomplete = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = Autocomplete.markup;

        o = $.extend({
            $e: null,
            selector: '.field.autocomplete',
            searchDelay: 250
        }, options);

        internal = {
            name: 'Autocomplete',
            $e: o.$e || $(o.selector),

            withoutNativeInput: true,

            endpoint: '/q/{{query}}',
            xhr: new Xhr({
                xhrSettings: {
                    contentType: 'text/plain; charest=utf-8',
                    dataType: 'html'
                }
            }),
            currentSearch: null,
            defaultResults: null,

            tagData: {
                dataKey: null,
                tagFieldName: null,
                tagMetaFields: {}
            },

            dropMenu: null,
            dropMenuOptions: {
                control: '.autocomplete-control',
                wrapper: '.autocomplete-results',
                item: '.autocomplete-results .autocomplete-result',
                autocomplete: true
            },

            templates: {
                tag: {
                    selector: '!.autocomplete-tag-template'
                }
            },

            components: {
                dropMenu: {
                    selector: '.autocomplete-drop-menu'
                },

                control: {
                    selector: '.autocomplete-control'
                },

                results: {
                    selector: '.autocomplete-results'
                },

                result: {
                    selector: '.autocomplete-result'
                },

                tags: {
                    selector: '.autocomplete-tags'
                },

                tag: {
                    selector: '.autocomplete-tag'
                },

                removeTag: {
                    selector: '.remove-tag'
                },

                clearInput: {
                    selector: '.clear-input'
                }
            },

            events: {
                'initCustomFieldsComplete': 'initCustomFieldsComplete',
                'focus @control': 'controlFocus',
                'blur @control': 'controlBlur',
                'keyup @control': 'controlKeyup',
                'click @removeTag': 'removeTagClick',
                'click @clearInput': 'clearInputClick',
                'change @control': 'controlChange',
                'paste @control': 'controlPaste'
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                fn.cacheDataEndpoint();
                fn.cacheDefaultResults();
                fn.cacheTagData();
                fn.initDropMenu();
                fn.getInitialTags();

                if (fn.isSingleValue()) {
                    fn.prefillControl();
                }

                if (internal.$e.hasClass(m.TAG_SEARCH_INPUT)) {
                    new TagSearchManager({
                        $e: internal.$e,
                        autocomplete: self
                    });
                }
            },

            cacheDataEndpoint: function () {
                var endpoint = internal.$e.data('endpoint');

                if (endpoint) {
                    endpoint = endpoint.replace('[[', '{{', 'g').replace(']]', '}}', 'g');
                    internal.endpoint = endpoint;
                }
            },

            updateEndpoint: function (updatedEndpoint) {
                internal.endpoint = updatedEndpoint;
            },

            cacheDefaultResults: function () {
                if (elements.result) {
                    internal.defaultResults = elements.results.html();
                }
            },

            getResults: function () {
                return elements.result || $();
            },

            getControlVal: function () {
                return $.trim(elements.control.val());
            },

            cacheTagData: function () {
                internal.tagData.name = internal.$e.data('name');
                internal.tagData.dataKey = internal.$e.data('key');
                internal.tagData.tagFieldName = internal.$e.data('tagFieldName');
                internal.tagData.tagMetaFields = internal.$e.data('tagMetaFields');
            },

            initDropMenu: function () {
                internal.dropMenu = new DropMenu({
                    $e: elements.dropMenu,
                    menuControl: internal.dropMenuOptions.control,
                    menuItemsWrapper: internal.dropMenuOptions.wrapper,
                    menuItem: internal.dropMenuOptions.item,
                    onSelect: fn.setValByEl
                });
            },

            getInitialTags: function () {
                var tags = internal.$e.data('tags');

                if ($.isPlainObject(tags)) {
                    tags = [tags];
                }

                if ($.isArray(tags)) {
                    $.each(tags, function (i, tag) {
                        if ($.type(tag) === 'string') {
                            tag = JSON.parse(tag.replace(/'/g, '"'));
                        }

                        fn.appendTag($.extend({
                            value: tag,
                            label: tag.title
                        }, internal.tagData));
                    });
                }
            },

            prefillControl: function () {
                var firstTagTitle, $firstTag, $firstTagLabel;

                if (elements.tag) {
                    $firstTag = elements.tag.first();
                    $firstTagLabel = $firstTag.find('.label');
                    firstTagTitle = $.trim($firstTagLabel.text());

                    elements.control.val(firstTagTitle);
                    fn.setTagSelectedState();
                }
            },

            isSingleValue: function () {
                return !!internal.$e.data('singleValue');
            },

            setValByEl: function ($result) {
                var displayLabel, resultJson, $clonedResult, handleAutoCompleteSelect;
                handleAutoCompleteSelect = internal.$e.data('handleAutoCompleteSelect');

                if (!$result.length) {
                    if (handleAutoCompleteSelect) {
                        handleAutoCompleteSelect(null);
                    }
                    return;
                }

                $clonedResult = $result.clone();
                $clonedResult.find('.result-meta').remove();

                displayLabel = $.trim($clonedResult.text());
                resultJson = $result.data('result');

                if (handleAutoCompleteSelect) {
                    handleAutoCompleteSelect(resultJson, displayLabel);
                    return;
                }

                if (fn.isSingleValue()) {
                    fn.reset();
                }

                fn.appendTag($.extend({
                    value: resultJson,
                    label: displayLabel
                }, internal.tagData));

                fn.getComponents();

                if (fn.isSingleValue()) {
                    elements.control.val(displayLabel);
                    internal.$e.addClass(m.TAG_SELECTED);
                } else {
                    elements.control.val('');
                }

                internal.$e.trigger('autocompleteSelect', resultJson);
                elements.control.trigger('change');
            },

            findResult: function (query) {
                var returnResult, queryRegEx;

                returnResult = null;
                queryRegEx = new RegExp('^' + $.trim(query) + '$', 'i');

                elements.result.each(function (i, resultEl) {
                    var $result, resultJson;

                    $result = $(resultEl);
                    resultJson = $result.data('result');

                    if (resultJson && (queryRegEx.test(resultJson.slug) || queryRegEx.test(resultJson.title))) {
                        returnResult = resultJson;
                        return false;
                    }
                });

                return returnResult;
            },

            doSearch: function (options) {
                options = options || {};

                fn.abortSearch();

                if (!elements.control.val().length && !options.initialResults) {
                    if (internal.defaultResults) {
                        fn.renderResults(internal.defaultResults, { toggleOpen: true });
                    } else {
                        fn.toggleDropMenu();
                    }

                    return;
                }

                internal.$e.addClass(m.PROCESSING);
                if (options.initialResults) {
                    internal.$e.addClass(m.PREFETCHING);
                }

                internal.currentSearch = internal.xhr.getHtml(fn.buildEndpoint(), {
                    complete: function () {
                        internal.$e.removeClass(m.PROCESSING);
                        if (options.initialResults) {
                            internal.$e.removeClass(m.PREFETCHING);
                        }
                    },
                    success: function (results) {
                        internal.searchTimeout = null;
                        fn.renderResults(results, options);
                    }
                });
            },

            throttledSearch: functionUtil.throttle(function () {
                fn.doSearch();
            }, o.searchDelay),

            abortSearch: function () {
                if (internal.currentSearch && internal.currentSearch.abort) {
                    internal.currentSearch.abort();
                }
            },

            buildEndpoint: function () {
                var endpoint = internal.endpoint,
                    query = elements.control.val(),
                    suffix = internal.$e.data('endpointSuffix'),
                    forAssociation = internal.$e.data('forAssociation');

                if (suffix) {
                    endpoint = endpoint + suffix;
                }

                if (!(query && query.length)) {
                    query = " ";
                }
                endpoint = endpoint.replace(/{{query}}/, encodeURIComponent(query));

                if (forAssociation) {
                    endpoint += endpoint.indexOf('?') > -1 ? '&' : '?';
                    endpoint += 'association=true';
                }

                return endpoint;
            },

            renderResults: function (results, options) {
                options = options || {};

                if (options.initialResults) {
                    if (results.indexOf(m.NO_RESULTS) < 0) {
                        elements.results.html(results);
                    }
                } else {
                    elements.results.html(results);
                }
                internal.dropMenu.update();
                fn.getComponents();

                if (!options.initialResults) {
                    fn.toggleDropMenu(options);
                } else {
                    internal.defaultResults = elements.results.html();
                }
            },

            clearResults: function () {
                elements.results.html('');
            },

            toggleDropMenu: function (options) {
                options = options || {};

                if (elements.control.val().length || options.toggleOpen) {
                    internal.dropMenu.open();
                } else {
                    internal.dropMenu.close();
                }
            },

            appendTag: function (tagData) {
                var $tag, tagExists, currentTags, valueKey;

                tagExists = false;
                currentTags = fn.getCurrentTags();
                valueKey = internal.$e.data('valueKey');

                $.each(currentTags, function (i, tag) {
                    var currentTagId, newTagId;

                    currentTagId = valueKey ? tag[valueKey] : tag.pk ? tag.pk : tag.slug;
                    newTagId = valueKey ? tagData.value[valueKey] : tagData.value.pk ? tagData.value.pk : tagData.value.slug;

                    if (currentTagId + '' === newTagId + '') {
                        tagExists = true;
                        return false;
                    }
                });

                if (tagExists) {
                    return;
                }

                if (valueKey) {
                    tagData.valueKey = valueKey;
                }

                $tag = $(templates.tag(tagData));
                $tag.data('valuePk', tagData.value.pk);

                elements.tags.append($tag);
                fn.getComponents();
                $tag.trigger('new:fieldset');
                internal.$e.trigger('change');
            },

            appendTags: function (tags) {
                $.each(tags, function (tag) {
                    fn.appendTag(tag);
                });
            },

            getCurrentTags: function () {
                var currentTags;

                currentTags = [];

                fn.getComponents();

                if (elements.tag) {
                    elements.tag.each(function (i, tagEl) {
                        var $tag, tagValue;

                        $tag = $(tagEl);
                        tagValue = $tag.data('tagValue');

                        currentTags.push(tagValue);
                    });
                }

                return currentTags;
            },

            removeTag: function (removeTagEl) {
                var $tag = $(removeTagEl).closest(internal.components.tag.selector),
                    fieldset = $tag.data('fieldsetInstance');

                if (fieldset) {
                    fieldset.removeEl();
                    internal.$e.trigger('change');
                    internal.$e.trigger('removeACTag');
                } else {
                    $tag.remove();
                }

                elements.tag = elements.tag.not($tag);

                fn.getComponents();
            },

            hasTags: function () {
                return elements.tags[0].children.length > 0;
            },

            reset: function () {
                fn.getComponents();
                if (elements.tag) {
                    elements.tag.each(function (i, tagEl) {
                        fn.removeTag(tagEl);
                    });
                }
                elements.control.val('');
            },

            setInputVal: function (val) {
                elements.control.val(val);
                fn.setTagSelectedState();
            },

            isInlineSearch: function () {
                return internal.$e.hasClass(m.INLINE_SEARCH_INPUT);
            },

            focus: function () {
                elements.control.focus();
            },

            setTagSelectedState: function () {
                var controlVal;

                controlVal = $.trim(elements.control.val());
                internal.$e.toggleClass(m.TAG_SELECTED, controlVal.length > 0);
            },

            prefillControlVal: function () {
                var controlVal = fn.getControlVal();

                if (!controlVal.length && internal.$e.hasClass(m.PREFILL_DEFAULT)) {
                    fn.renderResults(internal.defaultResults);
                    fn.getComponents();
                    elements.result.first().trigger('click');
                }
            },

            isDisabled: function () {
                return internal.$e.hasClass(m.DISABLED);
            },

            disable: function () {
                internal.$e.addClass(m.DISABLED);
            },

            doPrefetch: function () {
                return !internal.$e.hasClass(m.NO_PREFETCH);
            },

            prefetchResults: function (options) {
                options = options || {};

                if (options.clearFirst) {
                    fn.clearResults();
                }

                if (fn.doPrefetch()) {
                    fn.doSearch({ initialResults: true });
                }
            },

            ensureSingleValue: function () {
                var controlVal = fn.getControlVal();
                if (!controlVal.length) {
                    fn.reset();
                }
            }
        };

        handlers = {
            initCustomFieldsComplete: function () {
                fn.prefetchResults();
                fn.prefillControlVal();
            },

            controlFocus: function () {
                if (fn.isDisabled()) {
                    return;
                }

                fn.toggleDropMenu({
                    toggleOpen: elements.result && elements.result.length > 0
                });
                clearTimeout(internal.rotationTimer);
                internal.$e.addClass(m.FOCUS);
            },

            controlKeyup: function (evnt) {
                var alphanumRegex = /^[a-z\d\s]+$/i,
                    keyChar = String.fromCharCode(evnt.which),
                    isAlphanum = alphanumRegex.test(keyChar);

                if (fn.isDisabled()) {
                    return;
                }

                if (isAlphanum || evnt.which === kc.BACKSPACE || evnt.which === kc.SPACE) {
                    fn.throttledSearch();
                }
            },

            removeTagClick: function () {
                fn.removeTag(this);
            },

            controlBlur: function () {
                if (fn.isDisabled()) {
                    return;
                }

                internal.dropMenu.close({ delay: true });
                fn.abortSearch();
                fn.prefillControlVal();
                internal.$e.removeClass(m.FOCUS);

                if (fn.isSingleValue()) {
                    fn.ensureSingleValue();
                }
            },

            clearInputClick: function () {
                fn.setInputVal('');
                internal.$e.trigger('clearinput');
                fn.setTagSelectedState();
            },

            controlChange: function () {
                if (fn.isDisabled()) {
                    return;
                }

                fn.setTagSelectedState();
            },

            controlPaste: function () {
                if (fn.isDisabled()) {
                    return;
                }

                fn.throttledSearch();
            }
        };

        api = {
            hasTags: fn.hasTags,
            reset: fn.reset,
            appendTags: fn.appendTags,
            updateEndpoint: fn.updateEndpoint,
            setInputVal: fn.setInputVal,
            focus: fn.focus,
            findResult: fn.findResult,
            getResults: fn.getResults,
            getControlVal: fn.getControlVal,
            fadeInValue: fn.fadeInValue,
            setValByEl: fn.setValByEl,
            prefetchResults: fn.prefetchResults,
            disable: fn.disable
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    Autocomplete.markup = {
        ROTATING_VALUES: 'variant-rotating-values',
        INLINE_SEARCH_INPUT: 'variant-tag-search-input',
        TAG_SEARCH_INPUT: 'variant-tag-search-input',
        PREFILL_DEFAULT: 'variant-prefill-default',
        NO_PREFETCH: 'variant-no-prefetch',
        NO_RESULTS: 'variant-no-results',

        TAG_SELECTED: 'state-tag-selected',
        PREFETCHING: 'state-prefetching'
    };

    return Autocomplete;
});

define('forms/widgets/Datetime', [
    'jquery',
    'moment',
    'factories/moduleFactory'
], function (
    $,
    moment,
    moduleFactory
) {
    'use strict';

    var Datetime = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = Datetime.markup;

        o = $.extend({
            $e: null,
            selector: '.fieldset.datetime'
        }, options);

        internal = {
            name: 'Datetime',
            $e: o.$e || $(o.selector),

            isoTimeRegex: /([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]/,

            components: {
                datePicker: {
                    selector: '.date-picker'
                },
                time: {
                    selector: '.time'
                },
                datetimeField: {
                    selector: '.datetime-field'
                }
            },

            events: {
                'setupFieldsComplete': 'setupFieldsComplete',
                'fieldReady @dateTimeField': 'dateTimeFieldReady',
                'change @datePicker': 'datePickerChange',
                'change @time': 'timeChange'
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () { },

            setInitialValues: function () {
                var initialDateTime, isoTime;

                initialDateTime = elements.datetimeField.data('fieldInstance').getVal();

                if (!initialDateTime) {
                    return;
                }

                initialDateTime = moment(initialDateTime).format();
                isoTime = initialDateTime.match(internal.isoTimeRegex)[0];

                elements.datePicker.data('fieldInstance').setDefaultVal(initialDateTime);
                elements.time.data('fieldInstance').setDefaultVal(isoTime);
            },

            updateDateTime: function () {
                var date, time, dateTime;

                date = elements.datePicker.data('fieldInstance').getRawVal();
                time = elements.time.data('fieldInstance').getVal();

                if (time) {
                    dateTime = date.replace(internal.isoTimeRegex, time);
                } else {
                    dateTime = date;
                }

                dateTime = moment(dateTime).utc().format();

                elements.datetimeField.data('fieldInstance').setVal(dateTime);
            }

        };

        handlers = {
            datePickerChange: function () {
                fn.updateDateTime();
            },

            timeChange: function () {
                fn.updateDateTime();
            },

            dateTimeFieldReady: function () {
                fn.setInitialValues();
            },

            setupFieldsComplete: function (evnt, fieldset) {
                if (fieldset.getEl()[0] === internal.$e[0]) {
                    fn.setInitialValues();
                }
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    Datetime.markup = {};

    return Datetime;
});

define('forms/widgets/PublicationLink', [
    'jquery',
    'factories/moduleFactory',
    'forms/widgets/DropMenu'
], function (
    $,
    moduleFactory,
    DropMenu
) {
    'use strict';

    var PublicationLink = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = PublicationLink.markup;

        o = $.extend({
            $e: null,
            selector: '.publication-link'
        }, options);

        internal = {
            name: 'PublicationLink',

            fieldset: null,
            mode: 'read',

            components: {
                editComponents: {
                    selector: '.edit-components'
                },
                readComponents: {
                    selector: '.read-components'
                },
                fieldGroup: {
                    selector: '.field-group'
                },
                createLink: {
                    selector: '.create-link'
                },
                linkButton: {
                    selector: '.publication-link-button'
                },
                linkButtonLabel: {
                    selector: '.publication-link-button .label'
                },
                editDrop: {
                    selector: '.edit-drop',
                    constructor: DropMenu,
                    moduleOptions: {
                        selfToggle: true
                    }
                },
                editLink: {
                    selector: '.edit-link'
                },
                removeLink: {
                    selector: '.remove-link'
                }
            },

            events: {
                'click @createLink': 'createLinkClick',
                'click @editLink': 'editLinkClick',
                'click @removeLink': 'removeLinkClick'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.fieldset = internal.$e.data('fieldsetInstance');

                if (internal.fieldset.isReady()) {
                    fn.renderState();
                } else {
                    internal.$e.one('initCustomFieldsComplete', fn.renderState);
                }
            },

            getLinkData: function () {
                return {
                    title: internal.fieldset.getVal('publication_link_title'),
                    url: internal.fieldset.getVal('publication_link_url')
                };
            },

            linkIsValid: function () {
                var linkData;
                linkData = fn.getLinkData();
                return !!linkData.title;
            },

            getState: function () {
                if (fn.linkIsValid() && internal.mode !== 'edit') {
                    return 'read';
                } else {
                    return 'edit';
                }
            },

            createLink: function () {
                var linkData;
                linkData = fn.getLinkData();

                elements.linkButton.attr('href', linkData.url);
                elements.linkButtonLabel.html(linkData.title);

                internal.mode = 'read';
                fn.renderState();
            },

            removeLink: function () {
                internal.fieldset.reset();
                fn.renderState();
            },

            renderState: function () {
                var currentState, linkData;
                currentState = fn.getState();

                linkData = fn.getLinkData();

                elements.readComponents.toggleClass(m.HIDE, currentState === 'edit');
                elements.editComponents.toggleClass(m.HIDE, currentState === 'read');

                elements.linkButton.toggleClass(m.LINK_LESS, !linkData.url);
            }
        };

        handlers = {
            createLinkClick: function () {
                fn.createLink();
            },

            editLinkClick: function () {
                internal.mode = 'edit';
                fn.renderState();
            },

            removeLinkClick: function () {
                fn.removeLink();
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    PublicationLink.markup = {
        LINK_LESS: 'variant-link-less'
    };

    return PublicationLink;
});

define('forms/widgets/ShowWhenValid', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var ShowWhenValid = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = ShowWhenValid.markup;

        o = $.extend({
            $e: null,
            selector: '.show-when-valid'
        }, options);

        internal = {
            name: 'ShowWhenValid',
            $e: o.$e || $(o.selector),

            form: o.form,
            fieldset: o.fieldset,
            $fieldset: o.fieldset.getEl(),
            targetField: null,
            $target: null,

            components: {},
            events: {},

            autoComplete: null
        };

        elements = {
        };

        fn = {
            init: function () {
                fn.linkToTarget();

                if (internal.autoComplete) {
                    fn.setAutocompleteVisibility();
                } else {
                    fn.setVisibility();
                }
            },

            linkToTarget: function () {
                var targetName, autoComplete;

                autoComplete = internal.$e.data('linkAutocomplete');
                targetName = internal.$e.data('targetName');
                internal.targetField = internal.fieldset.getField(targetName);
                internal.$target = internal.targetField.getEls ? internal.targetField.getEls() : internal.targetField.getEl();

                if (autoComplete) {
                    internal.autoComplete = internal.$fieldset.find('.' + autoComplete);
                    internal.$target.on('change.showWhenValid', handlers.autocompleteChange);
                    internal.$fieldset.on('clearinput', handlers.autocompleteChange);
                } else {
                    internal.$target.on('change.showWhenValid', handlers.targetChange);
                }
            },

            setVisibility: function () {
                var targetIsValid, targetValue, targetValues;
                targetValue = internal.$e.data('targetValue');

                if (typeof targetValue === 'boolean') {
                    targetIsValid = internal.targetField.getVal() === targetValue;
                } else if (typeof targetValue === 'string') {
                    targetValues = targetValue.split(',');
                    targetIsValid = targetValues.indexOf(internal.targetField.getVal()) > -1;
                } else {
                    targetIsValid = internal.targetField.isValid();
                }

                internal.$e.toggleClass(m.HIDE, !targetIsValid);
            },

            setAutocompleteVisibility: function () {
                var fieldName, field, targetIsValid,
                    tagValue, targetValue;

                fieldName = internal.autoComplete.data('tagFieldName');
                field = targetIsValid = internal.fieldset.getField(fieldName);

                if (field) {
                    tagValue = $.trim(field.getEl().data('value').title);
                    targetValue = $.trim(internal.targetField.getVal());
                    targetIsValid = (tagValue && tagValue === targetValue);
                }

                internal.$e.toggleClass(m.HIDE, !targetIsValid);
            },

            destroy: function () {
                internal.$target.off('change.showWhenValid');
                internal.$target.off('clearinput', handlers.autocompleteChange);
            }
        };

        handlers = {
            targetChange: function (evnt) {
                if (evnt.target !== internal.$e[0]) {
                    fn.setVisibility();
                }
            },
            autocompleteChange: function (evnt) {
                if (evnt.target !== internal.$e[0]) {
                    fn.setAutocompleteVisibility();
                }
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    ShowWhenValid.markup = {};
    return ShowWhenValid;
});

define('forms/widgets/LicensePicker', [
    'jquery',
    'factories/moduleFactory',
    'utils/functionUtil'
], function (
    $,
    moduleFactory,
    functionUtil
) {
    'use strict';

    var LicensePicker = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = LicensePicker.markup;

        o = $.extend({
            $e: null,
            selector: 'fieldset.media-license'
        }, options);

        internal = {
            name: 'LicensePicker',
            $e: o.$e || $(o.selector),
            fieldset: null,

            ccLicenseComponents: {
                by: 'Attribution',
                nd: 'NoDerivatives',
                sa: 'ShareAlike',
                nc: 'NonCommercial',
                suffix: '4.0 International'
            },
            ccLicenseUrlTemplate: 'https://creativecommons.org/licenses/{{copyrightString}}/4.0/',

            components: {
                form: {
                    selector: '^form'
                },
                ccIcons: {
                    selector: '.cc-icon'
                },
                ccLicenseLink: {
                    selector: '^form .cc-license-link'
                }
            },

            events: {
                'change': 'licenseChange'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.fieldset = internal.$e.data('fieldsetInstance');
                fn.setInitialState();
            },

            setInitialState: function () {
                var formData, licenseParts;

                formData = internal.fieldset.getData();
                licenseParts = formData.copyright_string.split('-');

                if (licenseParts[0] === 'cc') {
                    internal.fieldset.setVals({
                        is_creative_commons: true,
                        adaptations: (formData.copyright_string.match(/nd|sa/) || [''])[0],
                        commercial: (formData.copyright_string.match(/nc/) || [''])[0]
                    });
                }
            },

            updateCCLicense: functionUtil.debounce(function () {
                var formData, isCC, adaptations, commercial, licenseParts;

                formData = internal.fieldset.getData();
                isCC = formData.is_creative_commons;

                if (isCC) {
                    licenseParts = ['cc', 'by'];

                    adaptations = formData.adaptations || '';
                    commercial = formData.commercial || '';

                    if (commercial.length) {
                        licenseParts.push(commercial);
                    }
                    if (adaptations.length) {
                        licenseParts.push(adaptations);
                    }

                    internal.fieldset.setVals({
                        'copyright_string': licenseParts.join('-'),
                        'adaptations': adaptations,
                        'commercial': commercial
                    }, null, { silent: true });

                    fn.updateCCIcons(licenseParts);
                    fn.updateCCLicenseLink();
                } else {
                    internal.fieldset.setVals({
                        'copyright_string': '',
                        'adaptations': '',
                        'commercial': ''
                    }, null, { silent: true });
                }
            }, 100, true),

            updateCCIcons: function (licenseParts) {
                var $icons, classPrefix;

                $icons = elements.ccIcons.not('.cc-cc');
                classPrefix = 'cc-';

                $icons.addClass(m.HIDE);
                licenseParts.forEach(function (licensePart) {
                    $icons.filter('.' + classPrefix + licensePart).removeClass(m.HIDE);
                });
            },

            updateCCLicenseLink: function () {
                var copyrightString, stringParts, licenseCopy, licenseUrl;

                copyrightString = internal.fieldset.getVal('copyright_string');
                copyrightString = copyrightString.replace('cc-', '');
                stringParts = copyrightString.split('-');
                licenseCopy = [];

                stringParts.forEach(function (stringPart) {
                    licenseCopy.push(internal.ccLicenseComponents[stringPart]);
                });

                licenseCopy = licenseCopy.join('-');
                licenseCopy = licenseCopy + ' ' + internal.ccLicenseComponents.suffix;

                licenseUrl = internal.ccLicenseUrlTemplate.replace('{{copyrightString}}', copyrightString);

                elements.ccLicenseLink.attr('href', licenseUrl);
                elements.ccLicenseLink.html(licenseCopy);
            }
        };

        handlers = {
            licenseChange: function (evnt) {
                var $target, targetName;

                $target = $(evnt.target);
                targetName = $target.attr('name');

                if (targetName !== 'copyright_string') {
                    fn.updateCCLicense();
                }
            }
        };

        api = {};

        // Use the moduleFactory to setup this module
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    LicensePicker.markup = {};

    return LicensePicker;
});

define('utils/appendValToObj', [
    'jquery'
], function (
    $
) {
    'use strict';
    var appendValToObj, merge;

    appendValToObj = function (dataObj, name, value) {
        var nameArray, nameDotted, baseName, currentObjDepth,
            prevObjDepth, lastKey;

        name = name || '';
        nameArray = name.match(/\[(.*?)\]/g) || false;
        baseName = name.replace(/\[(.*?)\]/g, '');

        nameDotted = baseName.split('.');
        baseName = nameDotted.shift();

        dataObj = dataObj || {};
        currentObjDepth = dataObj;
        prevObjDepth = dataObj;
        lastKey = baseName;

        if (baseName && baseName.length) {
            dataObj[baseName] = dataObj[baseName] || {};
            prevObjDepth = dataObj;
            lastKey = baseName;
            currentObjDepth = dataObj[baseName];
        }

        if (nameDotted.length) {
            $.each(nameDotted, function (i, nameKey) {
                currentObjDepth[nameKey] = currentObjDepth[nameKey] || {};
                prevObjDepth = currentObjDepth;
                lastKey = nameKey;
                currentObjDepth = currentObjDepth[nameKey];
            });
        }

        if (nameArray.length) {
            if (!$.isArray(prevObjDepth[lastKey])) {
                prevObjDepth[lastKey] = [];
            }

            if (!value) {
                return;
            }

            if (value[lastKey] && $.isArray(value[lastKey])) {
                $.each(value[lastKey], function (i, valueItem) {
                    prevObjDepth[lastKey].push(valueItem);
                });
            } else {
                $.each(nameArray, function (i, nameItem) {
                    var nameKey = nameItem.match(/\[(.*?)\]/) || false,
                        itemVal;

                    if (nameKey && nameKey[1].length) {
                        itemVal = {};
                        appendValToObj(itemVal, nameKey[1], value);
                    } else {
                        itemVal = value;
                    }

                    if (!$.isEmptyObject(itemVal)) {
                        prevObjDepth[lastKey].push(itemVal);
                    }
                });
            }
        } else {
            if ($.isPlainObject(value)) {
                if (lastKey && lastKey.length) {
                    if (value[lastKey]) {
                        merge(prevObjDepth, value);
                    } else {
                        merge(prevObjDepth[lastKey], value);
                    }
                } else {
                    merge(prevObjDepth, value);
                }
            } else {
                prevObjDepth[lastKey] = value;
            }
        }
    };

    merge = function (obj1, obj2) {
        $.each(obj2, function (key, value) {
            if ($.isPlainObject(value)) {
                if (obj1[key]) {
                    merge(obj1[key], value);
                } else {
                    obj1[key] = value;
                }
            } else if ($.isArray(value)) {
                if (obj1[key]) {
                    $.each(value, function (i, valueItem) {
                        obj1[key].push(valueItem);
                    });
                } else {
                    obj1[key] = value;
                }
            } else {
                obj1[key] = value;
            }
        });
    };

    return appendValToObj;
});

define('forms/Fieldset', [
    'jquery',
    'uuidv4',
    'factories/moduleFactory',
    'forms/fields/CustomInput',
    'forms/fields/CustomTextarea',
    'forms/fields/CustomRadio',
    'forms/fields/CustomCheckbox',
    'forms/fields/CustomSelect',
    'forms/fields/LinkedCustomSelect',
    'forms/fields/RichContentEditor',
    'forms/fields/JsonField',
    'forms/fields/FileDrop',
    'forms/fields/DatePicker',
    'forms/fields/Time',
    'forms/fields/HtmlField',
    'forms/widgets/FocalPoint',
    'forms/widgets/Autocomplete',
    'forms/widgets/Datetime',
    'forms/widgets/PublicationLink',
    'forms/widgets/ShowWhenValid',
    'forms/widgets/DropMenu',
    'forms/widgets/LicensePicker',
    'utils/appendValToObj'
], function (
    $,
    uuidv4,
    moduleFactory,
    CustomInput,
    CustomTextarea,
    CustomRadio,
    CustomCheckbox,
    CustomSelect,
    LinkedCustomSelect,
    RichContentEditor,
    JsonField,
    FileDrop,
    DatePicker,
    Time,
    HtmlField,
    FocalPoint,
    Autocomplete,
    Datetime,
    PublicationLink,
    ShowWhenValid,
    DropMenu,
    LicensePicker,
    appendValToObj
) {
    'use strict';
    /*
        Fieldset
        ========

        This is used to wrap the fields inside of a form to allow for them
        to be logically grouped into optional sub objects and arrays

        Example:

        var fieldset = new Fieldset({
            $e: $(el)
        });

        <fieldset> <!-- This will not wrap its content in a sub-object -->
            ... Fields and nested fieldsets...
        </fieldset>

        <fieldset name='foo'><!-- This WILL wrap its content in a sub-object {foo:...} ->
            ... Fields and nested fieldsets...
        </fielset>

        <fieldset name='bar'><!-- This WILL wrap its content in a sub-array {bar: [...]} ->
            ... Fields and nested fieldsets...
        </fielset>

        NB:
        - This module is setup and initialized by default by Form.js
    */
    var Fieldset = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = Fieldset.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: 'fieldset'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'Fieldset',
            $e: o.$e || $(o.selector),
            explicitInit: true,

            // Caches for child fieldsets and fields
            fieldsets: [],
            fields: [],

            // Map of DOM selectors to field constructors
            fieldConstructors: {
                '.custom-input': CustomInput,
                '.custom-radio': CustomRadio,
                '.custom-checkbox': CustomCheckbox,
                '.custom-select': CustomSelect,
                '.custom-textarea': CustomTextarea,
                '.linked-custom-select': LinkedCustomSelect,
                '.editable-content': RichContentEditor,
                '.json-field': JsonField,
                '.html-field': HtmlField,
                '.file-drop': FileDrop,
                '.date-picker': DatePicker,
                '.time': Time
            },

            widgetConstructors: {
                '.autocomplete': Autocomplete,
                '.datetime': Datetime,
                '.publication-link': PublicationLink,
                '.focal-point': FocalPoint,
                '.license-picker': LicensePicker
            },

            componentWidgets: {
                showWhenValid: ShowWhenValid,
                editDrop: {
                    constructor: DropMenu,
                    options: {
                        selfToggle: true
                    }
                }
            },

            // Dict of components used by this module.
            components: {
                fieldset: {
                    selector: 'fieldset, .fieldset',
                    ignoreNested: true
                },
                sortableFieldsets: {
                    selector: '.sortable-fieldsets'
                },
                showWhenValid: {
                    selector: '.show-when-valid',
                    directChildrenOnly: true
                },
                editDrop: {
                    selector: '.edit-drop',
                    directChildrenOnly: true
                },
                resetFieldset: {
                    selector: '.reset-fieldset'
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'setupFieldsComplete @fieldset': 'fieldsetSetupFieldsComplete',
                'destroy @fieldset': 'fieldsetDestroy',
                'destroy @field': 'fieldDestroy',
                'new:fieldset @fieldset': 'fieldsetNew',
                'sort': 'fieldsetsSort',
                'orderfieldsets': 'internalOrderFieldsets',
                'click @resetFieldset': 'resetFieldsetClick'
            }
        };

        // Elements cache
        elements = {};

        // Primary methods
        fn = {
            // First initialize any child fieldsets. If no child fieldsets found
            // then initialize any fields found and triggle a complete event
            init: function () {
                fn.generateFieldsetId();
                fn.initChildFieldsets();
                fn.initWidgets();

                if (!elements.fieldset) {
                    fn.setupCustomFields();
                }

                internal.$e.one('initCustomFieldsComplete', fn.initComponentWidgets);
            },

            generateFieldsetId: function () {
                internal.$e.data('fieldsetId', uuidv4());
            },

            // Iterate over child fieldsets elements, use them to init instances
            // of the Fieldset module, cache the returned instances.
            initChildFieldsets: function () {
                if (!elements.fieldset) {
                    return;
                }

                elements.fieldset.each(function (i, fieldset) {
                    fn.setupFieldset(fieldset);
                });

                $.each(internal.fieldsets, function (i, fieldset) {
                    fieldset.init();
                });
            },

            setupFieldset: function (fieldset, callInit) {
                var fieldsetInstance;
                callInit = callInit || false;

                fieldsetInstance = new Fieldset({
                    $e: $(fieldset),
                    form: o.form,
                    parentFieldset: self
                });

                internal.fieldsets.push(fieldsetInstance);

                if (callInit) {
                    fieldsetInstance.init();
                }
            },

            // Ensure the cached fieldset instances are in the same order as
            // the elements in the DOM
            orderFieldsets: function () {
                var orderedFieldsets = [], fieldsets;

                if (internal.$e.data('orderedFieldsets')) {
                    fieldsets = internal.$e.data('orderedFieldsets')();
                } else {
                    fn.getComponents();
                    fieldsets = elements.fieldset;
                }

                fieldsets.each(function (i, fieldsetEl) {
                    $.each(internal.fieldsets, function (j, fieldset) {
                        if (fieldset.getEl()[0] === fieldsetEl) {
                            orderedFieldsets[i] = fieldset;
                        }
                    });
                });

                internal.fieldsets = orderedFieldsets;
            },

            initWidgets: function () {
                $.each(internal.widgetConstructors, function (selector, Widget) {
                    if (internal.$e.is(selector)) {
                        new Widget({
                            $e: internal.$e,
                            fieldset: self,
                            form: o.form
                        });
                    }
                });
            },

            initComponentWidgets: function () {
                $.each(internal.componentWidgets, function (componentKey, Widget) {
                    if (elements[componentKey]) {
                        elements[componentKey].each(function (i, componentEl) {
                            if (typeof Widget === 'object') {
                                new Widget.constructor($.extend({
                                    $e: $(componentEl),
                                    fieldset: self
                                }, Widget.options));
                            } else {
                                new Widget({
                                    $e: $(componentEl),
                                    fieldset: self
                                });
                            }
                        });
                    }
                });
            },

            // Iterate over the field constructors, look for and iterate over
            // and fields found in the DOM. Initialize a constructor for each
            // field element and cache the returned instance
            setupCustomFields: function (options) {
                var allFieldsetsSetup;

                options = options || {};
                allFieldsetsSetup = true;

                $.each(internal.fieldsets, function (i, fieldset) {
                    allFieldsetsSetup = fieldset.isSetup();
                    return allFieldsetsSetup;
                });

                if (
                    !allFieldsetsSetup ||
                    elements.fieldset &&
                    internal.fieldsets.length !== elements.fieldset.length
                ) {
                    return;
                }

                $.each(internal.fieldConstructors, function (fieldSelector, FieldConstructor) {
                    internal.$e.find(fieldSelector).each(function (i, field) {
                        var $field = $(field),
                            fieldInstance;

                        if (!$field.hasClass(m.SETUP)) {
                            fieldInstance = new FieldConstructor({
                                $e: $field,
                                form: o.form,
                                fieldset: self
                            });
                            internal.fields.push(fieldInstance);
                        }
                    });
                });

                internal.$e.data('setupComplete', true);

                if (!options.silent) {
                    internal.$e.trigger('setupFieldsComplete', self);
                }

            },

            isSetup: function () {
                return internal.$e.data('setupComplete') || false;
            },

            isReady: function () {
                return internal.$e.data('initCustomFieldsComplete') || false;
            },

            // Iterate over the cached field instances and call their init method.
            // NB: All fields are set to be explicitly initialized
            initCustomFields: function () {

                $.each(internal.fields, function (i, field) {
                    if (!field.isInited()) {
                        field.init();
                    }
                });

                $.each(internal.fieldsets, function (i, fieldset) {
                    fieldset.initCustomFields();
                });

                if (internal.$e.data('initCustomFieldsComplete')) {
                    return;
                }

                internal.$e.data('initCustomFieldsComplete', true);
                internal.$e.trigger('initCustomFieldsComplete', self);
            },

            getFieldsetId: function () {
                return internal.$e.data('fieldsetId');
            },

            // Get and return the name of the current fieldset
            getName: function () {
                return internal.$e.attr('name') || internal.$e.data('name') || '';
            },

            getClosestParentName: function () {
                var fieldsetName = fn.getName();
                return fieldsetName.length ? fieldsetName : o.parentFieldset ? o.parentFieldset.getClosestParentName() : '';
            },

            // Get a field by name. Will check through child fieldsets if the
            // field is not found in the current fieldset. If no field is found
            // will return false
            getField: function (fieldName, parentKey) {
                var returnField, nameRegEx, noParentKey, parentKeyRegex, fieldsetName, closestParentName;

                if (!fieldName.length) {
                    return;
                }

                returnField = false;

                noParentKey = !parentKey && typeof parentKey !== 'string';
                parentKey = parentKey || '';
                fieldsetName = fn.getName();
                closestParentName = fn.getClosestParentName();

                parentKeyRegex = new RegExp((parentKey || '').replace(/\[.*?\]/, '') + '(\\[.*?\\])?');
                nameRegEx = new RegExp('^' + fieldName.replace(/\[.*?\]/, '') + '(\\[.*?\\])?' + '$');

                if (fieldsetName.length) {
                    closestParentName = fieldsetName;
                }

                $.each(internal.fields, function (i, field) {
                    var internalFieldName = field.getName();

                    if (!internalFieldName) {
                        return;
                    }

                    if (
                        internalFieldName.length &&
                        nameRegEx.test(internalFieldName) &&
                        (
                            noParentKey ||
                            !parentKey.length && !closestParentName.length ||
                            parentKey.length && parentKeyRegex.test(closestParentName)
                        )
                    ) {
                        returnField = field;
                        return false;
                    }
                });

                if (!returnField) {
                    $.each(internal.fieldsets, function (i, fieldset) {
                        returnField = fieldset.getField(fieldName, (noParentKey ? null : parentKey), closestParentName);

                        if (returnField) {
                            return false;
                        }
                    });
                }

                return returnField;
            },

            // Get an array of fields by name. Will check through child fieldsets
            // for matching fields as well. If no fields are found an empty array
            // will be returned.
            getFields: function (fieldName) {
                var returnFields = [];

                $.each(internal.fields, function (i, field) {
                    if (field.getName() === fieldName) {
                        returnFields.push(field);
                    }
                });

                $.each(internal.fieldsets, function (i, fieldset) {
                    var fieldsetFields = fieldset.getFields(fieldName);

                    $.each(fieldsetFields, function (i, fieldsetField) {
                        returnFields.push(fieldsetField);
                    });
                });

                return returnFields;
            },

            // Iterate over all cached fieldsets and fields and return an object
            // with the `{ names: (value / object / array) }`.
            getData: function (options) {
                var rootData = {},
                    collatedData = {},
                    fieldData = null,
                    rootName = fn.getName(),
                    nullIfBlank = internal.$e.data('nullIfBlank'),
                    emptyName = internal.$e.data('emptyName'),
                    isEmptyArray = emptyName ? emptyName.match(/\[(.*?)\]/g) || false : false,
                    allFieldsBlank = true;

                options = options || {};

                $.each(internal.fieldsets, function (i, fieldset) {
                    var fieldsetName = fieldset.getName(),
                        fieldsetValue;

                    if (fieldset.ignore() && !options.all) {
                        return;
                    }

                    fieldsetValue = fieldset.getData();
                    appendValToObj(collatedData, fieldsetName, fieldsetValue);
                });

                $.each(internal.fields, function (i, field) {
                    var fieldName = field.getName(),
                        fieldValue = field.getVal();

                    if (field.ignore() && !options.all) {
                        return;
                    }

                    if (field.nullIfBlank() && field.isBlank()) {
                        fieldValue = null;
                    }

                    if (/^(true|false)$/i.test(fieldValue)) {
                        fieldValue = /^true$/i.test(fieldValue);
                    }

                    fieldData = fieldData || {};

                    if (!field.isBlank()) {
                        allFieldsBlank = false;
                    }

                    appendValToObj(fieldData, fieldName, fieldValue);
                });

                if (nullIfBlank && allFieldsBlank) {
                    fieldData = {};
                }

                if (fieldData && !$.isEmptyObject(fieldData)) {
                    $.extend(true, collatedData, fieldData);
                }

                if (!$.isEmptyObject(collatedData)) {
                    appendValToObj(rootData, rootName, collatedData);
                }

                if (
                    $.isEmptyObject(rootData)
                ) {
                    if (isEmptyArray) {
                        rootData[emptyName.replace(/\[(.*?)\]/g, '')] = [];
                    } else {
                        rootData = nullIfBlank ? null : '';
                    }
                }

                return rootData;
            },

            // Before this fieldset is destroyed iteratively destroy all child
            // fieldsets and fields
            beforeDestroy: function () {
                var currentFieldsets = internal.fieldsets.slice(0),
                    currentFields = internal.fields.slice(0);

                $.each(currentFieldsets, function (i, fieldset) {
                    fieldset.destroy();
                });

                $.each(currentFields, function (i, field) {
                    field.destroy();
                });
            },

            // If any child fieldsets are destroyed, remove it from the cache.
            removeDestroyedFieldset: function (fieldsetEl) {
                var fieldsetIndex = -1;

                $.each(internal.fieldsets, function (i, fieldset) {
                    if (fieldset.getEl()[0] === fieldsetEl[0]) {
                        fieldsetIndex = i;
                        return false;
                    }
                });

                if (fieldsetIndex > -1) {
                    internal.fieldsets.splice(fieldsetIndex, 1);
                    fn.getComponents();
                }
            },

            // If any child fields are destroyed, remove it from the cache.
            removeDestroyedField: function (fieldEl) {
                var fieldIndex = -1;

                $.each(internal.fields, function (i, field) {
                    if (field.getEl()[0] === fieldEl) {
                        fieldIndex = i;
                        return false;
                    }
                });

                if (fieldIndex > -1) {
                    internal.fields.splice(fieldIndex, 1);
                    fn.getComponents();
                }
            },

            // Validate child fieldsets and child fields
            validate: function () {
                $.each(internal.fieldsets, function (i, fieldset) {
                    fieldset.validate();
                });
                $.each(internal.fields, function (i, field) {
                    field.validate();
                });
            },

            reset: function (resetOpts) {
                $.each(internal.fieldsets, function (i, fieldset) {
                    fieldset.reset(resetOpts);
                });

                $.each(internal.fields, function (i, field) {
                    field.reset(resetOpts);
                });
            },

            setVals: function (valObj, parentKey, options) {
                $.each(valObj, function (fieldKey, value) {
                    var field = fn.getField(fieldKey, parentKey);

                    if (field) {
                        field.setVal(value, options);
                    } else if ($.isPlainObject(value)) {
                        fn.setVals(value, fieldKey, options);
                    }
                });
            },

            getVal: function (fieldKey) {
                var field = fn.getField(fieldKey);
                if (field) {
                    return field.getVal();
                } else {
                    return null;
                }
            },

            getVals: function (fieldKeyArr) {
                var vals = {};

                $.each(fieldKeyArr, function (i, fieldKey) {
                    vals[fieldKey] = fn.getVal(fieldKey);
                });

                return vals;
            },

            ignore: function () {
                return !!internal.$e.data('ignore');
            },

            focusFirst: function () {
                internal.fields[0].focus();
            }
        };

        // Event handlers
        handlers = {
            fieldsetSetupFieldsComplete: function (evnt) {
                if (!evnt.intercepted) {
                    evnt.intercepted = true;
                    fn.setupCustomFields();
                }
            },

            fieldsetDestroy: function (evnt, fieldset) {
                var fieldsetEl;

                if (
                    evnt.intercepted ||
                    !fieldset
                ) {
                    return;
                }
                evnt.intercepted = true;

                fieldsetEl = fieldset.self.getEl();
                fn.removeDestroyedFieldset(fieldsetEl);

                setTimeout(function () {
                    fn.orderFieldsets();
                }, 50);
            },

            fieldDestroy: function (evnt) {
                if (evnt.intercepted) {
                    return;
                }

                evnt.intercepted = true;

                fn.removeDestroyedField(this);
            },

            fieldsetNew: function (evnt) {
                if (evnt.intercepted) {
                    return;
                }

                evnt.intercepted = true;

                if (!$(this).data('fieldsetInstance')) {
                    fn.getComponents();
                    fn.setupFieldset(this, true);
                    fn.orderFieldsets();
                }
            },

            fieldsetsSort: function () {
                fn.orderFieldsets();
            },

            internalOrderFieldsets: function () {
                fn.orderFieldsets();
            },

            resetFieldsetClick: function () {
                fn.reset();
            }
        };

        // Interface methods to be exposed
        api = {
            setupCustomFields: fn.setupCustomFields,
            initCustomFields: fn.initCustomFields,
            getFieldsetId: fn.getFieldsetId,
            getName: fn.getName,
            getData: fn.getData,
            getField: fn.getField,
            getFields: fn.getFields,
            validate: fn.validate,
            reset: fn.reset,
            isSetup: fn.isSetup,
            isReady: fn.isReady,
            setVals: fn.setVals,
            getVal: fn.getVal,
            getVals: fn.getVals,
            getClosestParentName: fn.getClosestParentName,
            ignore: fn.ignore,
            focusFirst: fn.focusFirst
        };

        // Use the moduleFactory to setup this module
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    Fieldset.markup = {};

    return Fieldset;
});

define('forms/widgets/FieldsetCloner', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var FieldsetCloner = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = FieldsetCloner.markup;

        o = $.extend({
            selector: 'form'
        }, options);

        internal = {
            name: 'FieldsetCloner',
            $e: o.$e || $(o.selector),

            templates: {
                removeClonedFieldset: {
                    selector: '!.remove-cloned-fieldset-template'
                }
            },

            components: {
                fieldsetCloner: {
                    selector: '.fieldset-cloner'
                },
                removeFieldsetControl: {
                    selector: '.remove-fieldset-control'
                }
            },

            events: {
                'click @fieldsetCloner': 'fieldsetClonerClick',
                'focus @fieldsetCloner': 'fieldsetClonerFocus',
                'click @removeFieldsetControl': 'removeFieldsetControlClick',
                'sort': 'internalElSort'
            }
        };

        elements = {};

        templates = {};

        fn = {
            init: function () {
                fn.setInitialStates();
            },

            setInitialStates: function () {
                elements.fieldsetCloner.each(function (i, fieldsetCloner) {
                    var $fieldsetCloner, targetSelector;

                    $fieldsetCloner = $(fieldsetCloner);
                    targetSelector = $fieldsetCloner.data('target');

                    if (targetSelector === 'self') {
                        targetSelector = '[name="' + $fieldsetCloner.attr('name') + '"]';
                    }

                    fn.processClones($fieldsetCloner, targetSelector);
                });
            },

            processClones: function ($fieldsetCloner, fieldsetSelector) {
                var $clones, maxClones;

                $clones = internal.$e.find('fieldset' + fieldsetSelector);
                maxClones = $fieldsetCloner.data('maxClones');
                maxClones = maxClones ? parseInt(maxClones) : null;

                if (maxClones && $clones.length > maxClones) {
                    $fieldsetCloner.hide();
                } else {
                    $fieldsetCloner.show();
                }

                if ($clones.length > 1) {
                    $clones.each(function (i, clone) {
                        fn.appendRemoveControl(clone, fieldsetSelector, $fieldsetCloner, i, $clones.length);
                    });
                } else {
                    $clones.each(function (i, clone) {
                        fn.removeRemoveControl(clone, $fieldsetCloner, i, $clones.length);
                    });
                }

                fn.getComponents();
            },

            appendRemoveControl: function (fieldset, fieldsetSelector, $fieldsetCloner, index, cloneCount) {
                var $removeControl, $fieldset, customControl, $customControl, clearLast;

                $fieldset = $(fieldset);
                customControl = $fieldsetCloner.data('customControl');
                clearLast = $fieldsetCloner.data('clearLast');

                if (customControl) {
                    $customControl = $fieldset.find(customControl);
                }

                if ($fieldset.hasClass(m.CLONED) || $fieldset.hasClass(m.CLONER)) {
                    return;
                }

                $removeControl = customControl ? $fieldset.find('.' + m.REMOVE_FIELDSET_CONTROL) : templates.removeClonedFieldset.clone();
                $removeControl.data('target', fieldsetSelector);
                $removeControl.data('$fieldsetCloner', $fieldsetCloner);

                if (customControl) {
                    $customControl.show();

                    if (clearLast) {
                        fn.setCustomControlState($fieldset, index, cloneCount);
                    }
                } else {
                    $fieldset.append($removeControl);
                }

                $fieldset.addClass(m.CLONED);
            },

            removeRemoveControl: function (fieldset, $fieldsetCloner, index, cloneCount) {
                var $fieldset, customControl, $customControl, clearLast;

                $fieldset = $(fieldset);
                customControl = $fieldsetCloner.data('customControl');
                clearLast = $fieldsetCloner.data('clearLast');

                if (customControl) {
                    $customControl = $fieldset.find(customControl);
                }

                if (customControl) {
                    if (clearLast) {
                        fn.setCustomControlState($fieldset, index, cloneCount);
                    } else {
                        $customControl.hide();
                    }
                } else {
                    $fieldset.find('.' + m.REMOVE_CLONED_FIELDSET).remove();
                }

                $fieldset.removeClass(m.CLONED);
            },

            setCustomControlState: function ($fieldset, fieldsetIndex, cloneCount) {
                var $removeControl, $resetFieldset;

                $resetFieldset = $fieldset.find('.' + m.RESET_FIELDSET);
                $removeControl = $fieldset.find('.' + m.REMOVE_FIELDSET_CONTROL);

                if (fieldsetIndex === 0 && cloneCount === 1) {
                    $removeControl.hide();
                    $resetFieldset.show();
                } else {
                    $removeControl.show();
                    $resetFieldset.hide();
                }
            },

            cloneFieldset: function (fieldsetCloner) {
                var $fieldsetCloner, targetSelector, $lastFieldset,
                    $clonedFieldset, fieldsetInstance;

                $fieldsetCloner = $(fieldsetCloner);
                targetSelector = $fieldsetCloner.data('target');

                if (targetSelector === 'self') {
                    $clonedFieldset = $fieldsetCloner.clone();
                    $clonedFieldset.removeClass(m.CLONER);
                    $clonedFieldset.insertBefore($fieldsetCloner);
                    targetSelector = '[name="' + $fieldsetCloner.attr('name') + '"]';
                } else {
                    $lastFieldset = internal.$e.find('fieldset' + targetSelector).last();
                    $clonedFieldset = $lastFieldset.clone();
                    $clonedFieldset.removeClass(m.CLONED);
                    $clonedFieldset.insertAfter($lastFieldset);
                }

                $clonedFieldset.find('.' + m.SETUP).removeClass(m.SETUP);
                $clonedFieldset.find('.' + m.INITED).removeClass(m.INITED);

                $clonedFieldset.trigger('new:fieldset');

                fieldsetInstance = $clonedFieldset.data('fieldsetInstance');
                fieldsetInstance.reset();
                fieldsetInstance.focusFirst();

                fn.processClones($fieldsetCloner, targetSelector);
            },

            removeClonedFieldset: function (removeControl) {
                var $removeControl, $fieldset, $fieldsetCloner,
                    fieldsetInstance, fieldsetSelector;

                $removeControl = $(removeControl);
                $fieldset = $removeControl.closest('fieldset.' + m.CLONED).first();
                $fieldsetCloner = $removeControl.data('$fieldsetCloner');

                fieldsetInstance = $fieldset.data('fieldsetInstance');
                fieldsetSelector = $removeControl.data('target');

                fieldsetInstance.removeEl();

                fn.processClones($fieldsetCloner, fieldsetSelector);
            }
        };

        handlers = {
            fieldsetClonerClick: function () {
                fn.cloneFieldset(this);
            },

            fieldsetClonerFocus: function () {
                fn.cloneFieldset(this);
            },

            removeFieldsetControlClick: function () {
                fn.removeClonedFieldset(this);
            },

            internalElSort: function () {
                fn.getComponents();
                fn.setInitialStates();
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    FieldsetCloner.markup = {
        CLONER: 'fieldset-cloner',
        CLONED: 'state-cloned',
        REMOVE_CLONED_FIELDSET: 'remove-cloned-fieldset',
        REMOVE_FIELDSET_CONTROL: 'remove-fieldset-control',
        RESET_FIELDSET: 'reset-fieldset'
    };

    return FieldsetCloner;
});

/*! Sortable 1.14.0 - mit | git://github.com/SortableJS/Sortable.git */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define('Sortable', e) : (t = t || self).Sortable = e() }(this, function () { "use strict"; function e(e, t) { var n, o = Object.keys(e); return Object.getOwnPropertySymbols && (n = Object.getOwnPropertySymbols(e), t && (n = n.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), o.push.apply(o, n)), o } function A(o) { for (var t = 1; t < arguments.length; t++) { var i = null != arguments[t] ? arguments[t] : {}; t % 2 ? e(Object(i), !0).forEach(function (t) { var e, n; e = o, t = i[n = t], n in e ? Object.defineProperty(e, n, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[n] = t }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach(function (t) { Object.defineProperty(o, t, Object.getOwnPropertyDescriptor(i, t)) }) } return o } function o(t) { return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function a() { return (a = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n, o = arguments[e]; for (n in o) Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]) } return t }).apply(this, arguments) } function i(t, e) { if (null == t) return {}; var n, o = function (t, e) { if (null == t) return {}; for (var n, o = {}, i = Object.keys(t), r = 0; r < i.length; r++)n = i[r], 0 <= e.indexOf(n) || (o[n] = t[n]); return o }(t, e); if (Object.getOwnPropertySymbols) for (var i = Object.getOwnPropertySymbols(t), r = 0; r < i.length; r++)n = i[r], 0 <= e.indexOf(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (o[n] = t[n]); return o } function r(t) { return function (t) { if (Array.isArray(t)) return l(t) }(t) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(t) || function (t, e) { if (t) { if ("string" == typeof t) return l(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Map" === (n = "Object" === n && t.constructor ? t.constructor.name : n) || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(t, e) : void 0 } }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function l(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, o = new Array(e); n < e; n++)o[n] = t[n]; return o } function t(t) { if ("undefined" != typeof window && window.navigator) return !!navigator.userAgent.match(t) } var y = t(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), w = t(/Edge/i), s = t(/firefox/i), u = t(/safari/i) && !t(/chrome/i) && !t(/android/i), n = t(/iP(ad|od|hone)/i), c = t(/chrome/i) && t(/android/i), d = { capture: !1, passive: !1 }; function h(t, e, n) { t.addEventListener(e, n, !y && d) } function f(t, e, n) { t.removeEventListener(e, n, !y && d) } function p(t, e) { if (e && (">" === e[0] && (e = e.substring(1)), t)) try { if (t.matches) return t.matches(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e) } catch (t) { return } } function N(t, e, n, o) { if (t) { n = n || document; do { if (null != e && (">" !== e[0] || t.parentNode === n) && p(t, e) || o && t === n) return t } while (t !== n && (t = (i = t).host && i !== document && i.host.nodeType ? i.host : i.parentNode)) } var i; return null } var g, m = /\s+/g; function I(t, e, n) { var o; t && e && (t.classList ? t.classList[n ? "add" : "remove"](e) : (o = (" " + t.className + " ").replace(m, " ").replace(" " + e + " ", " "), t.className = (o + (n ? " " + e : "")).replace(m, " "))) } function P(t, e, n) { var o = t && t.style; if (o) { if (void 0 === n) return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), void 0 === e ? n : n[e]; o[e = !(e in o || -1 !== e.indexOf("webkit")) ? "-webkit-" + e : e] = n + ("string" == typeof n ? "" : "px") } } function v(t, e) { var n = ""; if ("string" == typeof t) n = t; else do { var o = P(t, "transform") } while (o && "none" !== o && (n = o + " " + n), !e && (t = t.parentNode)); var i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix; return i && new i(n) } function b(t, e, n) { if (t) { var o = t.getElementsByTagName(e), i = 0, r = o.length; if (n) for (; i < r; i++)n(o[i], i); return o } return [] } function O() { var t = document.scrollingElement; return t || document.documentElement } function k(t, e, n, o, i) { if (t.getBoundingClientRect || t === window) { var r, a, l, s, c, u, d = t !== window && t.parentNode && t !== O() ? (a = (r = t.getBoundingClientRect()).top, l = r.left, s = r.bottom, c = r.right, u = r.height, r.width) : (l = a = 0, s = window.innerHeight, c = window.innerWidth, u = window.innerHeight, window.innerWidth); if ((e || n) && t !== window && (i = i || t.parentNode, !y)) do { if (i && i.getBoundingClientRect && ("none" !== P(i, "transform") || n && "static" !== P(i, "position"))) { var h = i.getBoundingClientRect(); a -= h.top + parseInt(P(i, "border-top-width")), l -= h.left + parseInt(P(i, "border-left-width")), s = a + r.height, c = l + r.width; break } } while (i = i.parentNode); return o && t !== window && (o = (e = v(i || t)) && e.a, t = e && e.d, e && (s = (a /= t) + (u /= t), c = (l /= o) + (d /= o))), { top: a, left: l, bottom: s, right: c, width: d, height: u } } } function R(t, e, n) { for (var o = M(t, !0), i = k(t)[e]; o;) { var r = k(o)[n]; if (!("top" === n || "left" === n ? r <= i : i <= r)) return o; if (o === O()) break; o = M(o, !1) } return !1 } function X(t, e, n, o) { for (var i = 0, r = 0, a = t.children; r < a.length;) { if ("none" !== a[r].style.display && a[r] !== Bt.ghost && (o || a[r] !== Bt.dragged) && N(a[r], n.draggable, t, !1)) { if (i === e) return a[r]; i++ } r++ } return null } function Y(t, e) { for (var n = t.lastElementChild; n && (n === Bt.ghost || "none" === P(n, "display") || e && !p(n, e));)n = n.previousElementSibling; return n || null } function B(t, e) { var n = 0; if (!t || !t.parentNode) return -1; for (; t = t.previousElementSibling;)"TEMPLATE" === t.nodeName.toUpperCase() || t === Bt.clone || e && !p(t, e) || n++; return n } function E(t) { var e = 0, n = 0, o = O(); if (t) do { var i = v(t), r = i.a, i = i.d } while (e += t.scrollLeft * r, n += t.scrollTop * i, t !== o && (t = t.parentNode)); return [e, n] } function M(t, e) { if (!t || !t.getBoundingClientRect) return O(); var n = t, o = !1; do { if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) { var i = P(n); if (n.clientWidth < n.scrollWidth && ("auto" == i.overflowX || "scroll" == i.overflowX) || n.clientHeight < n.scrollHeight && ("auto" == i.overflowY || "scroll" == i.overflowY)) { if (!n.getBoundingClientRect || n === document.body) return O(); if (o || e) return n; o = !0 } } } while (n = n.parentNode); return O() } function D(t, e) { return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width) } function S(e, n) { return function () { var t; g || (1 === (t = arguments).length ? e.call(this, t[0]) : e.apply(this, t), g = setTimeout(function () { g = void 0 }, n)) } } function F(t, e, n) { t.scrollLeft += e, t.scrollTop += n } function _(t) { var e = window.Polymer, n = window.jQuery || window.Zepto; return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0) } function C(t, e) { P(t, "position", "absolute"), P(t, "top", e.top), P(t, "left", e.left), P(t, "width", e.width), P(t, "height", e.height) } function T(t) { P(t, "position", ""), P(t, "top", ""), P(t, "left", ""), P(t, "width", ""), P(t, "height", "") } var j = "Sortable" + (new Date).getTime(); function x() { var e, o = []; return { captureAnimationState: function () { o = [], this.options.animation && [].slice.call(this.el.children).forEach(function (t) { var e, n; "none" !== P(t, "display") && t !== Bt.ghost && (o.push({ target: t, rect: k(t) }), e = A({}, o[o.length - 1].rect), !t.thisAnimationDuration || (n = v(t, !0)) && (e.top -= n.f, e.left -= n.e), t.fromRect = e) }) }, addAnimationState: function (t) { o.push(t) }, removeAnimationState: function (t) { o.splice(function (t, e) { for (var n in t) if (t.hasOwnProperty(n)) for (var o in e) if (e.hasOwnProperty(o) && e[o] === t[n][o]) return Number(n); return -1 }(o, { target: t }), 1) }, animateAll: function (t) { var c = this; if (!this.options.animation) return clearTimeout(e), void ("function" == typeof t && t()); var u = !1, d = 0; o.forEach(function (t) { var e = 0, n = t.target, o = n.fromRect, i = k(n), r = n.prevFromRect, a = n.prevToRect, l = t.rect, s = v(n, !0); s && (i.top -= s.f, i.left -= s.e), n.toRect = i, n.thisAnimationDuration && D(r, i) && !D(o, i) && (l.top - i.top) / (l.left - i.left) == (o.top - i.top) / (o.left - i.left) && (t = l, s = r, r = a, a = c.options, e = Math.sqrt(Math.pow(s.top - t.top, 2) + Math.pow(s.left - t.left, 2)) / Math.sqrt(Math.pow(s.top - r.top, 2) + Math.pow(s.left - r.left, 2)) * a.animation), D(i, o) || (n.prevFromRect = o, n.prevToRect = i, e = e || c.options.animation, c.animate(n, l, i, e)), e && (u = !0, d = Math.max(d, e), clearTimeout(n.animationResetTimer), n.animationResetTimer = setTimeout(function () { n.animationTime = 0, n.prevFromRect = null, n.fromRect = null, n.prevToRect = null, n.thisAnimationDuration = null }, e), n.thisAnimationDuration = e) }), clearTimeout(e), u ? e = setTimeout(function () { "function" == typeof t && t() }, d) : "function" == typeof t && t(), o = [] }, animate: function (t, e, n, o) { var i, r; o && (P(t, "transition", ""), P(t, "transform", ""), i = (r = v(this.el)) && r.a, r = r && r.d, i = (e.left - n.left) / (i || 1), r = (e.top - n.top) / (r || 1), t.animatingX = !!i, t.animatingY = !!r, P(t, "transform", "translate3d(" + i + "px," + r + "px,0)"), this.forRepaintDummy = t.offsetWidth, P(t, "transition", "transform " + o + "ms" + (this.options.easing ? " " + this.options.easing : "")), P(t, "transform", "translate3d(0,0,0)"), "number" == typeof t.animated && clearTimeout(t.animated), t.animated = setTimeout(function () { P(t, "transition", ""), P(t, "transform", ""), t.animated = !1, t.animatingX = !1, t.animatingY = !1 }, o)) } } } var H = [], L = { initializeByDefault: !0 }, K = { mount: function (e) { for (var t in L) !L.hasOwnProperty(t) || t in e || (e[t] = L[t]); H.forEach(function (t) { if (t.pluginName === e.pluginName) throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once") }), H.push(e) }, pluginEvent: function (e, n, o) { var t = this; this.eventCanceled = !1, o.cancel = function () { t.eventCanceled = !0 }; var i = e + "Global"; H.forEach(function (t) { n[t.pluginName] && (n[t.pluginName][i] && n[t.pluginName][i](A({ sortable: n }, o)), n.options[t.pluginName] && n[t.pluginName][e] && n[t.pluginName][e](A({ sortable: n }, o))) }) }, initializePlugins: function (n, o, i, t) { for (var e in H.forEach(function (t) { var e = t.pluginName; (n.options[e] || t.initializeByDefault) && ((t = new t(n, o, n.options)).sortable = n, t.options = n.options, n[e] = t, a(i, t.defaults)) }), n.options) { var r; n.options.hasOwnProperty(e) && (void 0 !== (r = this.modifyOption(n, e, n.options[e])) && (n.options[e] = r)) } }, getEventProperties: function (e, n) { var o = {}; return H.forEach(function (t) { "function" == typeof t.eventProperties && a(o, t.eventProperties.call(n[t.pluginName], e)) }), o }, modifyOption: function (e, n, o) { var i; return H.forEach(function (t) { e[t.pluginName] && t.optionListeners && "function" == typeof t.optionListeners[n] && (i = t.optionListeners[n].call(e[t.pluginName], o)) }), i } }; function W(t) { var e = t.sortable, n = t.rootEl, o = t.name, i = t.targetEl, r = t.cloneEl, a = t.toEl, l = t.fromEl, s = t.oldIndex, c = t.newIndex, u = t.oldDraggableIndex, d = t.newDraggableIndex, h = t.originalEvent, f = t.putSortable, p = t.extraEventProperties; if (e = e || n && n[j]) { var g, m = e.options, t = "on" + o.charAt(0).toUpperCase() + o.substr(1); !window.CustomEvent || y || w ? (g = document.createEvent("Event")).initEvent(o, !0, !0) : g = new CustomEvent(o, { bubbles: !0, cancelable: !0 }), g.to = a || n, g.from = l || n, g.item = i || n, g.clone = r, g.oldIndex = s, g.newIndex = c, g.oldDraggableIndex = u, g.newDraggableIndex = d, g.originalEvent = h, g.pullMode = f ? f.lastPutMode : void 0; var v, b = A(A({}, p), K.getEventProperties(o, e)); for (v in b) g[v] = b[v]; n && n.dispatchEvent(g), m[t] && m[t].call(e, g) } } function z(t, e) { var n = (o = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}).evt, o = i(o, G); K.pluginEvent.bind(Bt)(t, e, A({ dragEl: q, parentEl: V, ghostEl: Z, rootEl: $, nextEl: Q, lastDownEl: J, cloneEl: tt, cloneHidden: et, dragStarted: pt, putSortable: lt, activeSortable: Bt.active, originalEvent: n, oldIndex: nt, oldDraggableIndex: it, newIndex: ot, newDraggableIndex: rt, hideGhostForTarget: kt, unhideGhostForTarget: Rt, cloneNowHidden: function () { et = !0 }, cloneNowShown: function () { et = !1 }, dispatchSortableEvent: function (t) { U({ sortable: e, name: t, originalEvent: n }) } }, o)) } var G = ["evt"]; function U(t) { W(A({ putSortable: lt, cloneEl: tt, targetEl: q, rootEl: $, oldIndex: nt, oldDraggableIndex: it, newIndex: ot, newDraggableIndex: rt }, t)) } var q, V, Z, $, Q, J, tt, et, nt, ot, it, rt, at, lt, st, ct, ut, dt, ht, ft, pt, gt, mt, vt, bt, yt = !1, wt = !1, Et = [], Dt = !1, St = !1, _t = [], Ct = !1, Tt = [], xt = "undefined" != typeof document, Ot = n, Mt = w || y ? "cssFloat" : "float", At = xt && !c && !n && "draggable" in document.createElement("div"), Nt = function () { if (xt) { if (y) return !1; var t = document.createElement("x"); return t.style.cssText = "pointer-events:auto", "auto" === t.style.pointerEvents } }(), It = function (t, e) { var n = P(t), o = parseInt(n.width) - parseInt(n.paddingLeft) - parseInt(n.paddingRight) - parseInt(n.borderLeftWidth) - parseInt(n.borderRightWidth), i = X(t, 0, e), r = X(t, 1, e), a = i && P(i), l = r && P(r), s = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + k(i).width, t = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + k(r).width; if ("flex" === n.display) return "column" === n.flexDirection || "column-reverse" === n.flexDirection ? "vertical" : "horizontal"; if ("grid" === n.display) return n.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal"; if (i && a.float && "none" !== a.float) { e = "left" === a.float ? "left" : "right"; return !r || "both" !== l.clear && l.clear !== e ? "horizontal" : "vertical" } return i && ("block" === a.display || "flex" === a.display || "table" === a.display || "grid" === a.display || o <= s && "none" === n[Mt] || r && "none" === n[Mt] && o < s + t) ? "vertical" : "horizontal" }, Pt = function (t) { function l(r, a) { return function (t, e, n, o) { var i = t.options.group.name && e.options.group.name && t.options.group.name === e.options.group.name; if (null == r && (a || i)) return !0; if (null == r || !1 === r) return !1; if (a && "clone" === r) return r; if ("function" == typeof r) return l(r(t, e, n, o), a)(t, e, n, o); e = (a ? t : e).options.group.name; return !0 === r || "string" == typeof r && r === e || r.join && -1 < r.indexOf(e) } } var e = {}, n = t.group; n && "object" == o(n) || (n = { name: n }), e.name = n.name, e.checkPull = l(n.pull, !0), e.checkPut = l(n.put), e.revertClone = n.revertClone, t.group = e }, kt = function () { !Nt && Z && P(Z, "display", "none") }, Rt = function () { !Nt && Z && P(Z, "display", "") }; xt && document.addEventListener("click", function (t) { if (wt) return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), wt = !1 }, !0); function Xt(t) { if (q) { t = t.touches ? t.touches[0] : t; var e = (i = t.clientX, r = t.clientY, Et.some(function (t) { var e = t[j].options.emptyInsertThreshold; if (e && !Y(t)) { var n = k(t), o = i >= n.left - e && i <= n.right + e, e = r >= n.top - e && r <= n.bottom + e; return o && e ? a = t : void 0 } }), a); if (e) { var n, o = {}; for (n in t) t.hasOwnProperty(n) && (o[n] = t[n]); o.target = o.rootEl = e, o.preventDefault = void 0, o.stopPropagation = void 0, e[j]._onDragOver(o) } } var i, r, a } function Yt(t) { q && q.parentNode[j]._isOutsideThisEl(t.target) } function Bt(t, e) { if (!t || !t.nodeType || 1 !== t.nodeType) throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t)); this.el = t, this.options = e = a({}, e), t[j] = this; var n, o, i = { group: null, sort: !0, disabled: !1, store: null, handle: null, draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*", swapThreshold: 1, invertSwap: !1, invertedSwapThreshold: null, removeCloneOnHide: !0, direction: function () { return It(t, this.options) }, ghostClass: "sortable-ghost", chosenClass: "sortable-chosen", dragClass: "sortable-drag", ignore: "a, img", filter: null, preventOnFilter: !0, animation: 0, easing: null, setData: function (t, e) { t.setData("Text", e.textContent) }, dropBubble: !1, dragoverBubble: !1, dataIdAttr: "data-id", delay: 0, delayOnTouchOnly: !1, touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1, forceFallback: !1, fallbackClass: "sortable-fallback", fallbackOnBody: !1, fallbackTolerance: 0, fallbackOffset: { x: 0, y: 0 }, supportPointer: !1 !== Bt.supportPointer && "PointerEvent" in window && !u, emptyInsertThreshold: 5 }; for (n in K.initializePlugins(this, t, i), i) n in e || (e[n] = i[n]); for (o in Pt(e), this) "_" === o.charAt(0) && "function" == typeof this[o] && (this[o] = this[o].bind(this)); this.nativeDraggable = !e.forceFallback && At, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? h(t, "pointerdown", this._onTapStart) : (h(t, "mousedown", this._onTapStart), h(t, "touchstart", this._onTapStart)), this.nativeDraggable && (h(t, "dragover", this), h(t, "dragenter", this)), Et.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), a(this, x()) } function Ft(t, e, n, o, i, r, a, l) { var s, c, u = t[j], d = u.options.onMove; return !window.CustomEvent || y || w ? (s = document.createEvent("Event")).initEvent("move", !0, !0) : s = new CustomEvent("move", { bubbles: !0, cancelable: !0 }), s.to = e, s.from = t, s.dragged = n, s.draggedRect = o, s.related = i || e, s.relatedRect = r || k(e), s.willInsertAfter = l, s.originalEvent = a, t.dispatchEvent(s), c = d ? d.call(u, s, a) : c } function jt(t) { t.draggable = !1 } function Ht() { Ct = !1 } function Lt(t) { return setTimeout(t, 0) } function Kt(t) { return clearTimeout(t) } Bt.prototype = { constructor: Bt, _isOutsideThisEl: function (t) { this.el.contains(t) || t === this.el || (gt = null) }, _getDirection: function (t, e) { return "function" == typeof this.options.direction ? this.options.direction.call(this, t, e, q) : this.options.direction }, _onTapStart: function (e) { if (e.cancelable) { var n = this, o = this.el, t = this.options, i = t.preventOnFilter, r = e.type, a = e.touches && e.touches[0] || e.pointerType && "touch" === e.pointerType && e, l = (a || e).target, s = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || l, c = t.filter; if (!function (t) { Tt.length = 0; var e = t.getElementsByTagName("input"), n = e.length; for (; n--;) { var o = e[n]; o.checked && Tt.push(o) } }(o), !q && !(/mousedown|pointerdown/.test(r) && 0 !== e.button || t.disabled) && !s.isContentEditable && (this.nativeDraggable || !u || !l || "SELECT" !== l.tagName.toUpperCase()) && !((l = N(l, t.draggable, o, !1)) && l.animated || J === l)) { if (nt = B(l), it = B(l, t.draggable), "function" == typeof c) { if (c.call(this, e, l, this)) return U({ sortable: n, rootEl: s, name: "filter", targetEl: l, toEl: o, fromEl: o }), z("filter", n, { evt: e }), void (i && e.cancelable && e.preventDefault()) } else if (c = c && c.split(",").some(function (t) { if (t = N(s, t.trim(), o, !1)) return U({ sortable: n, rootEl: t, name: "filter", targetEl: l, fromEl: o, toEl: o }), z("filter", n, { evt: e }), !0 })) return void (i && e.cancelable && e.preventDefault()); t.handle && !N(s, t.handle, o, !1) || this._prepareDragStart(e, a, l) } } }, _prepareDragStart: function (t, e, n) { var o, i = this, r = i.el, a = i.options, l = r.ownerDocument; n && !q && n.parentNode === r && (o = k(n), $ = r, V = (q = n).parentNode, Q = q.nextSibling, J = n, at = a.group, st = { target: Bt.dragged = q, clientX: (e || t).clientX, clientY: (e || t).clientY }, ht = st.clientX - o.left, ft = st.clientY - o.top, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, q.style["will-change"] = "all", o = function () { z("delayEnded", i, { evt: t }), Bt.eventCanceled ? i._onDrop() : (i._disableDelayedDragEvents(), !s && i.nativeDraggable && (q.draggable = !0), i._triggerDragStart(t, e), U({ sortable: i, name: "choose", originalEvent: t }), I(q, a.chosenClass, !0)) }, a.ignore.split(",").forEach(function (t) { b(q, t.trim(), jt) }), h(l, "dragover", Xt), h(l, "mousemove", Xt), h(l, "touchmove", Xt), h(l, "mouseup", i._onDrop), h(l, "touchend", i._onDrop), h(l, "touchcancel", i._onDrop), s && this.nativeDraggable && (this.options.touchStartThreshold = 4, q.draggable = !0), z("delayStart", this, { evt: t }), !a.delay || a.delayOnTouchOnly && !e || this.nativeDraggable && (w || y) ? o() : Bt.eventCanceled ? this._onDrop() : (h(l, "mouseup", i._disableDelayedDrag), h(l, "touchend", i._disableDelayedDrag), h(l, "touchcancel", i._disableDelayedDrag), h(l, "mousemove", i._delayedDragTouchMoveHandler), h(l, "touchmove", i._delayedDragTouchMoveHandler), a.supportPointer && h(l, "pointermove", i._delayedDragTouchMoveHandler), i._dragStartTimer = setTimeout(o, a.delay))) }, _delayedDragTouchMoveHandler: function (t) { t = t.touches ? t.touches[0] : t; Math.max(Math.abs(t.clientX - this._lastX), Math.abs(t.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag() }, _disableDelayedDrag: function () { q && jt(q), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents() }, _disableDelayedDragEvents: function () { var t = this.el.ownerDocument; f(t, "mouseup", this._disableDelayedDrag), f(t, "touchend", this._disableDelayedDrag), f(t, "touchcancel", this._disableDelayedDrag), f(t, "mousemove", this._delayedDragTouchMoveHandler), f(t, "touchmove", this._delayedDragTouchMoveHandler), f(t, "pointermove", this._delayedDragTouchMoveHandler) }, _triggerDragStart: function (t, e) { e = e || "touch" == t.pointerType && t, !this.nativeDraggable || e ? this.options.supportPointer ? h(document, "pointermove", this._onTouchMove) : h(document, e ? "touchmove" : "mousemove", this._onTouchMove) : (h(q, "dragend", this), h($, "dragstart", this._onDragStart)); try { document.selection ? Lt(function () { document.selection.empty() }) : window.getSelection().removeAllRanges() } catch (t) { } }, _dragStarted: function (t, e) { var n; yt = !1, $ && q ? (z("dragStarted", this, { evt: e }), this.nativeDraggable && h(document, "dragover", Yt), n = this.options, t || I(q, n.dragClass, !1), I(q, n.ghostClass, !0), Bt.active = this, t && this._appendGhost(), U({ sortable: this, name: "start", originalEvent: e })) : this._nulling() }, _emulateDragOver: function () { if (ct) { this._lastX = ct.clientX, this._lastY = ct.clientY, kt(); for (var t = document.elementFromPoint(ct.clientX, ct.clientY), e = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(ct.clientX, ct.clientY)) !== e;)e = t; if (q.parentNode[j]._isOutsideThisEl(t), e) do { if (e[j]) if (e[j]._onDragOver({ clientX: ct.clientX, clientY: ct.clientY, target: t, rootEl: e }) && !this.options.dragoverBubble) break } while (e = (t = e).parentNode); Rt() } }, _onTouchMove: function (t) { if (st) { var e = this.options, n = e.fallbackTolerance, o = e.fallbackOffset, i = t.touches ? t.touches[0] : t, r = Z && v(Z, !0), a = Z && r && r.a, l = Z && r && r.d, e = Ot && bt && E(bt), a = (i.clientX - st.clientX + o.x) / (a || 1) + (e ? e[0] - _t[0] : 0) / (a || 1), l = (i.clientY - st.clientY + o.y) / (l || 1) + (e ? e[1] - _t[1] : 0) / (l || 1); if (!Bt.active && !yt) { if (n && Math.max(Math.abs(i.clientX - this._lastX), Math.abs(i.clientY - this._lastY)) < n) return; this._onDragStart(t, !0) } Z && (r ? (r.e += a - (ut || 0), r.f += l - (dt || 0)) : r = { a: 1, b: 0, c: 0, d: 1, e: a, f: l }, r = "matrix(".concat(r.a, ",").concat(r.b, ",").concat(r.c, ",").concat(r.d, ",").concat(r.e, ",").concat(r.f, ")"), P(Z, "webkitTransform", r), P(Z, "mozTransform", r), P(Z, "msTransform", r), P(Z, "transform", r), ut = a, dt = l, ct = i), t.cancelable && t.preventDefault() } }, _appendGhost: function () { if (!Z) { var t = this.options.fallbackOnBody ? document.body : $, e = k(q, !0, Ot, !0, t), n = this.options; if (Ot) { for (bt = t; "static" === P(bt, "position") && "none" === P(bt, "transform") && bt !== document;)bt = bt.parentNode; bt !== document.body && bt !== document.documentElement ? (bt === document && (bt = O()), e.top += bt.scrollTop, e.left += bt.scrollLeft) : bt = O(), _t = E(bt) } I(Z = q.cloneNode(!0), n.ghostClass, !1), I(Z, n.fallbackClass, !0), I(Z, n.dragClass, !0), P(Z, "transition", ""), P(Z, "transform", ""), P(Z, "box-sizing", "border-box"), P(Z, "margin", 0), P(Z, "top", e.top), P(Z, "left", e.left), P(Z, "width", e.width), P(Z, "height", e.height), P(Z, "opacity", "0.8"), P(Z, "position", Ot ? "absolute" : "fixed"), P(Z, "zIndex", "100000"), P(Z, "pointerEvents", "none"), Bt.ghost = Z, t.appendChild(Z), P(Z, "transform-origin", ht / parseInt(Z.style.width) * 100 + "% " + ft / parseInt(Z.style.height) * 100 + "%") } }, _onDragStart: function (t, e) { var n = this, o = t.dataTransfer, i = n.options; z("dragStart", this, { evt: t }), Bt.eventCanceled ? this._onDrop() : (z("setupClone", this), Bt.eventCanceled || ((tt = _(q)).draggable = !1, tt.style["will-change"] = "", this._hideClone(), I(tt, this.options.chosenClass, !1), Bt.clone = tt), n.cloneId = Lt(function () { z("clone", n), Bt.eventCanceled || (n.options.removeCloneOnHide || $.insertBefore(tt, q), n._hideClone(), U({ sortable: n, name: "clone" })) }), e || I(q, i.dragClass, !0), e ? (wt = !0, n._loopId = setInterval(n._emulateDragOver, 50)) : (f(document, "mouseup", n._onDrop), f(document, "touchend", n._onDrop), f(document, "touchcancel", n._onDrop), o && (o.effectAllowed = "move", i.setData && i.setData.call(n, o, q)), h(document, "drop", n), P(q, "transform", "translateZ(0)")), yt = !0, n._dragStartId = Lt(n._dragStarted.bind(n, e, t)), h(document, "selectstart", n), pt = !0, u && P(document.body, "user-select", "none")) }, _onDragOver: function (n) { var o, i, r, t, a = this.el, l = n.target, e = this.options, s = e.group, c = Bt.active, u = at === s, d = e.sort, h = lt || c, f = this, p = !1; if (!Ct) { if (void 0 !== n.preventDefault && n.cancelable && n.preventDefault(), l = N(l, e.draggable, a, !0), T("dragOver"), Bt.eventCanceled) return p; if (q.contains(n.target) || l.animated && l.animatingX && l.animatingY || f._ignoreWhileAnimating === l) return O(!1); if (wt = !1, c && !e.disabled && (u ? d || (i = V !== $) : lt === this || (this.lastPutMode = at.checkPull(this, c, q, n)) && s.checkPut(this, c, q, n))) { if (r = "vertical" === this._getDirection(n, l), o = k(q), T("dragOverValid"), Bt.eventCanceled) return p; if (i) return V = $, x(), this._hideClone(), T("revert"), Bt.eventCanceled || (Q ? $.insertBefore(q, Q) : $.appendChild(q)), O(!0); var g = Y(a, e.draggable); if (!g || function (t, e, n) { n = k(Y(n.el, n.options.draggable)); return e ? t.clientX > n.right + 10 || t.clientX <= n.right && t.clientY > n.bottom && t.clientX >= n.left : t.clientX > n.right && t.clientY > n.top || t.clientX <= n.right && t.clientY > n.bottom + 10 }(n, r, this) && !g.animated) { if (g === q) return O(!1); if ((l = g && a === n.target ? g : l) && (w = k(l)), !1 !== Ft($, a, q, o, l, w, n, !!l)) return x(), a.appendChild(q), V = a, M(), O(!0) } else if (g && function (t, e, n) { n = k(X(n.el, 0, n.options, !0)); return e ? t.clientX < n.left - 10 || t.clientY < n.top && t.clientX < n.right : t.clientY < n.top - 10 || t.clientY < n.bottom && t.clientX < n.left }(n, r, this)) { var m = X(a, 0, e, !0); if (m === q) return O(!1); if (w = k(l = m), !1 !== Ft($, a, q, o, l, w, n, !1)) return x(), a.insertBefore(q, m), V = a, M(), O(!0) } else if (l.parentNode === a) { var v, b, y, w = k(l), E = q.parentNode !== a, D = (D = q.animated && q.toRect || o, C = l.animated && l.toRect || w, S = (t = r) ? D.left : D.top, s = t ? D.right : D.bottom, g = t ? D.width : D.height, m = t ? C.left : C.top, D = t ? C.right : C.bottom, C = t ? C.width : C.height, !(S === m || s === D || S + g / 2 === m + C / 2)), S = r ? "top" : "left", g = R(l, "top", "top") || R(q, "top", "top"), m = g ? g.scrollTop : void 0; if (gt !== l && (b = w[S], Dt = !1, St = !D && e.invertSwap || E), 0 !== (v = function (t, e, n, o, i, r, a, l) { var s = o ? t.clientY : t.clientX, c = o ? n.height : n.width, t = o ? n.top : n.left, o = o ? n.bottom : n.right, n = !1; if (!a) if (l && vt < c * i) { if (Dt = !Dt && (1 === mt ? t + c * r / 2 < s : s < o - c * r / 2) ? !0 : Dt) n = !0; else if (1 === mt ? s < t + vt : o - vt < s) return -mt } else if (t + c * (1 - i) / 2 < s && s < o - c * (1 - i) / 2) return function (t) { return B(q) < B(t) ? 1 : -1 }(e); if ((n = n || a) && (s < t + c * r / 2 || o - c * r / 2 < s)) return t + c / 2 < s ? 1 : -1; return 0 }(n, l, w, r, D ? 1 : e.swapThreshold, null == e.invertedSwapThreshold ? e.swapThreshold : e.invertedSwapThreshold, St, gt === l))) for (var _ = B(q); (y = V.children[_ -= v]) && ("none" === P(y, "display") || y === Z);); if (0 === v || y === l) return O(!1); mt = v; var C = (gt = l).nextElementSibling, E = !1, D = Ft($, a, q, o, l, w, n, E = 1 === v); if (!1 !== D) return 1 !== D && -1 !== D || (E = 1 === D), Ct = !0, setTimeout(Ht, 30), x(), E && !C ? a.appendChild(q) : l.parentNode.insertBefore(q, E ? C : l), g && F(g, 0, m - g.scrollTop), V = q.parentNode, void 0 === b || St || (vt = Math.abs(b - k(l)[S])), M(), O(!0) } if (a.contains(q)) return O(!1) } return !1 } function T(t, e) { z(t, f, A({ evt: n, isOwner: u, axis: r ? "vertical" : "horizontal", revert: i, dragRect: o, targetRect: w, canSort: d, fromSortable: h, target: l, completed: O, onMove: function (t, e) { return Ft($, a, q, o, t, k(t), n, e) }, changed: M }, e)) } function x() { T("dragOverAnimationCapture"), f.captureAnimationState(), f !== h && h.captureAnimationState() } function O(t) { return T("dragOverCompleted", { insertion: t }), t && (u ? c._hideClone() : c._showClone(f), f !== h && (I(q, (lt || c).options.ghostClass, !1), I(q, e.ghostClass, !0)), lt !== f && f !== Bt.active ? lt = f : f === Bt.active && lt && (lt = null), h === f && (f._ignoreWhileAnimating = l), f.animateAll(function () { T("dragOverAnimationComplete"), f._ignoreWhileAnimating = null }), f !== h && (h.animateAll(), h._ignoreWhileAnimating = null)), (l === q && !q.animated || l === a && !l.animated) && (gt = null), e.dragoverBubble || n.rootEl || l === document || (q.parentNode[j]._isOutsideThisEl(n.target), t || Xt(n)), !e.dragoverBubble && n.stopPropagation && n.stopPropagation(), p = !0 } function M() { ot = B(q), rt = B(q, e.draggable), U({ sortable: f, name: "change", toEl: a, newIndex: ot, newDraggableIndex: rt, originalEvent: n }) } }, _ignoreWhileAnimating: null, _offMoveEvents: function () { f(document, "mousemove", this._onTouchMove), f(document, "touchmove", this._onTouchMove), f(document, "pointermove", this._onTouchMove), f(document, "dragover", Xt), f(document, "mousemove", Xt), f(document, "touchmove", Xt) }, _offUpEvents: function () { var t = this.el.ownerDocument; f(t, "mouseup", this._onDrop), f(t, "touchend", this._onDrop), f(t, "pointerup", this._onDrop), f(t, "touchcancel", this._onDrop), f(document, "selectstart", this) }, _onDrop: function (t) { var e = this.el, n = this.options; ot = B(q), rt = B(q, n.draggable), z("drop", this, { evt: t }), V = q && q.parentNode, ot = B(q), rt = B(q, n.draggable), Bt.eventCanceled || (Dt = St = yt = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), Kt(this.cloneId), Kt(this._dragStartId), this.nativeDraggable && (f(document, "drop", this), f(e, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), u && P(document.body, "user-select", ""), P(q, "transform", ""), t && (pt && (t.cancelable && t.preventDefault(), n.dropBubble || t.stopPropagation()), Z && Z.parentNode && Z.parentNode.removeChild(Z), ($ === V || lt && "clone" !== lt.lastPutMode) && tt && tt.parentNode && tt.parentNode.removeChild(tt), q && (this.nativeDraggable && f(q, "dragend", this), jt(q), q.style["will-change"] = "", pt && !yt && I(q, (lt || this).options.ghostClass, !1), I(q, this.options.chosenClass, !1), U({ sortable: this, name: "unchoose", toEl: V, newIndex: null, newDraggableIndex: null, originalEvent: t }), $ !== V ? (0 <= ot && (U({ rootEl: V, name: "add", toEl: V, fromEl: $, originalEvent: t }), U({ sortable: this, name: "remove", toEl: V, originalEvent: t }), U({ rootEl: V, name: "sort", toEl: V, fromEl: $, originalEvent: t }), U({ sortable: this, name: "sort", toEl: V, originalEvent: t })), lt && lt.save()) : ot !== nt && 0 <= ot && (U({ sortable: this, name: "update", toEl: V, originalEvent: t }), U({ sortable: this, name: "sort", toEl: V, originalEvent: t })), Bt.active && (null != ot && -1 !== ot || (ot = nt, rt = it), U({ sortable: this, name: "end", toEl: V, originalEvent: t }), this.save())))), this._nulling() }, _nulling: function () { z("nulling", this), $ = q = V = Z = Q = tt = J = et = st = ct = pt = ot = rt = nt = it = gt = mt = lt = at = Bt.dragged = Bt.ghost = Bt.clone = Bt.active = null, Tt.forEach(function (t) { t.checked = !0 }), Tt.length = ut = dt = 0 }, handleEvent: function (t) { switch (t.type) { case "drop": case "dragend": this._onDrop(t); break; case "dragenter": case "dragover": q && (this._onDragOver(t), function (t) { t.dataTransfer && (t.dataTransfer.dropEffect = "move"); t.cancelable && t.preventDefault() }(t)); break; case "selectstart": t.preventDefault() } }, toArray: function () { for (var t, e = [], n = this.el.children, o = 0, i = n.length, r = this.options; o < i; o++)N(t = n[o], r.draggable, this.el, !1) && e.push(t.getAttribute(r.dataIdAttr) || function (t) { var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; for (; n--;)o += e.charCodeAt(n); return o.toString(36) }(t)); return e }, sort: function (t, e) { var n = {}, o = this.el; this.toArray().forEach(function (t, e) { e = o.children[e]; N(e, this.options.draggable, o, !1) && (n[t] = e) }, this), e && this.captureAnimationState(), t.forEach(function (t) { n[t] && (o.removeChild(n[t]), o.appendChild(n[t])) }), e && this.animateAll() }, save: function () { var t = this.options.store; t && t.set && t.set(this) }, closest: function (t, e) { return N(t, e || this.options.draggable, this.el, !1) }, option: function (t, e) { var n = this.options; if (void 0 === e) return n[t]; var o = K.modifyOption(this, t, e); n[t] = void 0 !== o ? o : e, "group" === t && Pt(n) }, destroy: function () { z("destroy", this); var t = this.el; t[j] = null, f(t, "mousedown", this._onTapStart), f(t, "touchstart", this._onTapStart), f(t, "pointerdown", this._onTapStart), this.nativeDraggable && (f(t, "dragover", this), f(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function (t) { t.removeAttribute("draggable") }), this._onDrop(), this._disableDelayedDragEvents(), Et.splice(Et.indexOf(this.el), 1), this.el = t = null }, _hideClone: function () { et || (z("hideClone", this), Bt.eventCanceled || (P(tt, "display", "none"), this.options.removeCloneOnHide && tt.parentNode && tt.parentNode.removeChild(tt), et = !0)) }, _showClone: function (t) { "clone" === t.lastPutMode ? et && (z("showClone", this), Bt.eventCanceled || (q.parentNode != $ || this.options.group.revertClone ? Q ? $.insertBefore(tt, Q) : $.appendChild(tt) : $.insertBefore(tt, q), this.options.group.revertClone && this.animate(q, tt), P(tt, "display", ""), et = !1)) : this._hideClone() } }, xt && h(document, "touchmove", function (t) { (Bt.active || yt) && t.cancelable && t.preventDefault() }), Bt.utils = { on: h, off: f, css: P, find: b, is: function (t, e) { return !!N(t, e, t, !1) }, extend: function (t, e) { if (t && e) for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t }, throttle: S, closest: N, toggleClass: I, clone: _, index: B, nextTick: Lt, cancelNextTick: Kt, detectDirection: It, getChild: X }, Bt.get = function (t) { return t[j] }, Bt.mount = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; (e = e[0].constructor === Array ? e[0] : e).forEach(function (t) { if (!t.prototype || !t.prototype.constructor) throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(t)); t.utils && (Bt.utils = A(A({}, Bt.utils), t.utils)), K.mount(t) }) }, Bt.create = function (t, e) { return new Bt(t, e) }; var Wt, zt, Gt, Ut, qt, Vt, Zt = [], $t = !(Bt.version = "1.14.0"); function Qt() { Zt.forEach(function (t) { clearInterval(t.pid) }), Zt = [] } function Jt() { clearInterval(Vt) } var te, ee = S(function (n, t, e, o) { if (t.scroll) { var i, r = (n.touches ? n.touches[0] : n).clientX, a = (n.touches ? n.touches[0] : n).clientY, l = t.scrollSensitivity, s = t.scrollSpeed, c = O(), u = !1; zt !== e && (zt = e, Qt(), Wt = t.scroll, i = t.scrollFn, !0 === Wt && (Wt = M(e, !0))); var d = 0, h = Wt; do { var f = h, p = k(f), g = p.top, m = p.bottom, v = p.left, b = p.right, y = p.width, w = p.height, E = void 0, D = void 0, S = f.scrollWidth, _ = f.scrollHeight, C = P(f), T = f.scrollLeft, p = f.scrollTop, D = f === c ? (E = y < S && ("auto" === C.overflowX || "scroll" === C.overflowX || "visible" === C.overflowX), w < _ && ("auto" === C.overflowY || "scroll" === C.overflowY || "visible" === C.overflowY)) : (E = y < S && ("auto" === C.overflowX || "scroll" === C.overflowX), w < _ && ("auto" === C.overflowY || "scroll" === C.overflowY)), T = E && (Math.abs(b - r) <= l && T + y < S) - (Math.abs(v - r) <= l && !!T), p = D && (Math.abs(m - a) <= l && p + w < _) - (Math.abs(g - a) <= l && !!p); if (!Zt[d]) for (var x = 0; x <= d; x++)Zt[x] || (Zt[x] = {}); Zt[d].vx == T && Zt[d].vy == p && Zt[d].el === f || (Zt[d].el = f, Zt[d].vx = T, Zt[d].vy = p, clearInterval(Zt[d].pid), 0 == T && 0 == p || (u = !0, Zt[d].pid = setInterval(function () { o && 0 === this.layer && Bt.active._onTouchMove(qt); var t = Zt[this.layer].vy ? Zt[this.layer].vy * s : 0, e = Zt[this.layer].vx ? Zt[this.layer].vx * s : 0; "function" == typeof i && "continue" !== i.call(Bt.dragged.parentNode[j], e, t, n, qt, Zt[this.layer].el) || F(Zt[this.layer].el, e, t) }.bind({ layer: d }), 24))), d++ } while (t.bubbleScroll && h !== c && (h = M(h, !1))); $t = u } }, 30), n = function (t) { var e = t.originalEvent, n = t.putSortable, o = t.dragEl, i = t.activeSortable, r = t.dispatchSortableEvent, a = t.hideGhostForTarget, t = t.unhideGhostForTarget; e && (i = n || i, a(), e = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e, e = document.elementFromPoint(e.clientX, e.clientY), t(), i && !i.el.contains(e) && (r("spill"), this.onSpill({ dragEl: o, putSortable: n }))) }; function ne() { } function oe() { } ne.prototype = { startIndex: null, dragStart: function (t) { t = t.oldDraggableIndex; this.startIndex = t }, onSpill: function (t) { var e = t.dragEl, n = t.putSortable; this.sortable.captureAnimationState(), n && n.captureAnimationState(); t = X(this.sortable.el, this.startIndex, this.options); t ? this.sortable.el.insertBefore(e, t) : this.sortable.el.appendChild(e), this.sortable.animateAll(), n && n.animateAll() }, drop: n }, a(ne, { pluginName: "revertOnSpill" }), oe.prototype = { onSpill: function (t) { var e = t.dragEl, t = t.putSortable || this.sortable; t.captureAnimationState(), e.parentNode && e.parentNode.removeChild(e), t.animateAll() }, drop: n }, a(oe, { pluginName: "removeOnSpill" }); var ie, re, ae, le, se, ce = [], ue = [], de = !1, he = !1, fe = !1; function pe(n, o) { ue.forEach(function (t, e) { e = o.children[t.sortableIndex + (n ? Number(e) : 0)]; e ? o.insertBefore(t, e) : o.appendChild(t) }) } function ge() { ce.forEach(function (t) { t !== ae && t.parentNode && t.parentNode.removeChild(t) }) } return Bt.mount(new function () { function t() { for (var t in this.defaults = { scroll: !0, forceAutoScrollFallback: !1, scrollSensitivity: 30, scrollSpeed: 10, bubbleScroll: !0 }, this) "_" === t.charAt(0) && "function" == typeof this[t] && (this[t] = this[t].bind(this)) } return t.prototype = { dragStarted: function (t) { t = t.originalEvent; this.sortable.nativeDraggable ? h(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? h(document, "pointermove", this._handleFallbackAutoScroll) : t.touches ? h(document, "touchmove", this._handleFallbackAutoScroll) : h(document, "mousemove", this._handleFallbackAutoScroll) }, dragOverCompleted: function (t) { t = t.originalEvent; this.options.dragOverBubble || t.rootEl || this._handleAutoScroll(t) }, drop: function () { this.sortable.nativeDraggable ? f(document, "dragover", this._handleAutoScroll) : (f(document, "pointermove", this._handleFallbackAutoScroll), f(document, "touchmove", this._handleFallbackAutoScroll), f(document, "mousemove", this._handleFallbackAutoScroll)), Jt(), Qt(), clearTimeout(g), g = void 0 }, nulling: function () { qt = zt = Wt = $t = Vt = Gt = Ut = null, Zt.length = 0 }, _handleFallbackAutoScroll: function (t) { this._handleAutoScroll(t, !0) }, _handleAutoScroll: function (e, n) { var o, i = this, r = (e.touches ? e.touches[0] : e).clientX, a = (e.touches ? e.touches[0] : e).clientY, t = document.elementFromPoint(r, a); qt = e, n || this.options.forceAutoScrollFallback || w || y || u ? (ee(e, this.options, t, n), o = M(t, !0), !$t || Vt && r === Gt && a === Ut || (Vt && Jt(), Vt = setInterval(function () { var t = M(document.elementFromPoint(r, a), !0); t !== o && (o = t, Qt()), ee(e, i.options, t, n) }, 10), Gt = r, Ut = a)) : this.options.bubbleScroll && M(t, !0) !== O() ? ee(e, this.options, M(t, !1), !1) : Qt() } }, a(t, { pluginName: "scroll", initializeByDefault: !0 }) }), Bt.mount(oe, ne), Bt.mount(new function () { function t() { this.defaults = { swapClass: "sortable-swap-highlight" } } return t.prototype = { dragStart: function (t) { t = t.dragEl; te = t }, dragOverValid: function (t) { var e = t.completed, n = t.target, o = t.onMove, i = t.activeSortable, r = t.changed, a = t.cancel; i.options.swap && (t = this.sortable.el, i = this.options, n && n !== t && (t = te, te = !1 !== o(n) ? (I(n, i.swapClass, !0), n) : null, t && t !== te && I(t, i.swapClass, !1)), r(), e(!0), a()) }, drop: function (t) { var e, n, o = t.activeSortable, i = t.putSortable, r = t.dragEl, a = i || this.sortable, l = this.options; te && I(te, l.swapClass, !1), te && (l.swap || i && i.options.swap) && r !== te && (a.captureAnimationState(), a !== o && o.captureAnimationState(), n = te, t = (e = r).parentNode, l = n.parentNode, t && l && !t.isEqualNode(n) && !l.isEqualNode(e) && (i = B(e), r = B(n), t.isEqualNode(l) && i < r && r++, t.insertBefore(n, t.children[i]), l.insertBefore(e, l.children[r])), a.animateAll(), a !== o && o.animateAll()) }, nulling: function () { te = null } }, a(t, { pluginName: "swap", eventProperties: function () { return { swapItem: te } } }) }), Bt.mount(new function () { function t(o) { for (var t in this) "_" === t.charAt(0) && "function" == typeof this[t] && (this[t] = this[t].bind(this)); o.options.supportPointer ? h(document, "pointerup", this._deselectMultiDrag) : (h(document, "mouseup", this._deselectMultiDrag), h(document, "touchend", this._deselectMultiDrag)), h(document, "keydown", this._checkKeyDown), h(document, "keyup", this._checkKeyUp), this.defaults = { selectedClass: "sortable-selected", multiDragKey: null, setData: function (t, e) { var n = ""; ce.length && re === o ? ce.forEach(function (t, e) { n += (e ? ", " : "") + t.textContent }) : n = e.textContent, t.setData("Text", n) } } } return t.prototype = { multiDragKeyDown: !1, isMultiDrag: !1, delayStartGlobal: function (t) { t = t.dragEl; ae = t }, delayEnded: function () { this.isMultiDrag = ~ce.indexOf(ae) }, setupClone: function (t) { var e = t.sortable, t = t.cancel; if (this.isMultiDrag) { for (var n = 0; n < ce.length; n++)ue.push(_(ce[n])), ue[n].sortableIndex = ce[n].sortableIndex, ue[n].draggable = !1, ue[n].style["will-change"] = "", I(ue[n], this.options.selectedClass, !1), ce[n] === ae && I(ue[n], this.options.chosenClass, !1); e._hideClone(), t() } }, clone: function (t) { var e = t.sortable, n = t.rootEl, o = t.dispatchSortableEvent, t = t.cancel; this.isMultiDrag && (this.options.removeCloneOnHide || ce.length && re === e && (pe(!0, n), o("clone"), t())) }, showClone: function (t) { var e = t.cloneNowShown, n = t.rootEl, t = t.cancel; this.isMultiDrag && (pe(!1, n), ue.forEach(function (t) { P(t, "display", "") }), e(), se = !1, t()) }, hideClone: function (t) { var e = this, n = (t.sortable, t.cloneNowHidden), t = t.cancel; this.isMultiDrag && (ue.forEach(function (t) { P(t, "display", "none"), e.options.removeCloneOnHide && t.parentNode && t.parentNode.removeChild(t) }), n(), se = !0, t()) }, dragStartGlobal: function (t) { t.sortable; !this.isMultiDrag && re && re.multiDrag._deselectMultiDrag(), ce.forEach(function (t) { t.sortableIndex = B(t) }), ce = ce.sort(function (t, e) { return t.sortableIndex - e.sortableIndex }), fe = !0 }, dragStarted: function (t) { var e, n = this, t = t.sortable; this.isMultiDrag && (this.options.sort && (t.captureAnimationState(), this.options.animation && (ce.forEach(function (t) { t !== ae && P(t, "position", "absolute") }), e = k(ae, !1, !0, !0), ce.forEach(function (t) { t !== ae && C(t, e) }), de = he = !0)), t.animateAll(function () { de = he = !1, n.options.animation && ce.forEach(function (t) { T(t) }), n.options.sort && ge() })) }, dragOver: function (t) { var e = t.target, n = t.completed, t = t.cancel; he && ~ce.indexOf(e) && (n(!1), t()) }, revert: function (t) { var n, o, e = t.fromSortable, i = t.rootEl, r = t.sortable, a = t.dragRect; 1 < ce.length && (ce.forEach(function (t) { r.addAnimationState({ target: t, rect: he ? k(t) : a }), T(t), t.fromRect = a, e.removeAnimationState(t) }), he = !1, n = !this.options.removeCloneOnHide, o = i, ce.forEach(function (t, e) { e = o.children[t.sortableIndex + (n ? Number(e) : 0)]; e ? o.insertBefore(t, e) : o.appendChild(t) })) }, dragOverCompleted: function (t) { var e, n = t.sortable, o = t.isOwner, i = t.insertion, r = t.activeSortable, a = t.parentEl, l = t.putSortable, t = this.options; i && (o && r._hideClone(), de = !1, t.animation && 1 < ce.length && (he || !o && !r.options.sort && !l) && (e = k(ae, !1, !0, !0), ce.forEach(function (t) { t !== ae && (C(t, e), a.appendChild(t)) }), he = !0), o || (he || ge(), 1 < ce.length ? (o = se, r._showClone(n), r.options.animation && !se && o && ue.forEach(function (t) { r.addAnimationState({ target: t, rect: le }), t.fromRect = le, t.thisAnimationDuration = null })) : r._showClone(n))) }, dragOverAnimationCapture: function (t) { var e = t.dragRect, n = t.isOwner, t = t.activeSortable; ce.forEach(function (t) { t.thisAnimationDuration = null }), t.options.animation && !n && t.multiDrag.isMultiDrag && (le = a({}, e), e = v(ae, !0), le.top -= e.f, le.left -= e.e) }, dragOverAnimationComplete: function () { he && (he = !1, ge()) }, drop: function (t) { var e = t.originalEvent, n = t.rootEl, o = t.parentEl, i = t.sortable, r = t.dispatchSortableEvent, a = t.oldIndex, l = t.putSortable, s = l || this.sortable; if (e) { var c, u, d, h = this.options, f = o.children; if (!fe) if (h.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), I(ae, h.selectedClass, !~ce.indexOf(ae)), ~ce.indexOf(ae)) ce.splice(ce.indexOf(ae), 1), ie = null, W({ sortable: i, rootEl: n, name: "deselect", targetEl: ae, originalEvt: e }); else { if (ce.push(ae), W({ sortable: i, rootEl: n, name: "select", targetEl: ae, originalEvt: e }), e.shiftKey && ie && i.el.contains(ie)) { var p = B(ie), t = B(ae); if (~p && ~t && p !== t) for (var g, m = p < t ? (g = p, t) : (g = t, p + 1); g < m; g++)~ce.indexOf(f[g]) || (I(f[g], h.selectedClass, !0), ce.push(f[g]), W({ sortable: i, rootEl: n, name: "select", targetEl: f[g], originalEvt: e })) } else ie = ae; re = s } fe && this.isMultiDrag && (he = !1, (o[j].options.sort || o !== n) && 1 < ce.length && (c = k(ae), u = B(ae, ":not(." + this.options.selectedClass + ")"), !de && h.animation && (ae.thisAnimationDuration = null), s.captureAnimationState(), de || (h.animation && (ae.fromRect = c, ce.forEach(function (t) { var e; t.thisAnimationDuration = null, t !== ae && (e = he ? k(t) : c, t.fromRect = e, s.addAnimationState({ target: t, rect: e })) })), ge(), ce.forEach(function (t) { f[u] ? o.insertBefore(t, f[u]) : o.appendChild(t), u++ }), a === B(ae) && (d = !1, ce.forEach(function (t) { t.sortableIndex !== B(t) && (d = !0) }), d && r("update"))), ce.forEach(function (t) { T(t) }), s.animateAll()), re = s), (n === o || l && "clone" !== l.lastPutMode) && ue.forEach(function (t) { t.parentNode && t.parentNode.removeChild(t) }) } }, nullingGlobal: function () { this.isMultiDrag = fe = !1, ue.length = 0 }, destroyGlobal: function () { this._deselectMultiDrag(), f(document, "pointerup", this._deselectMultiDrag), f(document, "mouseup", this._deselectMultiDrag), f(document, "touchend", this._deselectMultiDrag), f(document, "keydown", this._checkKeyDown), f(document, "keyup", this._checkKeyUp) }, _deselectMultiDrag: function (t) { if (!(void 0 !== fe && fe || re !== this.sortable || t && N(t.target, this.options.draggable, this.sortable.el, !1) || t && 0 !== t.button)) for (; ce.length;) { var e = ce[0]; I(e, this.options.selectedClass, !1), ce.shift(), W({ sortable: this.sortable, rootEl: this.sortable.el, name: "deselect", targetEl: e, originalEvt: t }) } }, _checkKeyDown: function (t) { t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0) }, _checkKeyUp: function (t) { t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1) } }, a(t, { pluginName: "multiDrag", utils: { select: function (t) { var e = t.parentNode[j]; e && e.options.multiDrag && !~ce.indexOf(t) && (re && re !== e && (re.multiDrag._deselectMultiDrag(), re = e), I(t, e.options.selectedClass, !0), ce.push(t)) }, deselect: function (t) { var e = t.parentNode[j], n = ce.indexOf(t); e && e.options.multiDrag && ~n && (I(t, e.options.selectedClass, !1), ce.splice(n, 1)) } }, eventProperties: function () { var n = this, o = [], i = []; return ce.forEach(function (t) { var e; o.push({ multiDragElement: t, index: t.sortableIndex }), e = he && t !== ae ? -1 : he ? B(t, ":not(." + n.options.selectedClass + ")") : B(t), i.push({ multiDragElement: t, index: e }) }), { items: r(ce), clones: [].concat(ue), oldIndicies: o, newIndicies: i } }, optionListeners: { multiDragKey: function (t) { return "ctrl" === (t = t.toLowerCase()) ? t = "Control" : 1 < t.length && (t = t.charAt(0).toUpperCase() + t.substr(1)), t } } }) }), Bt });
define('forms/widgets/SortableFieldsets', [
    'jquery',
    'Sortable',
    'factories/moduleFactory'
], function (
    $,
    Sortable,
    moduleFactory
) {
    'use strict';
    /*
        SortableFieldsets
        ================
    */

    var SortableFieldsets = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        m = SortableFieldsets.markup;

        o = $.extend({
            selector: '.sortable-fieldsets'
        }, options);

        internal = {
            name: 'SortableFieldsets',
            $e: o.$e || $(o.selector),

            sortableOptions: {
                draggable: '.' + m.DRAGGABLE,
                handle: '.' + m.HANDLE,
                onSort: function () {
                    fn.handleSort();
                }
            },

            templates: {
                dragHandle: {
                    selector: '!.drag-handle-template'
                }
            },

            components: {
                fieldset: {
                    selector: 'fieldset:not(.variant-locked)',
                    ignoreNested: true
                }
            },
            events: {
                'new:fieldset': 'fieldsetNew',
                'modremove @fieldset': 'fieldsetRemove'
            }
        };

        elements = {};
        templates = {};

        fn = {
            init: function () {
                fn.setupFieldsetsForSorting();
                fn.initSortable();
            },

            setupFieldsetsForSorting: function () {
                if (!elements.fieldset) {
                    return;
                }

                if (elements.fieldset.length > 1) {
                    elements.fieldset.addClass(m.DRAGGABLE);

                    if (!fn.noHandle()) {
                        elements.fieldset.append(templates.dragHandle.clone());
                    }
                } else {
                    elements.fieldset.removeClass(m.DRAGGABLE);
                    elements.fieldset.find('.' + m.HANDLE).remove();
                }
            },

            initSortable: function () {
                Sortable.create(internal.$e[0], fn.sortableOptions());
            },

            sortableOptions: function () {
                if (fn.noHandle()) {
                    delete internal.sortableOptions.handle;
                }

                return internal.sortableOptions;
            },

            handleNewFieldset: function () {
                fn.getComponents();
                fn.setupFieldsetsForSorting();
            },

            handleFieldsetRemove: function () {
                fn.getComponents();
                fn.setupFieldsetsForSorting();
            },

            handleSort: function () {
                internal.$e.trigger('sort');
            },

            noHandle: function () {
                return internal.$e.hasClass(m.NO_HANDLE);
            }
        };

        handlers = {
            fieldsetNew: function () {
                fn.handleNewFieldset();
            },

            fieldsetRemove: function (evnt, el) {
                if (el.tagName === 'FIELDSET') {
                    setTimeout(function () { // Need to wait for the element to be removed
                        fn.handleFieldsetRemove();
                    }, 10);
                }
            }
        };

        api = {
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    SortableFieldsets.markup = {
        // States
        DRAGGABLE: 'state-draggable',

        // Component classes
        HANDLE: 'drag-handle',

        // Variants
        NO_HANDLE: 'variant-no-drag-handle'
    };

    return SortableFieldsets;
});

define('forms/Form', [
    'jquery',
    'factories/moduleFactory',
    'factories/validatorFactory',
    'forms/Fieldset',
    'forms/widgets/FieldsetCloner',
    'forms/widgets/SortableFieldsets',
    'services/Xhr',
    'utils/appendValToObj'
    //'Sentry'
], function (
    $,
    moduleFactory,
    validatorFactory,
    Fieldset,
    FieldsetCloner,
    SortableFieldsets,
    Xhr,
    appendValToObj
    //Sentry
) {
    'use strict';
    /*
        Form
        ====

        A form controller to handle the submission of forms. Exposes methods
        to allow to get the data contained within a form (from its fieldsets and
        fields).

        Example:
        var form = new Form({
            $e: $(el)
        });

        <form>
            <fieldset> <!-- NB: All forms MUST have at least 1 fieldset -->
                ...
            </fieldset>
        </form>
    */
    var Form = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = Form.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: 'form',
            initialData: null,
            prepData: null,
            onSubmit: function () { },
            onComplete: function () { },
            onSuccess: function () { },
            onError: function (xhr, status) {
                var errors;

                if (status === 'error' && xhr.responseJSON) {
                    errors = xhr.responseJSON;
                    if (xhr.status === 400) {
                        /*Sentry.captureMessage('Validation error from server', {
                            extra: { errors: JSON.stringify(errors) },
                        });*/
                    }
                    fn.showErrors(errors);
                }
            },
            onDelete: function () { }
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'Form',
            $e: o.$e || $(o.selector),

            xhr: new Xhr(),

            // Caches for child fieldsets
            fieldsets: [],
            initCustomFieldsTimeout: null,

            widgetConstructors: {
                fieldsetCloner: {
                    constructor: FieldsetCloner,
                    $e: o.$e
                },
                sortableFieldsets: SortableFieldsets
            },

            // Dict of components used by this module.
            components: {
                fieldset: {
                    selector: 'fieldset, .fieldset',
                    ignoreNested: true
                },
                allFieldsets: {
                    selector: 'fieldset, .fieldset'
                },
                formSubmit: {
                    selector: '[type="submit"], .form-submit'
                },
                fieldsetCloner: {
                    selector: '.fieldset-cloner'
                },
                sortableFieldsets: {
                    selector: '.sortable-fieldsets'
                },
                deleteControl: {
                    selector: '.delete-control'
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'change': 'internalElChange',
                'keyup': 'internalElKeyup',
                'submit': 'internalElSubmit',
                'complete': 'internalElComplete',
                'new:fieldset @fieldset': 'fieldsetNew',
                'initComplete @fieldset': 'fieldsetInitComplete',
                'destroy @fieldset': 'fieldsetDestroy',
                'sort @sortableFieldsets': 'sortableFieldsetsSort',
                'click @deleteControl': 'deleteControlClick'
            }
        };

        // Elements cache
        elements = {};

        // Primary methods
        fn = {
            // Initialize child fieldsets and form validator
            init: function () {
                fn.initValidator();
                fn.initFieldsets();
                fn.setSubmitStatus();
                fn.initWidgets();

                // with no fieldsets, the form will never be marked ready
                // unless we manually call initCustomFields().
                if (!elements.fieldset) {
                    fn.initCustomFields();
                }
            },

            // Iterate over the cached fieldset elements and use them to
            // initialize fieldset instances
            initFieldsets: function () {
                if (!elements.fieldset) {
                    return;
                }

                elements.fieldset.each(function (i, fieldsetEl) {
                    fn.setupFieldset(fieldsetEl);
                });

                $.each(internal.fieldsets, function (i, fieldset) {
                    fieldset.init();
                });
            },

            // Initialize a single fieldset instance on a supplied fieldset element
            setupFieldset: function (fieldsetEl, callInit) {
                var fieldsetInstance;

                callInit = callInit || false;

                fieldsetInstance = new Fieldset({
                    $e: $(fieldsetEl),
                    form: self
                });

                internal.fieldsets.push(fieldsetInstance);

                if (callInit) {
                    fieldsetInstance.init();
                }
            },

            // Ensure the cached fieldset instances are in the same order as
            // the elements in the DOM
            orderFieldsets: function () {
                var orderedFieldsets = [];

                elements.fieldset.each(function (i, fieldsetEl) {
                    $.each(internal.fieldsets, function (j, fieldset) {
                        if (fieldset && fieldset.getEl()[0] === fieldsetEl) {
                            orderedFieldsets.push(fieldset);
                        }
                    });
                });

                internal.fieldsets = orderedFieldsets;
            },

            // Iterate over the cached fieldsets and get them to initialize
            // their custom fields
            initCustomFields: function (fieldsetEl) {
                var initCustomFieldsMethod = function () {
                    let allFieldsets = elements.allFieldsets || $();
                    let fieldsetLength = allFieldsets.length,
                        initedFieldsetLength = allFieldsets.filter('.' + m.INITED).length;

                    if (fieldsetLength !== initedFieldsetLength) {
                        return;
                    }

                    $.each(internal.fieldsets, function (i, fieldset) {
                        let $fieldsetEl = fieldset.getEl();

                        if (
                            !fieldsetEl ||
                            $fieldsetEl[0] === fieldsetEl
                        ) {
                            fieldset.initCustomFields();
                        }
                    });

                    if (!fn.checkIfReady() && !internal.initCustomFieldsTimeout) {
                        internal.initCustomFieldsTimeout = setTimeout(initCustomFieldsMethod, 100);
                    }
                };

                if (internal.initCustomFieldsTimeout) {
                    clearTimeout(internal.initCustomFieldsTimeout);
                }

                internal.initCustomFieldsTimeout = setTimeout(initCustomFieldsMethod, 100);
            },

            checkIfReady: function () {
                // short-circuit if the data attr is already set
                if (internal.$e.data('isReady')) {
                    return true;
                }

                let isReady = true;
                $.each(internal.fieldsets, function (i, fieldset) {
                    isReady = fieldset.isReady();
                    return isReady;
                });

                if (isReady) {
                    fn.setInitialData();

                    internal.$e.data('isReady', true);
                    internal.$e.trigger('formReady');

                    if (typeof o.onReady === 'function') {
                        o.onReady();
                    }
                }
                return isReady;
            },

            isReady: function () {
                return internal.$e.data('isReady') || false;
            },

            isProcessing: function () {
                return internal.$e.data('processing') || false;
            },

            isDisabled: function () {
                return internal.$e[0].hasAttribute('disabled');
            },

            setInitialData: function () {
                if (o.initialData) {
                    fn.setVals(o.initialData, null, { silent: true });
                }
            },

            // Init the validator for the form
            initValidator: function () {
                validatorFactory({
                    $e: internal.$e,
                    self: self,
                    o: o,
                    internal: internal,
                    elements: elements,
                    fn: fn,
                    m: m
                }).create();
            },

            initWidgets: function () {
                $.each(internal.widgetConstructors, function (componentKey, Widget) {
                    if (elements[componentKey]) {
                        if (typeof Widget === 'object') {
                            new Widget.constructor({
                                $e: Widget.$e || internal.$e.find(Widget.selector),
                                form: self
                            });
                        } else {
                            elements[componentKey].each(function (i, componentEl) {
                                new Widget({
                                    $e: $(componentEl),
                                    form: self
                                });
                            });
                        }
                    }
                });
            },

            // Get and return the name of the form
            getName: function () {
                return internal.$e.attr('name');
            },

            // Get the data from the cached fieldsets and consolidate it into
            // an object. If the form is named use the form name as the name of
            // the object returned.
            getData: function () {
                var formData = {},
                    formName = fn.getName() || '';

                if (!fn.isDisabled()) {
                    $.each(internal.fieldsets, function (i, fieldset) {
                        var fieldsetData = {},
                            fieldsetName = fieldset.getName(),
                            fieldsetValue;

                        if (fieldset.ignore() && !options.all) {
                            return;
                        }

                        fieldsetValue = fieldset.getData();

                        appendValToObj(fieldsetData, fieldsetName, fieldsetValue);
                        appendValToObj(formData, formName, fieldsetData);
                    });
                }

                if ($.isEmptyObject(formData)) {
                    if (formName.length) {
                        formData[formName] = {};
                    }
                }

                return formData;
            },

            // Get a field by name. If no field is found by the child fieldsets
            // false is returned
            getField: function (fieldName, parentKey) {
                var returnField = false;

                $.each(internal.fieldsets, function (i, fieldset) {
                    if (!returnField) {
                        returnField = fieldset.getField(fieldName, parentKey);
                    }

                    if (returnField) {
                        return false;
                    }
                });

                return returnField;
            },

            // Get an array of fields by name. If no fields are found in the child
            // fieldset and empty array is returned
            getFields: function (fieldName) {
                var returnFields = [];
                $.each(internal.fieldsets, function (i, fieldset) {
                    $.each(fieldset.getFields(fieldName), function (i, field) {
                        returnFields.push(field);
                    });
                });

                return returnFields;
            },

            // If a fieldset is destroyed remove it from the cache
            removeDestroyedFieldset: function (fieldsetEl) {
                var fieldsetIndex = -1,
                    remainingFieldsets = [];

                $.each(internal.fieldsets, function (i, fieldset) {
                    if (!(fieldset && fieldset.getEl()[0] === fieldsetEl)) {
                        remainingFieldsets.push(fieldset);
                    } else {
                        fieldsetIndex = i;
                    }
                });

                if (fieldsetIndex > -1) {
                    internal.fieldsets = remainingFieldsets;
                    fn.getComponents();
                }
            },

            setSubmitStatus: function () {
                var isValid = self.isValid(),
                    isProcessing = fn.isProcessing();

                if (elements.formSubmit) {
                    internal.$e.toggleClass(m.DISABLED, !isValid);

                    elements.formSubmit.toggleClass(m.DISABLED, !isValid);
                    elements.formSubmit.toggleClass(m.PROCESSING, isProcessing);

                    elements.formSubmit.prop('disabled', !isValid);
                }
            },

            setProcessing: function () {
                internal.$e.addClass(m.PROCESSING);
                internal.$e.data('processing', true);
            },

            clearProcessing: function () {
                internal.$e.removeClass(m.PROCESSING);
                internal.$e.data('processing', false);
            },

            handleAjaxSubmit: function () {
                var postData, formData, xhrMethod, formAction;

                postData = fn.getData();
                if (o.prepData) {
                    postData = o.prepData(postData);
                }
                formData = new FormData();
                xhrMethod = internal.$e.attr('method').toLowerCase();
                formAction = internal.$e.attr('action');

                $.each(postData, function (key, value) {
                    if (value instanceof File) {
                        formData.append(key, value, value.name);
                    } else {
                        if ($.isArray(value)) {
                            if (value.length) {
                                $.each(value, function (i, valueItem) {
                                    formData.append(key + '[]', JSON.stringify(valueItem));
                                });
                            } else {
                                formData.append(key + '[]', '');
                            }
                        } else {
                            formData.append(key, value);
                        }
                    }
                });

                internal.xhr[xhrMethod](formData, {
                    url: formAction,
                    cache: false,
                    contentType: false,
                    processData: false,
                    complete: function (xhr, status) {
                        o.onComplete(xhr, status);

                        fn.clearProcessing();
                        fn.setSubmitStatus();
                    },
                    success: function (data, status, xhr) {
                        o.onSuccess(data, status, xhr);
                    },
                    error: function (xhr, status, error) {
                        o.onError(xhr, status, error);

                        fn.clearProcessing();
                        fn.setSubmitStatus();
                    }
                });
            },

            setVal: function (key, value, options) {
                var field = fn.getField(key);

                options = options || {};

                if (field) {
                    field.setVal(value, options);
                }
            },

            setVals: function (valObj, parentKey, options) {
                options = options || (typeof parentKey === 'object' ? parentKey : {});
                parentKey = typeof parentKey === 'string' ? parentKey : '';

                $.each(valObj, function (fieldKey, value) {
                    var field = fn.getField(fieldKey, parentKey);
                    if (field) {
                        field.setVal(value, options);
                    } else if ($.isPlainObject(value)) {
                        fn.setVals(value, fieldKey, options);
                    }
                });
            },

            getVal: function (fieldKey) {
                var field = fn.getField(fieldKey);

                if (field) {
                    return field.getVal();
                } else {
                    return null;
                }
            },

            getVals: function (fieldKeyArr) {
                var vals = {};

                $.each(fieldKeyArr, function (i, fieldKey) {
                    vals[fieldKey] = fn.getVal(fieldKey);
                });

                return vals;
            },

            reset: function (resetOpts) {
                $.each(internal.fieldsets, function (i, fieldset) {
                    fieldset.reset(resetOpts);
                });
            },

            showErrors: function (errors, parentKey) {
                var errorField;

                $.each(errors, function (fieldKey, errorMsg) {
                    if ($.isPlainObject(errorMsg)) {
                        fn.showErrors(errorMsg, fieldKey);
                    } else {
                        errorField = fn.getField(fieldKey, parentKey);

                        if (errorField) {
                            errorField.showError(errorMsg);
                        }
                    }
                });
            },

            stopProcessing: function () {
                fn.clearProcessing();
                fn.setSubmitStatus();
            },

            ignore: function () {
                return !!internal.$e.data('ignore');
            },

            submit: function (options) {
                options = options || {};
                $.extend(o, options);
                if (!fn.isProcessing()) {
                    internal.$e.submit();
                }
            }
        };

        // Event handlers
        handlers = {
            internalElChange: function () {
                fn.setSubmitStatus();
            },

            internalElKeyup: function () {
                fn.setSubmitStatus();
            },

            internalElSubmit: function (evnt) {
                fn.setProcessing();
                fn.setSubmitStatus();

                if (
                    internal.$e.hasClass(m.DISABLED) ||
                    !internal.$e.attr('action') ||
                    internal.$e.data('ajax')
                ) {
                    evnt.preventDefault();

                    if (!internal.$e.attr('action')) {
                        o.onSubmit(evnt, fn.getData());
                    }

                    if (internal.$e.data('ajax')) {
                        fn.handleAjaxSubmit();
                    }
                }
            },

            internalElComplete: function () {
                fn.clearProcessing();
                fn.setSubmitStatus();
            },

            fieldsetNew: function (evnt) {
                if (evnt.intercepted) {
                    return;
                }

                evnt.intercepted = true;

                if (!$(this).data('fieldsetInstance')) {
                    fn.getComponents();
                    fn.setupFieldset(this, true);
                    fn.initCustomFields(this);
                    fn.orderFieldsets();
                }
            },

            fieldsetInitComplete: function () {
                fn.initCustomFields();
            },

            fieldsetDestroy: function (evnt, fieldset) {
                var fieldsetEl;

                if (
                    evnt.intercepted ||
                    !fieldset
                ) {
                    return;
                }
                evnt.intercepted = true;

                fieldsetEl = fieldset.self.getEl();
                fn.removeDestroyedFieldset(fieldsetEl);

                setTimeout(function () {
                    fn.orderFieldsets();
                }, 50);
            },

            sortableFieldsetsSort: function () {
                fn.getComponents();
                fn.orderFieldsets();
            },

            deleteControlClick: function () {
                o.onDelete();
            }
        };

        // Interface methods to be exposed
        api = {
            getData: fn.getData,
            getField: fn.getField,
            getFields: fn.getFields,
            setVals: fn.setVals,
            setVal: fn.setVal,
            getVal: fn.getVal,
            getVals: fn.getVals,
            reset: fn.reset,
            isReady: fn.isReady,
            showErrors: fn.showErrors,
            stopProcessing: fn.stopProcessing,
            ignore: fn.ignore,
            submit: fn.submit,
            setProcessing: fn.setProcessing,
            clearProcessing: fn.clearProcessing
        };

        // Use the moduleFactory to setup this module
        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    Form.markup = {};

    return Form;
});

define('managers/ModalsManager', [
    'jquery',
    'factories/moduleFactory',
    'utils/transitionUtil',
    'forms/Form',
    'utils/keycodes',
    'utils/globalElements'
], function (
    $,
    moduleFactory,
    transitionUtil,
    Form,
    kc,
    globalElements
) {
    'use strict';
    /*
        Modals Manager
        ==============

        A manager for modals with the resposibility of:
        - Showing/Launching the modal
        - Appending supplied content to the content wrapper in the modal
        - Cloning and instantiating modal forms for use in the modal

        Example:
        <div class='modals-container global-modals'>
            <div class='modal'>
                <a class='close-modal'>
                    <i class='icon'>
                        {% include 'svg/forms/_add.html' %}
                    </i>
                </a>
                <div class='modal-content'></div>
            </div>
            <div class='modal-curtain'></div>
        </div>

        var modalsManager = new ModalsManager({
            $e: $('.modals-container')
        });

        NB:
        - This is intended to be a singleton and as such is instatiated by the
          core.js
    */
    var ModalsManager = function (options) {
        var self, o, m, internal, elements, templates, fn, handlers, api;

        self = this;

        // Markup & state classes
        m = ModalsManager.markup;

        // Options
        o = $.extend({
            $e: null,
            selector: '.modals-container'
        }, options);

        // Privates intended to be used internally
        internal = {
            name: 'ModalsManager',
            $e: o.$e || $(o.selector),

            modals: [],

            templates: {
                modal: {
                    selector: '.modal-template'
                },
                confirmationModal: {
                    selector: '!.confirmation-modal-template'
                },
                unexpectedErrorModal: {
                    selector: '!.unexpected-error-modal-template'
                }
            },

            // Dict of components used by this module.
            components: {
                // Core components
                modal: {
                    selector: '.modal'
                },
                closeModal: {
                    selector: '.close-modal'
                },
                modalPane: {
                    selector: '.modal-pane'
                },
                modalContent: {
                    selector: '.modal-content'
                },
                modalCurtain: {
                    selector: '.modal-curtain'
                },
                modalForms: {
                    selector: '.modal-form'
                },
                confirmBtn: {
                    selector: '.button.confirm'
                }
            },

            // Map of module events to handlers, to be bound in the factory.
            events: {
                'click @closeModal': 'closeModalClick',
                'click @modalCurtain': 'modalCurtainClick',
                'click @confirmBtn': 'confirmBtnClick'
            }
        };

        // Elements cache
        elements = {};

        templates = {};

        // Primary methods
        fn = {
            // Nothing to see here.
            init: function () { },

            // Launch a modal form based on its type
            // accepts: {type: 'form-type'}
            launchForm: function (options) {
                var formInstance, $form, $clonedForm, currentModal;

                $form = elements.modalForms.filter('[data-form-type="' + options.type + '"]');
                $clonedForm = $form.clone();

                options.content = $clonedForm;

                fn.launchModal(options);
                currentModal = fn.getCurrentActiveModal();

                if (options.formContent) {
                    $clonedForm.find('.' + m.FORM_CONTENT).html(options.formContent);
                }

                formInstance = new Form({
                    $e: $clonedForm,
                    onSubmit: function (evnt, formData) {
                        currentModal.onSubmit(evnt, formData);
                    },
                    onComplete: function (xhr, status) {
                        currentModal.onComplete(xhr, status);
                    },
                    onSuccess: function (data, status, xhr) {
                        currentModal.onSuccess(data, status, xhr);
                        fn.closeModal();
                    },
                    onError: function (xhr, status, error) {
                        currentModal.onError(xhr, status, error);
                    }
                });

                currentModal.form = formInstance;

                return currentModal;
            },

            // Launch the modal, with the option to send in content.
            launchModal: function (options) {
                var currentModal, content;

                options = options || {};

                if (!options.content) {
                    return;
                }

                content = options.content;
                fn.createNewModal(options);
                currentModal = fn.getCurrentActiveModal();

                if (content !== undefined) {
                    fn.replaceContent(content);
                }

                globalElements.body.addClass(m.DISABLED_SCROLL);
                internal.$e.addClass(m.OPEN);

                requestAnimationFrame(function () {
                    currentModal.modal.addClass(m.SHOW);
                    currentModal.modalCurtain.addClass(m.SHOW);
                });
                globalElements.doc.on('keyup', handlers.documentKeyup);

                return currentModal;
            },

            launchConfirmationModal: function (modalContent, modalOptions) {
                var modalInstance;

                modalInstance = fn.launchModal($.extend({
                    content: templates.confirmationModal(modalContent)
                }, modalOptions));

                return modalInstance;
            },

            launchUnexpectedErrorModal: function (modalContent, modalOptions) {
                var modalInstance;

                modalOptions = modalOptions || {};
                modalInstance = fn.launchModal($.extend({
                    content: templates.unexpectedErrorModal(modalContent)
                }, modalOptions));

                return modalInstance;
            },

            createNewModal: function (options) {
                var newModal;
                options = options || {};

                internal.$e.append(templates.modal.clone());
                fn.getComponents();

                newModal = {
                    modal: elements.modal.last(),
                    modalPane: elements.modalPane.last(),
                    modalContent: elements.modalContent.last(),
                    modalCurtain: elements.modalCurtain.last(),
                    onClose: options.onClose || function () { },
                    onSubmit: options.onSubmit || function () { },
                    onComplete: options.onComplete || function () { },
                    onSuccess: options.onSuccess || function () { },
                    onError: options.onError || function () { },
                    onConfirm: options.onConfirm || function () { },
                    beforeClose: options.beforeClose || function () { },
                    afterClose: options.afterClose || function () { },
                    closeModal: fn.closeModal
                };
                internal.modals.push(newModal);

                newModal.modal.css('z-index', internal.modals.length);

                if (options.size) {
                    newModal.modalPane.addClass('variant-' + options.size);
                }
            },

            getCurrentActiveModal: function (pop) {
                var lastModal;
                pop = pop || false;

                if (pop) {
                    lastModal = internal.modals.pop();
                } else {
                    lastModal = internal.modals[internal.modals.length - 1];
                }

                return lastModal;
            },

            // Empty the modal content and append the supplied content
            replaceContent: function (content) {
                var $content = $(content),
                    currentModal = fn.getCurrentActiveModal();

                currentModal.modalContent
                    .empty()
                    .append($content);
            },

            // Close the modal
            closeModal: function (closeControl) {
                var currentModal, closeIntercepted, $closeControl;

                currentModal = fn.getCurrentActiveModal(true);

                if (!currentModal) {
                    return;
                }

                closeIntercepted = currentModal.beforeClose() || false;

                if (closeIntercepted) {
                    return;
                }

                $closeControl = $(closeControl);

                transitionUtil.oneEnd(currentModal.modalCurtain, function () {
                    currentModal.modal.find('.' + m.INITED).each(function (i, moduleEl) {
                        $(moduleEl).trigger('modremove', moduleEl);
                    });

                    currentModal.modal.remove();

                    if (!internal.modals.length) {
                        globalElements.body.removeClass(m.DISABLED_SCROLL);
                        internal.$e.removeClass(m.OPEN);
                    }

                    fn.getComponents();
                    currentModal.afterClose();
                });

                currentModal.modal.removeClass(m.SHOW);
                currentModal.modalCurtain.removeClass(m.SHOW);
                globalElements.doc.off('keyup', handlers.documentKeyup);
                currentModal.onClose({ byBtn: $closeControl.hasClass(m.BUTTON) });

            },

            handleConfirm: function () {
                var currentModal = fn.getCurrentActiveModal();
                currentModal.onConfirm({ modal: currentModal });
            }
        };

        // Event handlers
        handlers = {
            // Close the modal when the close X is clicked
            closeModalClick: function () {
                fn.closeModal(this);
            },

            // Close the modal when the curtain is clicked
            modalCurtainClick: function () {
                fn.closeModal();
            },

            documentKeyup: function (evnt) {
                if (evnt.which === kc.ESCAPE) {
                    fn.closeModal();
                }
            },

            confirmBtnClick: function () {
                fn.handleConfirm();
            }
        };

        // A map of methods to be exposed on the instance of this module
        api = {
            launchForm: fn.launchForm,
            launchModal: fn.launchModal,
            launchConfirmationModal: fn.launchConfirmationModal,
            launchUnexpectedErrorModal: fn.launchUnexpectedErrorModal
        };

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            internal: internal,
            elements: elements,
            templates: templates,
            fn: fn,
            handlers: handlers,
            m: m,
            api: api
        }).create();
    };

    // Module markup
    ModalsManager.markup = {
        // States
        DISABLED_SCROLL: 'disable-scroll',

        // DOM Components
        FORM_CONTENT: 'form-content',
        BUTTON: 'button'
    };

    return ModalsManager;
});

define('managers/HeroSizeManager', [
    'jquery',
    'factories/moduleFactory',
    'services/layout'
], function (
    $,
    moduleFactory,
    layout
) {
    'use strict';

    var HeroSizeManager = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = HeroSizeManager.markup;

        o = $.extend({
            $e: null,
            selector: 'body'
        }, options);

        internal = {
            name: 'HeroSizeManager',
            $e: o.$e || $(o.selector),

            components: {
                hero: {
                    selector: '.' + m.HERO
                },

                licenseTooltip: {
                    selector: '.' + m.LICENSE_TOOLTIP
                }

            },
            events: {
            }
        };

        elements = {};

        fn = {
            init: function () {
                fn.update();
                layout.onResize(handlers.resize);
            },
            update: function () {
                if (!elements.hero) {
                    return;
                }

                elements.hero.each(function () {
                    var $hero = $(this),
                        $content = $hero.find('.' + m.HERO_CONTENT),
                        heroOffset,
                        contentOffset;

                    if ($content.length) {
                        $hero.css('height', '');

                        heroOffset = $hero.offset().top;
                        contentOffset = $content.offset().top;

                        if (contentOffset < heroOffset) {
                            $hero.height($hero.height() + (heroOffset - contentOffset));
                        }
                    }
                });

                if (elements.licenseTooltip) {
                    elements.licenseTooltip.toggleClass(m.REVERSE_X, window.innerWidth > 420);
                }
            }
        };

        handlers = {
            resize: function () {
                fn.update();
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    HeroSizeManager.markup = {
        HERO: 'hero',
        HERO_CONTENT: 'hero-content',
        LICENSE_TOOLTIP: 'license-tooltip',
        REVERSE_X: 'variant-reverse-x'
    };

    return HeroSizeManager;
});

define('utils/jsonUtil', [
    'jquery'
], function (
    $
) {
    'use strict';

    var jsonUtil = {
        paramsToJson: function (params) {
            var urlParams, parsedParams;
            urlParams = params.substring(1);
            parsedParams = decodeURIComponent(urlParams).replace(/"/g, '\\"').replace(/^&/g, '').replace(/&/g, '","').replace(/=/g, '":"');
            return $.trim(parsedParams).length ? JSON.parse('{"' + parsedParams + '"}') : {};
        },

        jsonToParams: function (jsonData, mapKey) {
            var params = [];

            $.each(jsonData, function (filterKey, filterData) {
                var param = false;

                if (typeof filterData === 'object') {
                    if ($.isArray(filterData) && mapKey) {
                        filterData = filterData.map(function (filterOption) {
                            return filterOption[mapKey];
                        });
                    }

                    if (!$.isEmptyObject(filterData)) {
                        param = encodeURIComponent(filterKey) + '=' + encodeURIComponent(JSON.stringify(filterData));
                    }
                } else {
                    if (filterData) {
                        param = encodeURIComponent(filterKey) + '=' + encodeURIComponent(filterData);
                    }
                }

                if (param) {
                    params.push(param);
                }
            });

            return params.join('&');
        },

        isDiff: function (jsonA, jsonB) {
            return JSON.stringify(jsonA) !== JSON.stringify(jsonB);
        },

        isDiffSimple: function (valueA, valueB) {
            var typeA, typeB, valsDiff, i, valKey, valItemA, valItemB;

            typeA = $.type(valueA);
            typeB = $.type(valueB);
            valsDiff = false;

            if (typeA !== typeB) {
                return true;
            }

            switch (typeA) {
                case 'boolean':
                case 'number':
                case 'string':
                    return valueA !== valueB;

                case 'array':
                    valsDiff = valueA.length !== valueB.length;

                    if (!valsDiff) {
                        for (i = 0; i < valueA.length; i++) {
                            valItemA = valueA[i];
                            valItemB = valueB[i];

                            valsDiff = jsonUtil.isDiffSimple(valItemA, valItemB);

                            if (valsDiff) {
                                return valsDiff;
                            }
                        }
                    }

                    return valsDiff;

                case 'object':
                    for (valKey in valueA) {
                        if (Object.prototype.hasOwnProperty.call(valueA, valKey)) {
                            valsDiff = (
                                valueB[valKey] === undefined ||
                                jsonUtil.isDiff(valueA[valKey], valueB[valKey])
                            );

                            if (valsDiff) {
                                return valsDiff;
                            }
                        }
                    }
                    return valsDiff;
            }
        }
    };

    return jsonUtil;
});

define('managers/GlobalSearchManager', [
    'jquery',
    'forms/Form',
    'utils/keycodes',
    'utils/jsonUtil',
    'factories/moduleFactory'
], function (
    $,
    Form,
    kc,
    jsonUtil,
    moduleFactory
) {
    'use strict';

    var GlobalSearchManager = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = GlobalSearchManager.markup;

        o = $.extend({
            $e: null,
            selector: '#global-search',
            queryKey: 'q',
            redirectOnSelect: true,
            useResultSlug: false,
            resetWhenEmpty: false,
            searchEndpoint: '/searchresults/?q={{ query }}',
            resetEndpoint: '/search/'
        }, options);

        internal = {
            name: 'GlobalSearchManager',
            $e: o.$e || $(o.selector),

            autocomplete: null,
            searchEndpoint: o.searchEndpoint,
            resetEndpoint: o.resetEndpoint,
            currentResultJson: null,

            components: {
                autocomplete: {
                    selector: '.autocomplete'
                },

                autocompleteControl: {
                    selector: '.autocomplete .autocomplete-control'
                },

                autocompleteCta: {
                    selector: '.autocomplete-cta'
                }
            },

            events: {
                'click @autocompleteCta': 'autocompleteCtaClick'
            }
        };

        elements = {};

        fn = {
            init: function () {
                // In tests globalSearch is not always present
                if (!internal.$e || !internal.$e.length) {
                    return;
                }

                new Form({
                    $e: internal.$e
                });

                elements.autocomplete.data('handleAutoCompleteSelect', fn.handleAutoCompleteSelect);
                internal.autocomplete = elements.autocomplete.data('autocompleteInstance');
            },

            handleAutoCompleteSelect: function (resultJson, displayLabel) {
                var searchJson, autocompleteVal, q;

                searchJson = jsonUtil.paramsToJson(location.search);
                autocompleteVal = elements.autocompleteControl.val();
                q = null;

                elements.autocompleteControl.val(displayLabel);
                elements.autocomplete.addClass(m.TAG_SELECTED);

                if (!resultJson) {
                    if (o.resetWhenEmpty && !autocompleteVal) {
                        q = '';
                    } else if (o.useResultSlug) {
                        if (internal.currentResultJson && internal.currentResultJson.slug) {
                            q = internal.currentResultJson.slug;
                        } else {
                            resultJson = internal.autocomplete.findResult(autocompleteVal);

                            if (resultJson) {
                                q = resultJson.slug;
                            }
                        }
                    } else if (autocompleteVal && !o.useResultSlug) {
                        q = autocompleteVal;
                    }
                } else {
                    internal.currentResultJson = resultJson;

                    if (o.useResultSlug) {
                        q = resultJson.slug;
                    }
                }

                if (q !== null) {
                    searchJson[o.queryKey] = q;
                    fn.doSearch(searchJson);
                } else if (o.redirectOnSelect && resultJson) {
                    window.location = resultJson.read_url;
                }
            },

            doSearch: function (searchJson) {
                var pathname = location.pathname;

                delete searchJson.page;

                if (pathname.length > 1 && internal.searchEndpoint.indexOf(pathname) > -1) {
                    window.location.search = jsonUtil.jsonToParams(searchJson);
                } else {
                    window.location = fn.getSearchEndpoint(searchJson[o.queryKey]);
                }
            },

            getSearchEndpoint: function (query) {
                var pathname, endpoint;

                pathname = location.pathname;
                endpoint = internal.searchEndpoint.replace('{{ query }}', query);

                if (location.search.length && internal.searchEndpoint.indexOf(pathname) > -1) {
                    endpoint += '&' + location.search.replace(/^\?/, '').replace(/q=.*?(&|$)/, '');
                }

                return endpoint;
            },

            reset: function (options) {
                var searchJson;
                options = options || {};

                if (options.removeParam) {
                    searchJson = jsonUtil.paramsToJson(location.search);
                    delete searchJson[options.removeParam];
                    window.location.search = jsonUtil.jsonToParams(searchJson);
                } else {
                    window.location = internal.resetEndpoint;
                }
            }
        };

        handlers = {
            autocompleteCtaClick: function () {
                fn.handleAutoCompleteSelect();
            }
        };

        api = {
            reset: fn.reset
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    GlobalSearchManager.markup = {
        TAG_SELECTED: 'state-tag-selected'
    };

    return GlobalSearchManager;
});

define('managers/RailManager', [
    'jquery',
    'factories/moduleFactory',
    'forms/widgets/DropMenu'
], function (
    $,
    moduleFactory,
    DropMenu
) {
    'use strict';

    var RailManager = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = RailManager.markup;

        o = $.extend({
            $e: null,
            selector: '.rail'
        }, options);

        internal = {
            name: 'RailManager',
            $e: o.$e || $(o.selector),

            components: {
                dropMenu: {
                    selector: '.drop-menu',
                    constructor: DropMenu,
                    moduleOptions: {
                        selfToggle: true
                    }
                }
            },
            events: {}
        };

        elements = {};

        fn = {
            init: function () { }
        };

        handlers = {};

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();

    };

    RailManager.markup = {};

    return RailManager;
});

define('ui/Breadcrumb', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var Breadcrumb = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = Breadcrumb.markup;

        o = $.extend({
            $e: null,
            selector: '',
            targetSelector: ''
        }, options);

        internal = {
            name: 'Breadcrumb',
            $e: o.$e || $(o.selector),

            components: {
                breadcrumbLink: {
                    selector: 'a'
                },
                breadcrumbArrow: {
                    selector: '.icon'
                },
                breadcrumbLabel: {
                    selector: '.breadcrumb-label'
                }
            },
            events: {}
        };

        elements = {};

        fn = {
            init: function () {
                if (internal.$e.length === 0) {
                    return;
                }
            }
        };

        handlers = {};

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    Breadcrumb.markup = {};

    return Breadcrumb;
});



define('services/CSRFLoader', [
    'jquery',
    'factories/moduleFactory',
    'js.cookie'
], function (
    $,
    moduleFactory,
    Cookies
) {
    'use strict';

    var CSRFLoader = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = CSRFLoader.markup;

        o = $.extend({

        }, options);

        internal = {
            name: 'CSRFLoader',
            selector: '[data-csrf]',
            events: {}
        };

        elements = {};

        fn = {
            init: function () {
                var $csrf_placeholders = $(internal.selector);

                if ($csrf_placeholders.length === 0) {
                    return;
                }

                /*$.get('/csrf/', {},
                    function (csrf) {
                        if (csrf) {
                            $csrf_placeholders.replaceWith(
                                '<input type="hidden" name="csrfmiddlewaretoken" value="' + csrf.token + '">'
                            );
                            Cookies.set('csrftoken', csrf.token, { path: '/' });
                        }
                    });*/
            }
        };

        handlers = {};

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    CSRFLoader.markup = {};

    return CSRFLoader;
});



/**
 * requestAnimationFrame version: "0.0.23" Copyright (c) 2011-2012, Cyril Agosta ( cyril.agosta.dev@gmail.com) All Rights Reserved.
 * Available via the mit license.
 * see: http://github.com/cagosta/requestAnimationFrame for details
 *
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel
 * mit license
 *
 */


(function (global) {


    (function () {


        if (global.requestAnimationFrame) {

            return;

        }

        if (global.webkitRequestAnimationFrame) { // Chrome <= 23, Safari <= 6.1, Blackberry 10

            global.requestAnimationFrame = global['webkitRequestAnimationFrame'];
            global.cancelAnimationFrame = global['webkitCancelAnimationFrame'] || global['webkitCancelRequestAnimationFrame'];
            return;

        }

        // IE <= 9, Android <= 4.3, very old/rare browsers

        var lastTime = 0;

        global.requestAnimationFrame = function (callback) {

            var currTime = new Date().getTime();

            var timeToCall = Math.max(0, 16 - (currTime - lastTime));

            var id = global.setTimeout(function () {

                callback(currTime + timeToCall);

            }, timeToCall);

            lastTime = currTime + timeToCall;

            return id; // return the id for cancellation capabilities

        };

        global.cancelAnimationFrame = function (id) {

            clearTimeout(id);

        };

    })();

    if (typeof define === 'function') {

        define('requireAnimationFrame', [], function () {

            return global.requestAnimationFrame;

        });

    }

})(window);
define('core', [
    'jquery',
    'utils/jqDomUtils',
    'ui/Header',
    'ui/Drawer',
    'ui/ModuleLayout',
    'ui/ListingLayout',
    'services/AnchorLinkObserver',
    'services/ExternalLinkObserver',
    'managers/ModalsManager',
    'managers/HeroSizeManager',
    'managers/GlobalSearchManager',
    'managers/RailManager',
    'ui/Breadcrumb',
    'services/CSRFLoader',
    // Non-assigned includes
    'requireAnimationFrame'
], function (
    $,
    jqDomUtils,
    Header,
    Drawer,
    ModuleLayout,
    ListingLayout,
    AnchorLinkObserver,
    ExternalLinkObserver,
    ModalsManager,
    HeroSizeManager,
    GlobalSearchManager,
    RailManager,
    Breadcrumb,
    CSRFLoader
) {
    'use strict';

    var internal = {
        isIniting: false,
        isInited: false
    };

    var core = {
        constructors: [
            // NOTE: order here is important, as later services may depend
            // on earlier ones being instantiated already.
            {
                name: 'modalsManager',
                constructor: ModalsManager,
                options: {
                    selector: '.global-modals'
                }
            },
            {
                multi: true,
                name: 'moduleLayouts',
                constructor: ModuleLayout,
                options: {
                    selector: '.' + ModuleLayout.markup.CONTAINER
                }
            },
            {
                multi: true,
                name: 'listingLayouts',
                constructor: ListingLayout,
                options: {
                    selector: '.' + ListingLayout.markup.CONTAINER
                }
            },
            {
                name: 'header',
                constructor: Header,
                options: {
                    selector: '.global-header'
                }
            },
            {
                name: 'drawer',
                constructor: Drawer,
                options: {
                    selector: '.global-drawer'
                }
            },
            {
                name: 'anchorLinkObserver',
                constructor: AnchorLinkObserver,
                options: {
                    selector: '.global-container'
                }
            },
            {
                // NOTE: depends on modalsManager
                name: 'externalLinkObserver',
                constructor: ExternalLinkObserver,
                options: {
                    linksInModal: false,
                    selector: '.global-container'
                }
            },
            {
                name: 'heroSizeManager',
                constructor: HeroSizeManager
            },
            {
                name: 'globalSearchManager',
                constructor: GlobalSearchManager,
                options: {
                    selector: '#global-search'
                }
            },
            {
                name: 'railManager',
                constructor: RailManager,
                options: {
                    selector: '.rail'
                }
            },
            {
                name: 'breadcrumb',
                constructor: Breadcrumb,
                options: {
                    selector: '.rail-nav-breadcrumb'
                }
            }
        ],
        instances: {}
    };

    core.init = function (scripts) {
        internal.isIniting = true;

        $.each(core.constructors, function (idx, constructorObj) {
            var options = $.extend((constructorObj.options || {}));

            constructorObj.constructor._core = core;

            if (constructorObj.multi) {
                core.instances[constructorObj.name] = [];
                $(options.selector).each(function () {
                    var individualInstanceOptions = $.extend({}, options, { $e: $(this) });

                    core.instances[constructorObj.name].push(
                        new constructorObj.constructor(individualInstanceOptions, core.instances)
                    );
                });
            } else {
                core.instances[constructorObj.name] =
                    new constructorObj.constructor(options, core.instances);
            }
        });

        if (scripts && scripts.length) {
            //core.runScripts(scripts);
        }
        internal.isInited = true;
    };

    core.destroy = function () {
        $.each(Object.values(core.instances).flat(), function (idx, instance) {
            if (instance.destroy instanceof Function) {
                instance.destroy();
            }
        });
        internal.isIniting = false;
        internal.isInited = false;
    };

    core.runScripts = function (scripts) {
        $.each(scripts, function (i, script) {
            if ($.isFunction(script)) {
                script(core);
            }
        });
    };

    core.getInstance = function (instanceName) {
        // until we've got a way to init core once for all our unit tests,
        // we're stuck leaving this init-on-demand logic here.
        if (!internal.isInited && !internal.isIniting) {
            core.init();
        }

        if (!core.instances[instanceName]) {
            throw 'Core: No modules available for ' + instanceName;
        }

        return core.instances[instanceName];
    };

    return core;
});

define('ui/OpenCloseToggler', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var OpenCloseToggler = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = OpenCloseToggler.markup;

        o = $.extend({
            $e: null,
            selector: '',
            targetSelector: ''
        }, options);

        internal = {
            name: 'OpenCloseToggler',
            $e: o.$e || $(o.selector),

            components: {
                target: {
                    selector: o.targetSelector
                }
            },
            events: {
                'click': 'click'
            }
        };

        elements = {};

        fn = {
            init: function () {
            },
            toggle: function () {
                elements.target.toggleClass(m.OPEN);
            }
        };

        handlers = {
            click: function (evnt) {
                evnt.preventDefault();
                fn.toggle();
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    OpenCloseToggler.markup = {};

    return OpenCloseToggler;
});

define('ui/MoreText', [
    'jquery',
    'factories/moduleFactory',
    'services/layout'
], function (
    $,
    moduleFactory,
    layout
) {
    'use strict';

    var MoreText = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = MoreText.markup;

        o = $.extend({
            $e: null,
            selector: '.more-text'
        }, options);

        internal = {
            name: 'MoreText',
            $e: o.$e || $(o.selector),

            components: {
                moreLink: {
                    selector: m.LINK
                },
                introText: {
                    selector: m.INTRO
                },
                fullText: {
                    selector: m.FULL
                }
            },
            events: {
                'click @moreLink': 'moreLinkClick'
            }
        };

        elements = {};

        fn = {
            init: function () {
                fn.hideFullText(false);

            },
            showFullText: function (triggerLayout) {
                elements.introText.hide();
                elements.fullText.show();
                if (triggerLayout) {
                    layout.trigger();
                }
            },
            hideFullText: function (triggerLayout) {
                elements.fullText.hide();
                elements.introText.show();
                if (triggerLayout) {
                    layout.trigger();
                }
            }
        };

        handlers = {
            moreLinkClick: function (evnt) {
                evnt.preventDefault();
                fn.showFullText(true);
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    MoreText.markup = {
        LINK: 'a.more-link',
        INTRO: '.more-text-intro',
        FULL: '.more-text-full'
    };

    return MoreText;
});

define('ui/blocks/EmbedBlock', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var EmbedBlock = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = EmbedBlock.markup;

        o = $.extend({
            selector: '.stream-block.embed-block'
        }, options);

        internal = {
            name: 'UiEmbedBlock',
            $e: o.$e || $(o.selector),

            components: {
                primaryBlockContent: {
                    selector: '.primary-block-content'
                },

                embedContent: {
                    selector: '.embed-content'
                }
            }
        };

        elements = {};

        fn = {
            init: function () {
                fn.setSize();
            },

            setSize: function () {
                var sizeRatio,
                    paddingPercent;

                internal.$e.removeClass(m.SIZED);

                sizeRatio = elements.embedContent.height() / elements.embedContent.width();
                paddingPercent = Math.floor(sizeRatio * 100);

                elements.embedContent.css({
                    'padding-bottom': paddingPercent + '%'
                });

                internal.$e.addClass(m.SIZED);
            }
        };

        handlers = {};

        api = {
            setSize: fn.setSize
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    EmbedBlock.markup = {
        SIZED: 'state-sized'
    };

    return EmbedBlock;
});

/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the mit license */

define('ui/blocks/GalleryBlock', [
    'jquery',
    'factories/moduleFactory',
    'ui/Slideshow'
], function (
    $,
    moduleFactory,
    Slideshow
) {
    'use strict';

    var GalleryBlock = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = GalleryBlock.markup;

        o = $.extend({
            selector: '.stream-block.embed-block'
        }, options);

        internal = {
            name: 'UiGalleryBlock',
            $e: o.$e || $(o.selector),

            components: {
                primaryBlockContent: {
                    selector: '.primary-block-content'
                },

                galleryBlockWrap: {
                    selector: '.gallery-block-wrap'
                }
            },

            events: {
                'click @galleryBlockWrap': 'galleryBlockWrapClick'
            }
        };

        elements = {};

        fn = {
            init: function () { },

            launchSlideshow: function () {
                var $wrapperEl, modal;

                $wrapperEl = $('<div class="slideshow-wrapper" />');

                modal = o.modalsManager.launchModal({
                    content: $wrapperEl
                });

                new Slideshow({
                    $e: $wrapperEl,
                    data: $.extend({ readView: true }, o.data),
                    modal: modal
                });
            }
        };

        handlers = {
            galleryBlockWrapClick: function () {
                fn.launchSlideshow();
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    GalleryBlock.markup = {};

    return GalleryBlock;
});

define('ui/GalleryManager', [
    'jquery',
    'ui/Slideshow',
    'factories/moduleFactory'
], function (
    $,
    Slideshow,
    moduleFactory
) {
    'use strict';

    var GalleryManager = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = GalleryManager.markup;

        o = $.extend({
            $e: null,
            selector: '.gallery-manager',
            modalsManager: null
        }, options);

        internal = {
            name: 'GalleryManager',
            $e: o.$e || $(o.selector),

            components: {
                launchSlideshow: {
                    selector: '.launch-slideshow'
                }
            },

            events: {
                'click @launchSlideshow': 'launchSlideshowClick'
            }
        };

        elements = {};

        fn = {
            init: function () { },

            launchSlideshow: function () {
                var modal, $el;

                $el = $('<div class="slideshow-wrapper" />');
                modal = o.modalsManager.launchModal({
                    content: $el
                });

                new Slideshow({
                    $e: $el,
                    data: $.extend({
                        readView: true
                    }, o.data),
                    modal: modal
                });
            }
        };

        handlers = {
            launchSlideshowClick: function () {
                fn.launchSlideshow();
            }
        };

        api = {};

        // Use the moduleFactory to build the module.
        moduleFactory({
            self: self,
            o: o,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            m: m,
            api: api
        }).create();
    };

    GalleryManager.markup = {};

    return GalleryManager;
});

define('ui/ListExpander', [
    'jquery',
    'factories/moduleFactory'
], function (
    $,
    moduleFactory
) {
    'use strict';

    var ListExpander = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = ListExpander.markup;

        o = $.extend({
            $e: null,
            selector: '.' + m.CONTAINER,
            $siblings: $(),
            index: null
        }, options);

        internal = {
            name: 'ListExpander',
            $e: o.$e || $(o.selector),

            isCollapsed: o.index !== 0,

            dimensions: {
                listContainer: null
            },

            components: {
                listToggleControl: {
                    selector: '.' + m.LIST_TOGGLE_CONTROL
                },

                listContainer: {
                    selector: '.' + m.LIST_CONTAINER
                },

                listItem: {
                    selector: '.' + m.LIST_ITEM
                }
            },

            events: {
                'click @listToggleControl': 'listToggleControlClick',
                'collapse': 'selfCollapse'
            }
        };

        elements = {};

        fn = {
            init: function () {
                fn.toggleExpandState({ initialCollapse: true });
                internal.$e.removeClass(m.HIDE);
                elements.listContainer.addClass(m.ARMED);
            },

            toggleExpandState: function (options) {
                options = options || {};
                internal.isCollapsed = options.forceCollapse || internal.isCollapsed;

                elements.listContainer.css('height', internal.isCollapsed ? 0 : elements.listContainer[0].scrollHeight);
                internal.$e.toggleClass(m.COLLAPSE, internal.isCollapsed);

                if (!internal.isCollapsed && !options.initialCollapse) {
                    fn.collapseSiblings();
                }

                internal.isCollapsed = !internal.isCollapsed;
            },

            collapseSiblings: function () {
                if (o.$siblings.length) {
                    o.$siblings.trigger('collapse');
                }
            }
        };

        handlers = {
            listToggleControlClick: function (evnt) {
                if (!evnt.target.hasAttribute('href')) {
                    fn.toggleExpandState();
                }
            },

            selfCollapse: function () {
                fn.toggleExpandState({ forceCollapse: true });
            }
        };

        api = {
        };

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    ListExpander.markup = {
        //DOM Selector
        CONTAINER: 'list-expander',
        LIST_TOGGLE_CONTROL: 'list-toggle-control',
        LIST_CONTAINER: 'list-container',
        LIST_ITEM: 'list-item',

        // States & variants
        ARMED: 'state-armed'
    };

    return ListExpander;
});

define('services/ieHandler', [
    'jquery',
    'utils/globalElements'
], function (
    $,
    globalElements
) {
    'use strict';

    var ieHandler = {};

    var m = {
        SVG_REQUIRES_SHIM: 'shim-svgs',
        SVG_SHIM_HOLDER: 'shimmed-svg-holder'
    };

    var fn = {
        shimSVG: function ($svg) {
            var svgRect = $svg[0].viewBox.baseVal,
                $canvas = $('<canvas width="' + svgRect.width + '" height="' + svgRect.height + '"></canvas>');

            $svg.parent().addClass(m.SVG_SHIM_HOLDER);
            $svg.before($canvas);
        },
        shimSVGs: function ($e) {
            $('.' + m.SVG_REQUIRES_SHIM + ' svg', $e).each(function () {
                fn.shimSVG($(this));
            });
        }
    };

    ieHandler.init = function () {
        fn.shimSVGs(globalElements.body);
    };


    return ieHandler;
});

define('managers/SearchFiltersManager', [
    'jquery',
    'forms/Form',
    'utils/jsonUtil',
    'factories/moduleFactory'
], function (
    $,
    Form,
    jsonUtil,
    moduleFactory
) {
    'use strict';

    var SearchFiltersManager = function (options) {
        var self, o, m, internal, elements, fn, handlers, api;

        self = this;

        m = SearchFiltersManager.markup;

        o = $.extend({
            $e: null,
            selector: '.search-filters',
            paramMapKey: 'pk',
            override_url: null
        }, options);

        internal = {
            name: 'SearchFiltersManager',
            $e: o.$e || $(o.selector),

            form: null,
            searchJson: {},
            validFilters: true,

            components: {
                dateRangeSelects: {
                    selector: '.date-range-selects'
                },
                dateRangeValidationMessage: {
                    selector: '.date-range-selects .validation-message'
                },
                field: {
                    selector: '.field'
                }
            },

            events: {
                'formReady': 'formReady',
                'change': 'filterChange'
            }
        };

        elements = {};

        fn = {
            init: function () {
                internal.form = new Form({
                    $e: internal.$e
                });
            },

            cacheFilters: function () {
                internal.searchJson = jsonUtil.paramsToJson(location.search);
                $.extend(internal.searchJson, internal.form.getData());
                delete internal.searchJson.page;
            },

            doSearch: function () {
                var newSearchJson, prevSearchJson, newSearchParams;

                prevSearchJson = $.extend({}, internal.searchJson);
                newSearchJson = $.extend({}, internal.searchJson, internal.form.getData());

                if (jsonUtil.isDiff(prevSearchJson, newSearchJson)) {
                    newSearchParams = jsonUtil.jsonToParams(newSearchJson, o.paramMapKey);
                    if (o.override_url) {
                        window.location = o.override_url + '?' + newSearchParams;
                    } else {
                        location.search = newSearchParams;
                    }
                }
            },

            validate: function () {
                var isValid, filterData, startYearInt, endYearInt;

                isValid = true;
                filterData = internal.form.getData();
                startYearInt = parseInt(filterData.start_year, 10);
                endYearInt = parseInt(filterData.end_year, 10);

                isValid = startYearInt <= endYearInt;
                elements.dateRangeSelects.toggleClass(m.INVALID, startYearInt > endYearInt);

                internal.validFilters = isValid;
            },

            isValid: function () {
                fn.validate();
                return internal.validFilters;
            }
        };

        handlers = {
            formReady: function () {
                internal.form = internal.$e.data('formInstance');
                fn.cacheFilters();
            },

            filterChange: function () {
                if (internal.form && internal.form.isReady() && fn.isValid()) {
                    fn.doSearch();
                }
            }
        };

        api = {};

        moduleFactory({
            self: self,
            o: o,
            m: m,
            internal: internal,
            elements: elements,
            fn: fn,
            handlers: handlers,
            api: api
        }).create();
    };

    SearchFiltersManager.markup = {};

    return SearchFiltersManager;
});

require([
    //'Sentry',
    'core',
    'js.cookie',
    'ui/OpenCloseToggler',
    'ui/MoreText',
    'ui/blocks/EmbedBlock',
    'ui/blocks/GalleryBlock',
    'ui/Breadcrumb',
    'ui/GalleryManager',
    'ui/ListExpander'
]);

define("bundles/common", function () { });

